[{"title":"二维码生成外链(判断是否是微信扫描）","date":"2018-12-26T12:35:10.000Z","path":"2018/12/26/二维码生成外链(判断是否是微信扫描）/","text":"需求通过二维码生成 sketch 下载链接，可以扫描下载 问题初始方案：通过二维码生成 sketch 静态资源链接，然而 用安卓微信是直接解析的，会直接下载文件，用IOS 手机微信扫描后会产生乱码 改进方案通过二维码生成一个静态 HTML 的页面，并判断“用户代理” 信息，确认是否是微信客户端，从而实现返回不同的文字效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Download&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; html, body &#123; height: 100%; width: 100%; &#125; #holder &#123; height: 25%; &#125; #content &#123; text-align: center; &#125; #content p &#123; font-size: 20px; line-height: 36px; margin-bottom: 20px; &#125; #link &#123; display: inline-block; width: 80%; color: #2D71DB; text-align: left; font-size: 12px; word-break:break-all; &#125; #link a &#123; color: #2D71DB !important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"holder\"&gt;&lt;/div&gt; &lt;div id=\"content\"&gt; &lt;p&gt; &lt;span id=\"tar\"&gt;请复制网址后使用浏览器下载&lt;/span&gt;&lt;br&gt; 或发送下载链接至PC端微信下载 &lt;/p&gt; &lt;div id=\"link\"&gt; https://obs-cn-shanghai.yun.pingan.com/xdc/PAT%20Design%20UI%20Kit%20Orange_V1.1.sketch?response-content-disposition=attachment%3Bfilename%3DPAT%2520Design%2520UI%2520Kit%2520Orange_V1.1.sketch &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var ua = navigator.userAgent.toLocaleLowerCase(); var isWeixin = ua.indexOf('micromessenger') != -1; var tar = document.getElementById('tar'); var link = 'https://obs-cn-shanghai.yun.pingan.com/xdc/PAT%20Design%20UI%20Kit%20Orange_V1.1.sketch?response-content-disposition=attachment%3Bfilename%3DPAT%2520Design%2520UI%2520Kit%2520Orange_V1.1.sketch'; var linkWrap = document.getElementById('link'); if (!isWeixin) &#123; tar.innerText = '可点击直接下载'; linkWrap.innerHTML = '&lt;a href=\"' + link + '\"&gt;' + link + '&lt;/a&gt;'; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最终效果浏览器 微信","tags":[]},{"title":"node 命令","date":"2018-12-25T13:54:33.000Z","path":"2018/12/25/node 命令/","text":"12# 查询全局模块路径npm root -g # /usr/local/lib/node_modules","tags":[]},{"title":"webpack 工作原理","date":"2018-12-24T10:24:23.000Z","path":"2018/12/24/webpack 工作原理/","text":"tags: [组件]categories: 底层原理及基础 流程概括 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，通过执行对象的 run 方法开始执行编译 确定入口：根据配置中的 entry 找出所有入口文件 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理 完成模块编译：在经过","tags":[]},{"title":"mobx","date":"2018-12-23T02:45:00.000Z","path":"2018/12/23/mobx/","text":"mobx状态管理工具 VS Redux 开发难度低：redux函数式编程思想；mobx响应式编程风格，同时集成度高，避免引入众多第三方库 开发代码量少：redux有reducer等众多概念，而mobx只要在store中更新即可 渲染性能好：redux通过shouldComponentUpdate优化，但是当应用大到一定程度，就比较难实现；mobx精确的指出了哪些需要重复渲染，将re-render限制在最小范围之内 mobx核心思想 状态变化引起的副作用应该被自动触发 数据流：类redux单向数据流模式（action =》 State =〉Reaction） 基础知识实现继承和多态1234567mkdir mobx_testcd mobx_testmkdir srctouch src/index.jsnpm init -ytouch webpack.config.jsyarn add webpack webpack-cli babel-core babel-preset-env babel-loader -D 配置webpack.config.js 1234567891011121314151617181920212223const path = require('path')module.exports = &#123; mode: 'development', // 'production' entry: path.resolve(__dirname, 'src/index.js'), output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'main.js', &#125;, module: &#123; rules: [&#123; test: /\\.js$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['env'], &#125; &#125; &#125;] &#125;, devtool: 'inline-source-map', // 方便调试&#125; 配置package.json 123\"scripts\": &#123; \"start\": \"webpack -w\" // -w：js文件更改自动执行编译 &#125;, 编写index.html123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src= \"src/index.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 编写src/index.js 用原生实现继承和多态 继承：Dog.prototype.proto === Animal.prototype 多态：重写Dog的name属性 Dog的原型对象的构造函数应该指向Dog而不是Animal 12345678910111213141516171819202122232425262728293031323334353637function Animal() &#123; // body...&#125;function Dog() &#123; // body...&#125;Object.defineProperties(Animal.prototype, &#123; name: &#123; value() &#123; return 'Animal' &#125; &#125;, say: &#123; value() &#123; return `I'm $&#123;this.name()&#125;` &#125; &#125;&#125;)// dog instanceOf Animal === true// dog.__proto__.__proto__ === Animal.prototype// dog.__proto__ === Dog.prototype// Dog.prototype.__proto__ === Animal.prototypeDog.prototype = Object.create(Animal.prototype, &#123; constructor: &#123; value: Dog, enumerable: false, &#125;, name: &#123; value() &#123; return `Dog` &#125; &#125;&#125;)// document.write(new Dog() instanceOf Animal())// document.write(new Dog().say())document.write(Dog.prototype.constructor) 通过ES6来实现 12345678910111213141516class Animal &#123; name() &#123; return 'Animal' &#125; say() &#123; return `I'm $&#123;this.name()&#125;` &#125;&#125;class Dog extends Animal &#123; name() &#123; return 'Dog' &#125;&#125;console.log(new Dog() instanceOf Animal 安装babel插件，使其支持在类中声明成员变量yarn add babel-plugin-transform-class-properties -D配置webpack.config.jsmodule.rules下面的use.plugins: [‘transform-class-properties’] decoratorDecorator是在声明阶段实现类与类成员注解的一种语法.本质上是特殊的函数。 安装babel插件yarn add babel-plugin-transform-decorators-legacy -D配置webpack.config.jsmodule.rules下面的use.plugins: [‘transform-decorators-legacy’] mobx 常用 API安装mobx依赖：yarn add mobx observable(可观察的数据)是一种让数据的变化可以被观察的方法 哪些数据可以被观察： 原始类型：String | Number | Boolean | Symbol 对象 数组 PS：一定要检查数组的长度以避免越界访问，在mobx中越界的数组值是不被观察的.同样要检查对象是否含有属性hasOwnProperty 1234567891011import &#123; observable &#125; from 'mobx';class Store &#123; @observable array = [] @observable obj = &#123;&#125; @observable map = new Map() @observable string = 'hello' @observable number = 20 @observable bool = false&#125; 对可观察的数据作出反应方式： computed observe() get() autorun when reaction mobx 实现 todoListyarn add mobx-react react react-dom prop-typesyarn add babel-preset-react 配置webpack.config.jspresets: [[&#39;env&#39;, &#39;react&#39;]], 资源mobx-state-tree","tags":[]},{"title":"单元测试","date":"2018-12-23T02:25:20.000Z","path":"2018/12/23/单元测试/","text":"前言前端单测是一个可有可无的东西？ 写单测比较费时，有这个时间不如多做几个需求！ 测试在验收的时候对页面的功能都会操作一遍，写单测相当于无用功 后端提供给前端的接口需要保证质量，因此需要做单测，但前端很少需要提供接口给其他人。 什么情况下需要单测在大部分情况下，如果公司业务不复杂，我是认同完全没有必要做单测的观点的。但如果涉及到了以下几个方面，则要好好考虑一下： 业务比较复杂，前端参与的人员超过3人 公司非常注重代码的质量，想尽一切办法杜绝线上出bug 是跨项目组件的提供方 在做一个开源项目 组件化单测的必要性： 虽然单元测试需要花费时间且所花时间会比模块本身更多，但是性价比却是随着使用的次数越来越高 在工作中或开源社区中，我们写库的目的都是为了能更好的为别人使用，这个时候单元测试应该是必须的 好的单元测试可以作为优秀的文档，并且保证模块行为的确定性。 UI库并不涉及业务逻辑，所以只写单元测试足够 测哪些方面 模块应被渲染的DOM树是否正确 模块的属性传递是否正确,(属性是方法,则是否被正确调用;属性是布尔值或对象,则是否被正确传递且达到预期的目的） 模块内的各个行为是否正确 甚至可以测试各个DOM节点是否被应用预期的class，且这些class是不是预期的样式 测试工具 Jest是Facebook开发的一个测试框架，它集成了测试执行器、断言库、spy、mock、snapshot和测试覆盖率报告等功能。React项目本身也是使用Jest进行单测的，因此它们俩的契合度相当高。 Enzyme是由airbnb开发的React单测工具。它扩展了React的TestUtils并通过支持类似jQuery的find语法可以很方便的对render出来的结果做各种断言。 \bJEST 跑一个简单的测试用例 技术栈：React@16 + webpack@3 编写测试用例流程： Arrange（准备）：设置测试场景，准备测试数据 Act（执行）：调用被测试代码 Assert（断言）：验证被测代码是否与预期相同 安装Jest并让其支持ES6语法1npm install --save-dev jest jest-cli babel-jest # babel-jest的作用是让单测代码支持ES6 \b新建单测文件夹并新建一个单测文件1.在项目的根目录新建__jest__文件夹和\bcomponents文件夹 __jest__ __mocks__ __tests__ mudules // 存放各个模块的单测代码 utils // 对一些公用函数写的测试代码 sum.test.js // 单测用例 components Math.js // 被测试对象 2.新建单测文件 123456// __jest__/__test__/sum.test.jsconst sum = require('../../../components/Math');test('adds 1 + 2 to equal 3', () =&gt; &#123; expect(sum(1, 2)).toBe(3);&#125;); 1234function sum(a, b) &#123; return a + b;&#125;module.exports = sum; 配置package.json1234567891011121314151617\"jest\": &#123; // moduleFileExtensions对应webpack中的extensions； \"moduleFileExtensions\": [ \"js\", \"jsx\" ], // moduleDirectories对应webpack中的modulesDirectories； \"moduleDirectories\": [ \"node_modules\" ], // moduleNameMapper对应webpack中的alias \"moduleNameMapper\": &#123; \"\\\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$\": \"&lt;rootDir&gt;/__jest__/__mocks__/fileMock.js\", \"\\\\.(css|scss)$\": \"identity-obj-proxy\", // 对于css等样式文件，使用identity-obj-proxy来mock，它会在引用到class的地方直接返回class的类名 \"^cpn(.*)$\": \"&lt;rootDir&gt;/src/components$1\" //这里的&lt;rootDir&gt;对应我们项目的根目录。 &#125; &#125; 同时添加以下script： 123\"scripts\": &#123; \"test\": \"jest __jest__/__tests__\"&#125; 运行测试脚本在命令行输入：npm run test出现以下结果，则说明Jest安装成功并通过第一个测试!👏 create-react-app create-react-app 自带 Jest 库 Jest 会自动在当前目录下寻找满足条件的JS文件作为单测代码来执行 文件名以 .test.js 为后缀的代码文件 存于 _test_ 目录下的代码文件 目录结构 在根目录创建test目录，单测文件以 .test.js 为后缀 在每个组件目录下创建 _test_ 子目录 语法测试用例it()1234// 它在什么样的情况下是什么行为it(&apos;should return object when invoked&apos;, () =&gt; &#123; // 增加断言语句&#125;) 测试套件 describe() 测试套件 = 测试用例 + 测试套件 从外到里顺序执行 重用共同的环境设置 123456describe('action', () =&gt; &#123; it('should return object when invoked', () =&gt; &#123; // 增加断言语句 &#125;) // 可以有更多的it函数调用&#125;) 钩子函数 beforeAll: 在开始测试套件开始之前执行一次 afterAll: 在结束测试套件中所有测试用例之后执行一次 beforeEach: 每个测试用例在执行之前都执行一次 afterEach: 每个测试用例在执行之后都执行一次","tags":[]},{"title":"项目启动流程","date":"2018-12-23T02:19:17.000Z","path":"2018/12/23/项目启动流程/","text":"前言假设接到一个新项目，首先考虑以下几点 使用何种类库，如何考虑技术选型？分别从哪几个维度去考虑？ 项目目录如何组织(按角色还是按功能) dev和prod不同环境如何配置 团队内部其他系统都用了什么 多人合作开发，团队环境和代码规范问题如何解决?是否需要统一编辑器 是否需要出文档，教其他团队成员配置环境、安装依赖等 如果每个项目皆是如此，请考虑效率？(脚手架、cli) 如何稳定高效的推动项目，请考虑成本收益比，并考虑项目所需的人力、物力的各项支持 技术框架选型考虑以下几个问题： 框架自身成熟度？ 框架生态圈 框架主要解决什么问题？ 团队：学习成本 项目周期： 项目维护成本 结论：最终决定在中小型项目中使用Vue，而大中型项目中使用React，而对于金融科技公司而言，中台复杂项目较多，从而选定以React为主，当项目周期短且交付压力大时仍采用使用Vue的策略。 项目目录按角色12345678reducers/ #包含所有Redux 的reducer; todoReducer.jsactions/ #包含所有action 构造函数； todoActions.jscomponents/ #包含所有的傻瓜组件； todoList.jscontainers/ #包含所有的容器组件。 todoListContainer.js “按照角色组织”的方式非常不利于应用的扩展。当你需要对一个功能进行修改，虽然这个功能只是针对某一个具体的应用模块，但是却牵扯到多个角色，而不得不在多个目录间跳转。 按功能12345678910111213141516todoList/ actions.js #定义action 类型； actionTypes.js #定义action 构造函数，决定了这个功能模块可以接受的动作； index.js #导出该组件需要导出的所有内容，每个文件夹下都包含一个index文件也有利于直接引用文件夹名称就可以导出模块 reducer.jS #定义这个功能模块如何对应actions.js 中定义的动作； views/ #包含这个功能模块中所有的React 组件 component.js #傻瓜组件 container.js #容器组件filter/ actions.js actionTypes.js index.js reducer.js views/ component.js container.js 每个功能模块对应一个目录，每个目录下包含同样名字的角色文件。当需要修改某个功能模块的代码时，只要关注对应的目录即可，所有需要修改的代码文件都能在当前目录下找到。 脚手架为什么不用create-react-app 不满足当前团队的需求 不可以定制化，需要二次修改配置 没有开发组件的能力 结论：为什么不自己开发一个cli工具呢？？ yeoman npm install yo -g 把全局环境node_modules包下面的模板工程 copy 到你的当前项目路径文件夹下","tags":[]},{"title":"机器学习","date":"2018-12-23T01:50:20.000Z","path":"2018/12/23/机器学习/","text":"Python 廖雪峰 Python 教程 Python 入门教程 Tensorflow Tensorflow中文文档 资源 机器学习干货Top10，附项目地址 机器学习速成课程","tags":[]},{"title":"开源管理","date":"2018-12-23T01:45:43.000Z","path":"2018/12/23/开源管理/","text":"督导小组 核心功能的监督把控， 整体功能的规划设计， 督导新功能的引入， 制定开发计划， 提交代码 Review 编译小组 代码文件编译到不同端的实现， 微信小程序端 JSX 编译， 快应用端 JSX 编译等 ESLint 插件维护 开发工具小组负责 cli 工具的开发与优化工作 组件库小组 标准组件库的规范制定、 文档编写， 标准组件库在不同端的实现， 标准组件库官网建设 运行框架小组 负责不同端运行框架的实现 端能力 API 小组 端能力 API 的规范制定、 端能力 API 的文档编写， 端能力 API 在不同端的实现 UI 库小组 负责 Dbox UI 库的实现 社区维护小组 社区内答疑解惑， GitHub ISSUE 维护， 问题搜集， 社区项目发起与引导， 第三方库适配与生态管理等","tags":[]},{"title":"如何做一个 Github 开源项目","date":"2018-12-23T01:44:09.000Z","path":"2018/12/23/如何做一个 Github 开源项目/","text":"适合开源 cache工具(缓存工具，整合localStorage,以及合理的内存销毁机制) query2json,解析url参数为json格式 移动端打印console.log,方便移动端输出内容 版本号 一级：重构版本 二级：重大功能改进 三级：小升级或者bug修复 0.X.X: 非正式版本 目录结构 src: 源代码 release: 发布结果 test：单元测试用例 doc: 文档 example：实例 Readme 产品简介(此处要突出特点，打差异化竞争) 产品安装和下载 快速使用(详细的使用文档或者二次开发文档，外链即可) 交流提问区(QQ、微信群) 关于作者(博客链接和收款二维码) 文档和测试用例1234npm i gitbook-cli -gSUMMARY.mdgitbook initgitbook build 配置.gitignore加上_book 发布npm模块123npm add usernpm loginnpm publish . 不能重名 升级 新建分支 修改版本号 修改代码、文档和测试用例 自测 将新的分支提交到远程 再次确认版本号，因为版本号非常重要 将新的分支合并到master，并提交master到远程 创建tag并提交到远程 提交到npm 宣传一个公司的核心竞争力，一是技术，二是营销。 博客围绕产品功能第一类技术干货文章第二类产品介绍以第一类为主 如何 坑 预防 总结 半年记 回答相关的问题 知乎 sf.gg stackoverflow 字数只能多不能少，最好图文并茂，还能讲个笑话 回答要专业，经过亲自测试，不要想当然的瞎猜 回答问题的最后，顺便推广自己的产品 需求采纳 很多用户都提过这个需求，即大众需求 自己判断这个需求对大部分用户都有用 该需求符合产品定位以及产品发展的方向 该需求能抹平和竞品的差距，或者能和竞品差异化竞争","tags":[]},{"title":"微博运营","date":"2018-12-23T01:42:52.000Z","path":"2018/12/23/微博运营/","text":"微博运营 微博重点扶持行业：母婴、金融、汽车、美妆、饮料等 要想有粉丝 》要先有曝光 》先有流量 平台根据用户反馈给内容分配流量：微博是通过1个小时内评判流量是否倾斜 符合平台运营的基本规范 + 生产用户喜欢的优质内容 微博加权规则 账号因素： 认证：媒体账号 会员 绑定手机号 丰富账号信息 内容因素：热门话题 | 九图 | 头条文章 | 视频 微博降权 不被推荐到热门流 减少部分曝光量 减少大部分曝光量 封号 向外引流：微信 | 抖音 广告关键词： 易导致账号被降权，降低在热门展现的几率或者是禁止展现 “购买” “优惠” “券”等 淘宝 | 京东 | 亚马逊 | 。。。| 5 折。。。都要避免 电商领域会有外链的特权 微博向微信引流 将微信号插在图片，被监测的几率相对较低 设置私信自动回复，用“VX”字样 微博蹭热搜、公众号蹭热点 选择可蹭的话题 撰写蹭热文案：关键词必须相同、完全关联，且要保证文案的相关性 长文关注： 新账号扶植功能，仅粉丝可阅读全文，否则需关注账号看全文 总粉丝两万以下的账号有此功能，一旦突破，功能自动取消 利用大 V 流量增粉 找垂直领域大V 谈价格 写文章 资源公众号运营工具导航","tags":[]},{"title":"this 指向","date":"2018-12-23T01:30:22.000Z","path":"2018/12/23/this 指向/","text":"this 介绍this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境 this的指向 作为对象的方法调用：指向该对象 作为普通函数调用：指向全局对象(严格模式下：undefined) 构造器调用 Function.prototype.call 或 Function.prototype.apply 调用 document.getElementById()的内部实现中需要用到this，并且这个this被期望指向document 123456789document.getElementById = ( function(func) &#123; return function() &#123; return func.apply(document, arguments) &#125; &#125;)(document.getElementById)var getId = document.getElementById call &amp;&amp; apply当使用 call 或 apply 时，如果我们传入的第一个参数为null, 函数体内的 this 会指向默认的宿主对象，在浏览器中则是window.但是在严格模式下，函数体内的 this 还是为 null 有时候使用 call 或 apply 的目的不在于指定 this 指向，而是借用其他对象的方法 如 Math.max.apply(null, [1,2,3,4,5]) 等同于 Math.max(…[1,2,3,4,5]) 改变this的指向123456789101112131415161718Function.prototype.bind = function() &#123; var self = this // 保存原函数 var context = [].shift.call(arguments) // 需要绑定的 this 上下文 var args = [].slice.call(arguments) // 剩余的参数转成数组 return function() &#123; // 返回一个新的函数 return self.apply(context, [].concat.call(args, [].slice.call(arguments))) // 执行新的函数的时候，会把之前传入的context当作新函数体内的this // 并且组合两次分别传入的参数，作为新函数的参数 &#125;&#125;var obj = &#123; name: 'lulu'&#125;var func = function(a, b, c, d) &#123; alert(this.name) alert([a, b, c, d])&#125;.bind(obj, 1, 2)func(3, 4) 借用其他对象的方法 借用构造函数，从而实现一些类似继承的效果 1234567891011var A = function(name)&#123; this.name = name&#125;var B = function() &#123; A.apply(this, arguments)&#125;B.prototype.getName = function(name) &#123; return this.name&#125;var b = new B('lulu')console.log(b.getName()) // lulu 操作arguments对象时借用Array.prototype上的方法 向 arguments 中添加一个新的元素：Array.prototype.push.call(arguments, …) 把 arguments 转换成一个真的数组：Array.prototype.slice.call(arguments) 截去 arguments 的头一个元素：Array.prototype.shift.call(arguments) 1234(function() &#123; Array.prototype.push.call(arguments, 3) console.log(arguments) // [1,2,3]&#125;)(1,2) 12345678910// V8 源码实现上面的代码function ArrayPush () &#123; var n = TO_UINT32(this.length) // 被 push 的对象的 length var m = %_ArgumentsLength() // push 的参数个数 for (var i = 0; i &lt; m; i++) &#123; this[n + i] = %_Arguments[i] // 对象本身要可以存取属性 &#125; this.length = n + m // 修正 length 属性的值 return this.length // 对象的 length 属性要可读写&#125;","tags":[]},{"title":"闭包和高阶函数","date":"2018-12-23T01:04:56.000Z","path":"2018/12/23/闭包和高阶函数/","text":"closure看是否对自由变量进行了捕获 变量作用域 函数作用域 全局作用域 作用域链：变量的搜索从内而外。函数像一层半透明的玻璃，在函数里面可以看到函数外面的变量，而函数外面则无法看到函数里面的变量 变量的生命周期 全局变量：永久，除非主动销毁 局部变量：退出函数时就没有了价值，即随着函数调用的结束而被销毁 闭包的作用 封装变量 延续局部变量的寿命 12345678910111213// 然而闭包可以延续局部变量的生命周期var func = function() &#123; var a = 1; return function() &#123; a++; alert(a) &#125;&#125;var f = func()f() // 2f() // 3f() // 4f() // 5 当退出函数时，局部变量a并没有消失，而是似乎一直在某个地方存活着。这是因为当执行var f = func()时，f返回了一个匿名函数的引用，它可以访问到func()被调用时产生的环境，而局部变量a一直处在这个环境里。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。 1234567891011var Type = &#123;&#125;for (var i = 0; type = ['String', 'Array', 'Number']; i++) &#123; (function(type)&#123; Type[`is$&#123;type&#125;`] = function(obj) &#123; return Object.prototype.toString.call(obj) === '[object $&#123;type&#125;]' &#125; &#125;)(type)&#125;Type.isArray([])Type.isString('str') 1234567891011121314// 对于相同的参数来说，每次都进行计算时一种浪费，引入缓存机制提高函数性能var cache = &#123;&#125;;function mult() &#123; var args = Array.prototype.join.call(arguments, ',') if (cache[args]) return cache[args] var result = 1 for (var i = 0; i &lt; arguments.length; i++) &#123; result = result * arguments[i] &#125; return cache[args] = result&#125;console.log(mult(1, 2, 3)) // 6console.log(mult(1, 2, 3)) // 6console.log(cache) 代码重构：1. 去掉全局变量 2. 独立可复用的代码12345678910111213141516171819202122var mult = ( function()&#123; var cache = &#123;&#125;; return function () &#123; var args = Array.prototype.join.call(arguments, ',') if (cache[args]) return cache[args] // return cache[args] = calculate.apply(null, arguments) // null 即 windows 对象 return cache[args] = calculate(...arguments) &#125; &#125;)()var calculate = function () &#123; var result = 1 for (var i = 0; i &lt; arguments.length; i++) &#123; result = result * arguments[i] &#125; return result&#125;console.log(mult(1, 2, 3)) // 6console.log(mult(1, 2, 3)) // 6 12345678var report = function (src) &#123; var imgs = [] return function(src)&#123; var img = new Image() imgs.push(img) img.src = src &#125;&#125; 面向对象设计 过程与数据的结合是形容面向对象中的“对象”时经常使用的表达对象以方法的形式包含了过程而闭包则是在过程中以环境的形式包含了数据 12345678910111213// 闭包var extent = function() &#123; var value = 0 return &#123; call: function() &#123; value++ console.log(value) &#125; &#125;&#125;var extent = extent()extent.call()extent.call() 1234567891011// 面向对象var extent = &#123; value: 0, call: function() &#123; this.value++ console.log(this.value) &#125;&#125;extent.call() // 1extent.call() // 2extent.call() // 3 123456789101112// 构造函数var Extent = function() &#123; this.value = 0&#125;Extent.prototype.call = function() &#123; this.value++ console.log(this.value)&#125;var extent = new Extent()extent.call() // 1extent.call() // 2extent.call() // 3 用闭包实现命令模式命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者(执行者)之间的耦合关系。在命令被执行之前，可以预先往命令对象中植入命令的接收者。12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;div&gt; &lt;button id=\"execute\"&gt;点我执行命令&lt;/button&gt; &lt;button id=\"undo\"&gt;点我执行命令&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var Tv = &#123; open: function() &#123; console.log('打开电视机') &#125; close: function() &#123; console.log('关上电视机') &#125; &#125; var OpenTvCommand = function(receiver) &#123; this.receiver = receiver &#125; OpenTvCommand.prototype.execute = function() &#123; this.receiver.open() // 执行命令，打开电视机 &#125; OpenTvCommand.prototype.undo = function() &#123; this.receiver.close() // 执行命令，关闭电视机 &#125; var setCommand = function(command) &#123; document.getElementById('execute').onclick = function() &#123; command.execute() &#125; document.getElementById('undo').onclick = function() &#123; command.undo() &#125; &#125; setCommand(new OpenTvCommand(Tv)) &lt;/script&gt;&lt;/body&gt; 12345678910111213141516171819202122232425262728293031&lt;script type=\"text/javascript\"&gt; var Tv = &#123; open: function() &#123; console.log('打开电视机') &#125; close: function() &#123; console.log('关上电视机') &#125; &#125; var createCommand = function(receiver) &#123; var execute = function() &#123; return receiver.open() // 执行命令，打开电视机 &#125; var undo = function() &#123; return receiver.close() // 执行命令，关闭电视机 &#125; return &#123; execute: execute, undo: undo &#125; &#125; var setCommand = function(command) &#123; document.getElementById('execute').onclick = function() &#123; command.execute() &#125; document.getElementById('undo').onclick = function() &#123; command.undo() &#125; &#125; setCommand(createCommand(Tv)) &lt;/script&gt; 闭包与内存管理局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的。如果在将来需要回收这些变量，可以手动把这些变量设为null 使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些DOM节点，就有可能造成内存泄露。在IE浏览器中，由于 BOM 和 DOM 中的对象是使用 C++ 以 COM 对象的方式实现的，而 COM 对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收。 高阶函数 函数可以作为参数被传递 函数可以作为返回值输出 作为参数被传递分离业务代码中变化和不变的部分 回调函数 异步请求 当一个函数不适合执行一些请求时，可以把这些请求封装成一个函数，“委托”给另外一个函数来执行 作为返回值输出123456789101112var getSingle = function(fn) &#123; var ret return function() &#123; return ret || (ret = fn.apply(this, arguments)) &#125;&#125;var getScript = getSingle(function() &#123; return document.createElement('script')&#125;)var script1 = getScript()var script2 = getScript()alert(script1 === script2) // true 高阶函数实现AOPAOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。123456789101112131415161718192021222324252627Function.prototype.before = function(beforefn) &#123; var _self = this // 保存原函数的引用,this 值是func -&gt; &#123;console.log(2)&#125; return function() &#123; // 返回包含了原函数和新函数的“代理”函数 beforefn.apply(this, arguments) // 执行新函数，修正this,this是window return _self.apply(this, arguments) // 执行原函数 &#125;&#125;Function.prototype.after = function(afterfn) &#123; var _self = this // this 值是“代理”函数 return function() &#123; var ret = _self.apply(this, arguments) afterfn.apply(this, arguments) return ret &#125;&#125;var func = function() &#123; console.log(2) return 2&#125;func = func.before(function() &#123; console.log(1) return 1&#125;).after(function() &#123; console.log(3) return 3&#125;)func() currying一个柯里化的函数首先会接受一些参数，接受了这些参数之后，该参数并不会立即求值，而是继续返回另一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值 12345678910111213141516171819var cost = ( var args = [] return function()&#123; if (arguments.length === 0)&#123; var money = 0 for(var i = 0; i &lt; args.length; i++) &#123; money += args[i] &#125; return money &#125; else &#123; [].push.apply(args, arguments) &#125; &#125;)()cost(100) // 未真正求值cost(200) // 未真正求值cost(300) // 未真正求值console.log(cost()) 1234567891011121314151617181920212223242526272829var currying = function(fn) &#123; var args = [] return function() &#123; if(arguments.length === 0)&#123; return fn.apply(this, args) &#125; else &#123; [].push.apply(args, arguments) console.log('arguments', arguments, arguments.callee ) return arguments.callee &#125; &#125;&#125;var cost = (function()&#123; var money = 0 return function()&#123; for (var i = 0; i &lt; arguments.length; i++) &#123; money += arguments[i] &#125; return money &#125;&#125;)()var cost = currying(cost)cost(100) // 未真正求值cost(200) // 未真正求值cost(300) // 未真正求值alert(cost()) // 求值并输出： 600 1234567891011121314Function.prototype.uncurrying = function() &#123; var self = this console.log(this) return function() &#123; var obj = Array.prototype.shift.call(arguments) console.log(arguments) return self.apply(obj, arguments) &#125;&#125;var push = Array.prototype.push.uncurrying()(function()&#123; push(arguments, 4) console.log(arguments)&#125;)(1,2,3) 123456Function.prototype.uncurrying = function() &#123; var self = this return function() &#123; return Function.prototype.call.apply(self, arguments) &#125;&#125; 1234567891011121314151617181920Function.prototype.uncurrying = function() &#123; var self = this return function() &#123; var obj = Array.prototype.shift.call(arguments) return self.apply(obj, arguments) &#125;&#125;var Arg = &#123;&#125;for (var i = 0, fn, arr = ['push', 'shift', 'forEach']; fn = arr[i++];) &#123; console.log(fn) Arg[fn] = Array.prototype[fn].uncurrying()&#125;var obj = &#123; 'length': 3, '0': 1, '1': 2, '2': 3&#125;Arg.push(obj, 4) // 向对象中添加一个元素console.log(obj.length) // 4 函数节流有些情况下，函数的触发不是由用户直接控制的，这样当函数被非常频繁的调用时，会造成大的性能问题。 场景 window.onresize()：给window对象绑定了resize事件，当浏览器窗口大小被拖动而改变的时候，这个事件触发的频率非常之高。如果我们在window.onresize事件函数里有一些跟DOM节点相关的操作，而跟DOM节点相关的操作往往是非常消耗性能的，这时候浏览器可能就会吃不消而造成卡顿现象。 mousemove()：同样，给一个div节点绑定了拖拽事件(主要是mousemove),div节点被拖动的时候，也会频繁地触发该拖拽事件函数 上传进度：微云的上传功能使用了一个浏览器插件。该插件在真正开始上传文件之前，会对文件进行扫描并随时通知JS函数，以便在页面中显示当前的扫描进度。但该插件通知的频率非常之高，约10s一次 原理当函数被触发的频率太高时，需要按时间段来忽略掉一些事件请求，借助setTimeout来完成 将即将被执行的函数用setTimeout延迟一段时间执行。如果该次延迟执行还没有完成，则忽略接下来调用该函数的请求 一定要等当前执行的事件执行完了，才会让新的事件进来，否则全部作废 12345678910111213141516171819202122232425var throttle = function(fn, interval) &#123; var _self = fn, // 保存需要被延迟执行的函数引用 timer, // 定时器 firstTime = true; // 是否是第一次调用 return function() &#123; var args = arguments, _me = this; if (firstTime) &#123; // 如果是第一次调用，不需要延迟执行 _self.apply(_me, args) return firstTime = false &#125; if (timer) &#123; // 如果定时器还在，说明前一次延迟执行还没有完成 return false &#125; timer = setTimeout(function() &#123; // 延迟一段时间执行 clearTimeout(timer) timer = null _self.apply(_me, args) &#125;, interval || 500) &#125;&#125;window.onresize = throttle(function() &#123; console.log(1)&#125;, 500) 函数防抖12 场景 搜索引擎搜索：希望用户在输入完最后一个字才调用查询接口，适用延迟执行的防抖函数， 分时函数在短时间内大量触发请求会严重影响页面性能，解决方案之一是让这些请求分批进行，比如把1秒钟创建1000个节点，改为每隔200毫秒创建8个节点 1234567891011121314151617181920212223// 创建节点时需要用到的数据// 封装了创建节点逻辑的函数// 每一批创建的节点数量var timeChunk = function(ary, fn, count) &#123; var obj, t var len = ary.length var start = function () &#123; for (var i = 0; i &lt; Math.min(count || 1, ary.length); i++) &#123; var obj = ary.shift() fn(obj) &#125; &#125; return function() &#123; t = setInterval(function() &#123; if (ary.length === 0) &#123; // 如果全部节点都已经被创建好 return clearInterval(t) &#125; start() &#125;, 200) // 分批执行的时间间隔，也可以用参数的形式传入 &#125;&#125; 资源7分钟理解JS的节流、防抖及使用场景","tags":[]},{"title":"消息机制","date":"2018-12-23T00:52:20.000Z","path":"2018/12/23/消息机制/","text":"消息机制是软件工程中一个普遍运用的工程思想。 “设计模式”中的观察者模式 Windows 操作系统底层 Spring 框架中的 ApplicationListener 模块 Objective-C 语言中的函数调用都是通过消息机制驱动的。 使用消息机制最大的好处在于可以做到业务模块间安全解耦，模块间通过发送消息的方式进行协作。 非消息机制案例我们先举一个后端开发中的例子，下图是一个简单的预定系统的建模图，并没有使用消息机制： 在没有消息机制的情况下，用户模块需要知道订单模块的存在，并向其进行接口调用，同理订单模块需要向支付模块进行接口调用。这种设计下模块间是耦合的。 消息机制案例 上图中，无论是客户下订单、支付还是预定都是通过消息的方式传递的，每个模块都是向一个消息处理器起发消息，同时也监听消息处理器发送回来的消息。在这种模式下，模块完全不知道其它模块的存在，彻底做到了解耦。 消息机制在前端中的应用在前端业务开发中，我们经常也会用到 EventEmitter 库来进行消息传递。比如页面上有两块区域，一块用 React 框架渲染，一块用 D3 渲染的，当两块区域需要数据同步时，就可以使用消息机制进行通讯，保证页面数据整体一致。 如果你的业务中有不同生命周期的组件，建议采用消息机制进行管理，不仅消除了耦合，逻辑关系部分的代码也集中到了一个文件中，内聚性得到了提升。 使用消息机制的一个附属产物就是中间件，我们可以为消息定制各种中间件，在中间中完成一些通用逻辑，让业务代码更精炼。 说到前端框架中消息机制的运用，当然首推 Redux 框架，在 Redux 框架中，任何数据交互都需要先转化为一个 action，由 action 去触发 reducer 和相关的 middleware 处理 action，改变数据，最终同步到页面 UI 上，如下图所示：","tags":[]},{"title":"设计模式及设计原则","date":"2018-12-23T00:47:22.000Z","path":"2018/12/23/设计模式及设计原则/","text":"面向对象 三要素 继承：子类继承父类 封装：数据的权限和保密 多态：同一接口不同实现 123456789101112131415161718192021222324252627282930313233// 父类class People &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; eat() &#123; alert(`$&#123;this.name&#125; eat something`) &#125; speak() &#123; alert(`$&#123;this.name&#125;: age $&#123;this.age&#125;`) &#125;&#125;// 子类继承父类class Student extends People &#123; constructor(name, age, number)&#123; super(name, age) this.number = number &#125; study() &#123; alert(`$&#123;this.name&#125; study`) &#125;&#125;// 实例let xiaoming = new Student('xiaoming', 10, 'A1')xiaoming.study()xiaoming.eat()let wangxin = new Student('wangxin', 10, 'A2')wangxin.study()wangxin.speak() 继承* People是父类，公共的，不仅仅服务于Student * 继承可将公共方法抽离出来，提高复用，减少冗余 封装(ES6尚不支持，TS支持) 定义属性关键字： * public: 完全开放；前面如果不写关键字，那么默认是public * protected: 对子类开放 * private: 对自己开放 [TypeScript](http://www.typescriptlang.org/play/index.html) 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 父类class People &#123; name age protected weight // 对子类开放 constructor(name, age) &#123; this.name = name this.age = age this.weight = 120 &#125; eat() &#123; alert(`$&#123;this.name&#125; eat something`) &#125; speak() &#123; alert(`$&#123;this.name&#125;: age $&#123;this.age&#125;`) &#125;&#125;// 子类继承父类class Student extends People &#123; number private girlFriend constructor(name, age, number)&#123; super(name, age) this.number = number this.girlfriend = 'lu' &#125; study() &#123; alert(`$&#123;this.name&#125; study`) &#125; getWeight() &#123; alert(`weight: $&#123;this.weight&#125;`) &#125;&#125;// 实例let xiaoming = new Student('xiaoming', 10, 'A1')xiaoming.study()xiaoming.eat()xiaoming.getWeight()xiaoming.girlFriend // 编译时会报错，直接会编译不通过！！！let wangxin = new Student('wangxin', 10, 'A2')wangxin.study()wangxin.speak() * 减少耦合，不该外露的不外露 * 利于数据、接口的权限管理 * ES6 不支持，一般认为以\\_开头的属性是 private 多态* 同一个接口，不同表现 * JS应用极少 * 需要结合java等语言的接口、重写、重载等功能 12345678910111213141516171819202122232425262728293031// 父类class People &#123; constructor(name, age) &#123; this.name = name this.age = age this.weight = 120 &#125; saySomething() &#123; &#125;&#125;class A extends People &#123; constructor(name) &#123; super(name) &#125; saySomething() &#123; alert(`I am A : $&#123;this.name&#125;`) &#125;&#125;class B extends People &#123; constructor(name) &#123; super(name) &#125; saySomething() &#123; alert(`I am B : $&#123;this.name&#125;`) &#125;&#125;let a = new A('a')a.saySomething()let b = new B('b')b.saySomething() * 保持子类的开放性和灵活性 * 面向接口编程 * JS引用极少，了解即可 jQuery 应用举例* jQuery是一个class * \\$(&apos;p&apos;)是jQuery的一个实例 1234567891011121314151617181920212223242526272829303132333435class jQuery &#123; constructor(selector) &#123; let slice = Array.prototype.slice let dom = slice.call(document.querySelectorAll(selector)) let len = len ? dom.length : 0 for (let i = 0; i &lt; len; i++) &#123; this[i] = dom[i] &#125; this.length = len this.selector = selector || '' &#125; append(node) &#123; // ... &#125; addClass(name) &#123; // ... &#125; html(data) &#123; // ... &#125; // ...&#125;window.$ = function(selector) &#123; // 工厂模式 return new jQuery(selector)&#125;// 测试代码var $p = $('p')console.log($p)console.log($p.addClass) 为何使用面向对象？* 程序执行：顺序、判断、循环 ———— 结构化 * 面向对象 ———— 数据结构化 * 对于计算机，结构化的才是最简单的 * 编程：简单 &amp; 抽象 UML 类图* Unified Modeling Language : 统一建模语言 * UML包含很多种图，本章相关的是类图 * 关系 * 泛化：继承;空箭头 * 关联：引用: People 引用 House；实心箭头 * 演示，代码和类图的结合 * MS Office Visio * [ProcessOn](https://www.processon.com/) 123456789101112131415161718192021222324252627282930313233343536373839// 父类class People &#123; constructor(name, house) &#123; this.name = name this.house = house &#125; saySomething() &#123; &#125;&#125;class A extends People &#123; constructor(name, house) &#123; super(name, house) &#125; saySomething() &#123; alert(`I am A : $&#123;this.name&#125;`) &#125;&#125;class B extends People &#123; constructor(name, house) &#123; super(name, house) &#125; saySomething() &#123; alert(`I am B : $&#123;this.name&#125;`) &#125;&#125;class House &#123; constructor(city) &#123; this.city = city &#125; showCity() &#123; alert(`house in : $&#123;this.name&#125;`) &#125;&#125;let ahouse = new House('beijing')let a = new A('a', ahouse)a.saySomething()let b = new B('b')b.saySomething() 类图 * 类名 * 所有的属性：public 属性名A：类型 * 所有的方法：public 方法名A(参数1，参数2)：返回值类型 * &apos;+&apos;: public * &apos;#&apos;: protected * &apos;-&apos;: private 设计原则 何为设计？ 即按照哪一种思路或者标准来实现功能 功能相同，可以有不同设计方案来实现 伴随着需求增加，设计的作用才能体现出来 《LINUX/UNIX设计哲学》 小即是美 让每个程序只做好一件事 快速建立原型 舍弃高效率而取可移植性(效率会因为硬件的升级而被抹平) 采用纯文本来存储数据 充分利用软件的杠杆效应(软件复用) 使用shell脚本来提高杠杆效应和可移植性 避免强制性的用户界面 让每个程序都成为过滤器 小准则： 允许用户定制环境 尽量使操作系统内核小而轻量化 使用小写字母并尽量简写 沉默是金 各部分之和大于整体 寻求90%的解决方案 1ls | grep *.json | grep 'package' 5大设计原则* Single: 单一职责原则 * 一个程序只做好一件事 * 如果功能过于复杂 * Open: 开放封闭原则 * 对扩展开放，对修改封闭 * 增加需求时，拓展新代码，而非修改已有代码 * 这是软件设计的终极目标 * L: 李氏置换原则 * 子类能覆盖父类 * 父类能出现的地方子类就能出现 * JS中使用较少(弱类型 &amp; 继承使用较少) * Interface: 接口独立原则 * 保持接口的单一独立，避免出现“胖接口” * JS中没有接口(TS例外)，使用较少 * 类似于单一职责原则，这里更关注接口 * Dependence: 依赖倒置原则 * 面向接口编程，依赖于抽象而不依赖于具体 * 使用方只关注接口而不关注具体类的实现 * JS中使用较少(没有接口 &amp; 弱类型) 123456789101112131415161718192021222324function loadImg(src) &#123; return new Promise((resolve, reject) =&gt; &#123; let img = document.createElement('img') img.onload = () =&gt; &#123; resolve(img) &#125; img.onerror = () =&gt; &#123; reject('图片加载失败') &#125; img.src = src &#125;)&#125;let src = './img.png'let result = loadImg(src)result.then((img) =&gt; &#123; alert(`width: $&#123;img.width&#125;`) return img &#125;).then((img) =&gt; &#123; alert(`height: $&#123;img.height&#125;`) &#125;).catch((err) =&gt; &#123; console.log(err)&#125;) 从设计到模式* 设计：指导思想 * 模式：结合日常开发总结出固定的模板 23种设计模式 * 创建型 * 组合型 * 行为型 面试题&gt; 打车时，可以打专车或者快车； &gt; 任何车都有车牌号和名称； &gt; 不同车价格不同，快车1元/km，专车2元/km； &gt; 行程开始时，显示车辆信息； &gt; 行程结束时，显示打车金额(假定行程就5km)。 12345678910111213141516171819202122232425262728293031323334class Car &#123; constructor(number, name) &#123; this.number = number this.name = name &#125;&#125;class KuaiChe extends Car &#123; constructor(number, name) &#123; super(number, name) this.price = 1 &#125;&#125;class ZhuanChe extends Car &#123; constructor(number, name) &#123; super(number, name) this.price = 2 &#125;&#125;class Trip &#123; constructor(car) &#123; this.car = car &#125; start() &#123; console.log(`行程开始 名称：$&#123;this.car.name&#125; 车牌号：$&#123;this.car.number&#125;`) &#125; end() &#123; console.log(`行程结束 价格：$&#123;this.car.price&#125; * 5`) &#125;&#125;let car = new KuaiChe(100, '桑塔纳')let trip = new Trip(car)trip.start()trip.end() &gt; 某停车场，分3层，每层100车位； &gt; 每个车位都能监控到车辆的驶入和离开； &gt; 车辆进入前，显示每层的空余车位数量； &gt; 车辆进入时，摄像头可识别车牌号和时间； &gt; 车辆出来时，出口显示器显示车牌号和停车时长。 &gt; 设计模式 优先级：创建型 | 结构型 | 行为型 结合核心技术 结合框架应用 综合示例 设计方案 代码演示 设计模式对应（7种）","tags":[]},{"title":"穿搭篇","date":"2018-12-22T10:10:59.000Z","path":"2018/12/22/穿搭篇/","text":"血管颜色手腕内侧血管颜色偏蓝紫：冷色调 冷色调：带红感的肤色 穿金戴银冷色调：银色 白色上身冷色调：纯白色比乳白色更好 衣服颜色搭配属于冷基调的人适合：以蓝色为基调的颜色，红色是偏紫的红，如玫红色；不适合橙，黄。适合偏蓝的黄如柠檬黄；绿偏蓝的绿。蓝色和紫色非常适合冷皮的妹子。（灰色非常适合皮肤白皙的妹子穿！） 色彩分配原则 整体性：全身整体围绕一个主色调展开，用同色系不同明度饱和度的颜色搭出层次感 配饰类：饰品，鞋等颜色上相互呼应 细节：靠近面部位置的配饰如围巾耳环帽子，避免冷色。 上冷 + 下暖 口红偏紫红色口红比橘色口红更适合 冷色调冷色调包括大热的冰淇淋色、婴儿蓝、樱花粉，偏紫的红等等。","tags":[]},{"title":"代码观","date":"2018-12-22T09:58:39.000Z","path":"2018/12/22/代码观/","text":"代码要清晰地表达意图 代码是给人读的，不要耍小聪明。 用代码沟通 注释的艺术。 动态地进行取舍 记住，没有最佳解决方案。各种目标不可能面面俱到，关注对用户重要的需求。 增量式编程 写一点代码就构建、测试、重构、休息。让代码干净利落。 尽量简单 宁简勿繁。如果没有充足的理由，就不要使用什么模式、原则和特别的技术。 编写内聚的代码 类和组件应该足够小，任务单一。 告知，不要询问 多用消息传递，少用函数调用。 根据契约进行替换 委托往往优于继承 记录问题解决日志 不要在同一地方摔倒两次。错误是最宝贵的财富。 警告就是错误 忽视编译器的警告可能铸成大错。 对问题各个击破 分而治之是计算机科学中最重要的思想之一。但是，要从设计和原型阶段就考虑各部分应该能够很好地分离。 报告所有的异常 提供有用的错误信息 稍微多花一点心思，出错的时候，将给你带来极大便利 准备好后再共享代码 不要提交无法编译或者没有通过单元测试的代码！ 做代码复查 复查对提高代码质量、减少错误极为重要。 及时通报进展与问题 主动通报，不要让别人来问你","tags":[]},{"title":"Awesome Frontend","date":"2018-12-22T09:21:05.000Z","path":"2018/12/22/Awesome Frontend/","text":"https://www.yuque.com/kobg2k/ipgh9u","tags":[]},{"title":"自动化部署","date":"2018-12-22T09:20:04.000Z","path":"2018/12/22/自动化部署/","text":"自动化部署三剑客Jenkins + Ansible + Gitlab 持续交付现场交付 =&gt; shell命令行 =&gt; 持续交付 版本控制系统：GitLab + GitHub 持续集成工具：Jenkins 部署工具(远程服务器端交付推送): Ansible + Saltstack + Chef GitLabGitLab 与 GitHub 的不同 GitHub：分布式在线代码托管仓库 个人版本可在线免费使用 企业版本收费且需要服务器安装 GitLab：分布式在线代码仓库托管软件 社区免费版本需要服务器安装 企业收费版本需要服务器安装 GitLab的优势和应用场景 开源免费，适合中小型公司将代码放置在该系统中 差异化的版本管理，离线同步以及强大分支管理功能 便捷的GUI操作界面以及强大账户权限管理功能 集成度很高，能够集成绝大多数的开发工具 支持内置HA，保证在高并发下仍旧实现高可用性 GitLab主要服务构成 Nginx静态Web服务器 GitLab-workhorse轻量级的反向代理服务器 Gitlab-shell用于处理Git命令和修改authorized keys列表 Logrotate日志文件管理工具 Postgresql数据库 Redis缓存服务器 Gitlab安装配置管理 利用VirtualBox创建测试服务器 安装Gitlab前系统预配置准备工作 关闭firewalld防火墙：保证本地PC可以访问虚拟机中的所有资源 # systemctl stop firewalld : 关闭当前正在运行的防火墙服务 # systemctl disable firewalld : 禁用防火墙开机启动 关闭SELINUX（强制访问控制安全策略）并重启系统：保证该策略不会影响Gitlab的正常运行 # vi /etc/sysconfig/selinux: 修改SELINUX=disabled # reboot: 重启系统，完成SELINUX的禁用操作 getenforce: 查看SELINUX是否已经被禁用 安装Omnibus Gitlab-ce package # yum -y install curl policycoreutils openssh-server openssh-clients postfix: 安装Gitlab组件 # curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash: 配置YUM仓库 sudo yum install postfix sudo systemctl enable postfix sudo systemctl start postfix: 启动postfix邮件服务 安装Gitlab-ce社区版本：# yum install -y gitlab-ce Omnibus Gitlab 等相关配置初始化并完成安装 证书创建与配置加载 创建本地私有密钥 mkdir -p /etc/gitlab/ssl openssl genrsa -out &quot;/etc/gitlab/ssl/gitlab.example.com.key&quot; 2048 openssl req -new -key &quot;/etc/gitlab/ssl/gitlab.example.com.key&quot; -out &quot;/etc/gitlab/ssl/gitlab.example.com.csr&quot; openssl x509 -req -days 365 -in &quot;/etc/gitlab/ssl/gitlab.example.com.csr&quot; -signkey &quot;/etc/gitlab/ssl/gitlab.example.com.key&quot; -out &quot;/etc/gitlab/ssl/gitlab.example.com.crt&quot; openssl dhparam -out /etc/gitlab/ssl/dhparams.pem 2048 更改证书权限：chmod 600 * Nginx SSL 代理服务配置 vi /etc/gitlab/gitlab.rb 修改 external_url &#39;https://gitlab.example.com&#39; 修改 nginx[&#39;/redirect_http_to_https&#39;] = true 修改 nginx[&#39;ssl_certificate&#39;] = &#39;/etc/gitlab/ssl/gitlab.example.com.crt&#39; 修改 nginx[&#39;ssl_certificate_key&#39;] = &#39;/etc/gitlab/ssl/gitlab.example.com.key&#39; 修改 nginx[&#39;ssl_dhparam&#39;] = &#39;/etc/gitlab/ssl/dhparams.pem&#39; vi /var/opt/gitlab/nginx/conf/gitlab-http.conf 找到 server_name gitlab.example.com,并在下面添加rewrite ^(.*)$ https://$host$1 permanent gitlab-ctl restart 编辑windows下的host文件，手动添加一条DNS记录10.110.16.20 gitlab.example.com 初始化Gitlab相关服务并完成安装 # gitlab-ctl reconfigure 资源Installation methods for GitLab","tags":[]},{"title":"React Router 4.0","date":"2018-12-22T09:16:12.000Z","path":"2018/12/22/React Router 4.0/","text":"路由使用场景 如果是功能复杂的网站，建议后端路由，不建议大型网站用前端路由，太重（通常来说就是整个网站，也可以是功能单一的大型网站，比如携程这样的） 功能单一的网站，比如webapp那种，建议前端路由（通常说的单页应用SPA） 页面有很多组件复用的情况，建议前端路由（如果页面功能复杂，参考第一条） 无所谓前端还是后端路由的网站，比如后台管理系统，那就前端路由吧，毕竟无论是Vue还是React,都有好几个搭配的UI库，前端路由会比较顺心 功能太简单的网站，简单到就几个静态页面，前端路由、后端路由均可，甚至不需要路由 前端路由不能做SEO 事情没有绝对性，任何前端路由的网站肯定能用后端路由实现，反之亦然 可以把项目按不同的需求拆分开，有些部分后台路由，部分前端路由也可。 Router原理 历史：入栈 | 出栈，记录跳转关系还能原路跳转回去的机制 跳转：可以传递参数，负责不同页面的跳转动作 事件：打开一个新页面或者退回到上一个页面时触发的逻辑 原生路由方法 window.location window.location.pathname window.location.search 页面路由window.location.href = ‘/test’ // 页面路由history.back() // 出栈 hash路由window.location.hash = ‘#test’// hash值变化时执行的回调函数window.onhashchange = () =&gt; (console.log(‘current router’, window.location.hash)) H5路由history.pushState(name, title, toPath) // 入栈history.replaceState(name, title, toPath) // 不会更改历史记录，替换当前状态值// 出栈时执行的回调函数window.onpopstate = (e) =&gt; (console.log(‘h5 router change’, e.state)) 常见Router 页面Router: 页面刷新 Hash Router: 页面不刷新，但是会改变url H5 Router: 既能操作Hash又能操作路径，兼容性差。和hash类似。页面不刷新，但是会改变url 相互独立的包yarn add react-router-dom@v4.2.2 react-router React Router 核心 react-router-dom 用于 DOM 绑定的 React Router react-router-native 用于 React Native 的 React Router react-router-redux React Router 和 Redux 的集成 react-router-config 静态路由配置的小助手 &lt;BrowserRouter&gt;用H5的方式来实现的 basename: string 作用：为所有位置添加一个基准UR 场景：需要把页面部署到服务器的二级目录12&lt;BrowserRouter basename=\"/minooo\" /&gt;&lt;Link to=\"/react\" /&gt; // 最终渲染为 &lt;a href=\"/minooo/react\"&gt; getUserConfirmation: func 作用：导航到此页面前执行的函数，默认使用 window.confirm 场景：当需要用户进入页面前执行什么操作时可用123456const getConfirmation = (message, callback) =&gt; &#123;const allowTransition = window.confirm(message)callback(allowTransition)&#125;&lt;BrowserRouter getUserConfirmation=&#123;getConfirmation('Are you sure?', yourCallBack)&#125; /&gt; forceRefresh: bool 作用：当浏览器不支持 HTML5 的 history API 时强制刷新页面12const supportsHistory = 'pushState' in window.history&lt;BrowserRouter forceRefresh=&#123;!supportsHistory&#125; /&gt; keyLength: number 作用：设置它里面路由的 location.key 的长度。默认是6。（key的作用：点击同一个链接时，每次该路由下的 location.key都会改变，可以通过 key 的变化来刷新页面。） 场景：按需设置 &lt;BrowserRouter keyLength={12} /&gt; children: node 作用：渲染唯一子元素 场景：作为一个 React组件，天生自带 children 属性 &lt;Route&gt;路由规则 自带三个 render method 和三个 props(match | location | history) 。 render method每种 render method 都有不同的应用场景，同一个 应该只使用一种 render method ，大部分情况下你将使用 component &lt;Route component&gt; 只有当访问地址和路由匹配时，一个 React component 才会被渲染，此时此组件接受 route props (match, location, history)。 当使用 component 时，router 将使用 React.createElement 根据给定的 component 创建一个新的 React 元素。这意味着如果你使用内联函数（inline function）传值给 component将会产生不必要的重复装载。对于内联渲染（inline rendering）, 建议使用 render prop。 1234&lt;Route path=\"/user/:username\" component=&#123;User&#125; /&gt;const User = (&#123; match &#125;) =&gt; &#123;return &lt;h1&gt;Hello &#123;match.params.username&#125;!&lt;/h1&gt;&#125; &lt;Route render&gt; 此方法适用于内联渲染，而且不会产生上文说的重复装载问题。 也可用于子路由 render方法会传入route的信息 12345678910111213// 内联渲染&lt;Route path=\"/home\" render=&#123;() =&gt; &lt;h1&gt;Home&lt;/h1&#125; /&gt;// 包装 组合const FadingRoute = (&#123; component: Component, ...rest &#125;) =&gt; (&lt;Route &#123;...rest&#125; render=&#123;props =&gt; ( &lt;FadeIn&gt; &lt;Component &#123;...props&#125; /&gt; &lt;/FadeIn&gt;)&#125; /&gt;)&lt;FadingRoute path=\"/cool\" component=&#123;Something&#125; /&gt; &lt;Route children&gt; 子路由：有时候只想知道访问地址是否匹配，然后改变下别的东西，而不是对应的整个页面 1234567891011&lt;ul&gt; &lt;ListIemLink to='somewhere' /&gt; &lt;ListIemLink to='somewhere-ele' /&gt;&lt;/ul&gt;const ListIemLink = (&#123;to, ...rest&#125;) =&gt; ( &lt;Route path=&#123;to&#125; children=&#123;(&#123;match&#125; =&gt; ( &lt;li className=&#123;match ? 'active' : ' '&#125;&gt; &lt;Link to=&#123;to&#125; &#123;...rest&#125; /&gt; &lt;/li&gt; ))&#125;&gt;&lt;/Route&gt;) path: string 任何可以被解析的有效URL路径 如果不给path，那么路由将总是匹配 exact: bool 精确匹配 path 为 ‘/one’ 的路由将不能匹配 ‘/one/two’，反之，亦然。所以在配子路由时千万注意不要配这个参数 strict: bool 对路径末尾斜杠的匹配。如果为 true。path 为 ‘/one/‘ 将不能匹配 ‘/one’ 但可以匹配 ‘/one/two’。 如果要确保路由没有末尾斜杠，那么 strict 和 exact 都必须同时为 true 为应用提供声明式，无障碍导航 to: string 作用：跳转到指定路径 场景：如果只是单纯的跳转就直接用字符串形式的路径。 to: object 作用：携带参数跳转到指定路径 场景：比如你点击的这个链接将要跳转的页面需要展示此链接对应的内容，又比如这是个支付跳转，需要把商品的价格等信息传递过去。 123456&lt;Link to=&#123;&#123; pathname: &apos;/course&apos;, search: &apos;?sort=name&apos;, state: &#123; price: 18 &#125;&#125;&#125; /&gt;&lt;Link to=&quot;/courses&quot; /&gt; replace: bool 为 true 时，点击链接后将使用新地址替换掉上一次访问的地址，什么意思呢，比如：你依次访问 ‘/one’ ‘/two’ ‘/three’ ’/four’ 这四个地址，如果回退，将依次回退至 ‘/three’ ‘/two’ ‘/one’ ，这符合我们的预期，假如我们把链接 ‘/three’ 中的 replace 设为 true 时。依次点击 one two three four 然后再回退会发生什么呢？会依次退至 ‘/three’ ‘/one’！ 场景：在用 路由 做选项卡时候会用到 &lt;NavLink&gt;为了实现页面导航的“激活状态”，是&lt;Link&gt;的特别版本 activeClassName: string 导航选中激活时候应用的样式名，默认样式名为 active 1234&lt;NavLink to=\"/about\" activeClassName=\"selected\"&gt;MyBlog&lt;/NavLink&gt; activeStyle: object 如果不想使用样式名就直接写style exact: bool 若为 true，只有当访问地址严格匹配时激活样式才会应用 strict: bool 若为 true，只有当访问地址后缀斜杠严格匹配（有或无）时激活样式才会应用 isActive: func 决定导航是否激活，或者在导航激活时候做点别的事情。不管怎样，它不能决定对应页面是否可以渲染。 &lt;Switch&gt;路由选项，解决路由多次匹配的问题只渲染出第一个与当前访问地址匹配的 &lt;Route&gt; 或 &lt;Redirect&gt;场景：对于转场动画非常适用，因为被渲染的路由和前一个被渲染的路由处于同一个节点位置！12345678910111213&lt;Fade&gt; &lt;Switch&gt; &#123;/* 用了Switch 这里每次只匹配一个路由，所有只有一个节点。 */&#125; &lt;Route/&gt; &lt;Route/&gt; &lt;/Switch&gt;&lt;/Fade&gt;&lt;Fade&gt; &lt;Route/&gt; &lt;Route/&gt; &#123;/* 不用 Switch 这里可能就会匹配多个路由了，即便匹配不到，也会返回一个null，使动画计算增加了一些麻烦。 */&#125;&lt;/Fade&gt; children: node &lt;Switch&gt; 下的子节点只能是 &lt;Route&gt; 或 &lt;Redirect&gt; 元素。只有与当前访问地址匹配的第一个子节点才会被渲染。&lt;Route&gt; 元素用它们的 path 属性匹配，&lt;Redirect&gt; 元素使用它们的 from 属性匹配。如果没有对应的 path 或 from，那么它们将匹配任何当前访问地址。 &lt;Redirect&gt;渲染时将导航到一个新地址，这个新地址覆盖在访问历史信息里面的本该访问的那个地址 to: string 重定向的 URL 字符串 to: object 重定向的 location 对象 push: bool 若为真，重定向操作将会把新地址加入到访问历史记录里面，并且无法回退到前面的页面。 from: string 需要匹配的将要被重定向路径 &lt;Prompt&gt;当用户离开当前页面前做出一些提示。 message: string 当用户离开当前页面时，设置的提示信息。 &lt;Prompt message=&quot;确定要离开？&quot; /&gt; message: func 当用户离开当前页面时，设置的回掉函数 &lt;Prompt message={location =&gt; (你确定要跳转到 \\${location.pathname}页面吗?)} /&gt; when: bool 通过设置一定条件决定是否启用Prompt history实现了对会话（session）历史的管理 “browser history” - history 在 DOM 上的实现，用于支持 HTML5 history API 的浏览器 “hash history” - history 在 DOM 上的实现，用于旧版浏览器。 “memory history” - history 在内存上的实现，用于测试或非 DOM 环境（例如 React Native） history的属性和方法 length: number 浏览历史堆栈中的条目数 action: string 路由跳转到当前页面执行的动作，分为 PUSH, REPLACE, POP location: object 当前访问地址信息组成的对象 pathname: string URL路径 search: string URL中的查询字符串 hash: string URL的 hash 片段 state: string 例如执行 push(path, state) 操作时，location 的 state 将被提供到堆栈信息里，state 只有在 browser 和 memory history 有效。 push(path, [state]) 在历史堆栈信息里加入一个新条目 replace(path, [state]) 在历史堆栈信息里替换掉当前的条目 go(n) 将 history 堆栈中的指针向前移动 n goBack() 等同于 go(-1) goForward 等同于 go(1) block(prompt) 阻止跳转 history 对象是可变的，因为建议从 的 prop 里来获取 location，而不是从 history.location 直接获取。这样可以保证 React 在生命周期中的钩子函数正常执行 location 当前的位置，将要去的位置，或是之前所在的位置 location 对象不会发生改变，因此可以在生命周期的回调函数中使用 location 对象来查看当前页面的访问地址是否发生改变。 场景：在获取远程数据以及使用动画时非常有用 123456789&#123; key: 'sdfad1' pathname: '/about', search: '?name=minooo' hash: '#sdfas', state: &#123; price: 123 &#125;&#125; 获取location对象 在 Route component 中，以 this.props.location 获取 在 Route render 中，以 ({location}) =&gt; () 方式获取 在 Route children 中，以 ({location}) =&gt; () 方式获取 在 withRouter 中，以 this.props.location 的方式获取 match 包含了 如何与 URL 匹配的信息 params: object 路径参数，通过解析 URL 中的动态部分获得键值对 isExact: bool 为 true 时，整个 URL 都需要匹配 path: string 用来匹配的路径模式，用于创建嵌套的 url: string URL 匹配的部分，用于嵌套的 当一个 Route 没有 path 时，它会匹配一切路径。 获取 match 对象 在 Route component 中，以 this.props.match获取 在 Route render 中，以 ({match}) =&gt; () 方式获取 在 Route children 中，以 ({match}) =&gt; () 方式获取 在 withRouter 中，以 this.props.match的方式获取 matchPath 的返回值 取路由中传入的参数值，即：传入的参数;带参数的路由一般放到最后，以避免冲突 this.props.match.param.id this.props.match.path code-splittingCode Spliting 是一个非常酷的特性，它能让我们用户无需完整下载整个 app 即可使用。你可以将他认为是增量加载我们的应用。尽管有一些其他工具也能实现相关特性，但在这个教程里我们使用 Webpack 和 bundle loader 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// Bundle.jsximport React from 'react';import PropTypes from 'prop-types';class Bundle extends React.Component &#123; state = &#123; // short for \"module\" but that's a keyword in js, so \"mod\" mod: null &#125; componentWillMount() &#123; // 加载初始状态 this.load(this.props); &#125; componentWillReceiveProps(nextProps) &#123; if (nextProps.load !== this.props.load) &#123; this.load(nextProps); &#125; &#125; load(props) &#123; // 重置状态 this.setState(&#123; mod: null &#125;); // 传入组件的组件 props.load((mod) =&gt; &#123; this.setState(&#123; // handle both es imports and cjs mod: mod.default ? mod.default : mod &#125;); &#125;); &#125; render() &#123; // if state mode not undefined,The container will render children return this.state.mod ? this.props.children(this.state.mod) : null; &#125;&#125;Bundle.propTypes = &#123; load: PropTypes.func, children: PropTypes.func&#125;;export default Bundle; 配置路由1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// RouteConfigExample.jsximport React from 'react'import &#123; BrowserRouter as Router, Route, Link&#125; from 'react-router-dom'// Some folks find value in a centralized route config.// A route config is just data. React is great at mapping// data into components, and &lt;Route&gt; is a component./// /////////////////////////////////////////////////////////// first our route componentsconst Main = () =&gt; &lt;h2&gt;Main&lt;/h2&gt;const Sandwiches = () =&gt; &lt;h2&gt;Sandwiches&lt;/h2&gt;const Tacos = (&#123; routes &#125;) =&gt; ( &lt;div&gt; &lt;h2&gt;Tacos&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to='/tacos/bus'&gt;Bus&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/tacos/cart'&gt;Cart&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &#123;routes.map((route, i) =&gt; ( &lt;RouteWithSubRoutes key=&#123;i&#125; &#123;...route&#125; /&gt; ))&#125; &lt;/div&gt;)const Bus = () =&gt; &lt;h3&gt;Bus&lt;/h3&gt;const Cart = () =&gt; &lt;h3&gt;Cart&lt;/h3&gt;/// /////////////////////////////////////////////////////////// then our route configconst routes = [ &#123; path: '/sandwiches', component: Sandwiches &#125;, &#123; path: '/tacos', component: Tacos, routes: [ &#123; path: '/tacos/bus', component: Bus &#125;, &#123; path: '/tacos/cart', component: Cart &#125; ] &#125;]// wrap &lt;Route&gt; and use this everywhere instead, then when// sub routes are added to any route it'll workconst RouteWithSubRoutes = (route) =&gt; ( &lt;Route path=&#123;route.path&#125; render=&#123;props =&gt; ( // pass the sub-routes down to keep nesting &lt;route.component &#123;...props&#125; routes=&#123;route.routes&#125; /&gt; )&#125; /&gt;)const RouteConfigExample = () =&gt; ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to='/tacos'&gt;Tacos&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/sandwiches'&gt;Sandwiches&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &#123;routes.map((route, i) =&gt; ( &lt;RouteWithSubRoutes key=&#123;i&#125; &#123;...route&#125; /&gt; ))&#125; &lt;/div&gt; &lt;/Router&gt;)export default RouteConfigExample 资源关于 React Router 4 的一切 React Router 中文文档 浅谈前后端路由与前后端渲染 hash VS browser Warning: Hash history cannot PUSH the same path; a new entry will not be added to the history stack 坑 react-router browserHistory刷新页面404问题解决 通过router 的 history.push() 方法延迟跳转后还是会跳转 在当前目录下的文件路径不再使用./, 而是直接用/ 的优先级要比 高，所以不要在同一个 中同时使用这两个属性。 Link 和 BrowserRouter 是同一个history，然而createBrowserHistory 的 history只能改变url，并没有触发页面刷新 错误的地方就在类似这样的代码 写法1 export default connect(mapStateToProp, mapDispatchToProp)(withRouter(AppContainer)); 应该写成 写法2 export default withRouter(connect(mapStateToProp, mapDispatchToProp)(AppContainer));原因connect内是进行shallow comparison浅比较的。它重写了组件的shouldComponentUpdate方法 写法1中，connect重写了withRouter的shouldComponentUpdate方法，导致其不能够响应location的变化（仅仅响应mapStateToProps里面的变化） 写法2中，将withRouter提到外层，withRouter的shouldComponentUpdate不会被重写，就会响应location的变化","tags":[]},{"title":"正确的提问(issue)","date":"2018-12-22T07:28:59.000Z","path":"2018/12/22/正确的提问(issue)/","text":"不要问已经回答过的问题尽职调查，试着找找是不是已经有人问过你的问题。如果你问了一个很容易找到答案的问题，你的问题很快会作为重复的问题关闭。 不要让人替你写代码如果你只是问”我怎么做某件事？”你的问题很快就会被关掉。希望你能在提issue之前自己先努力尝试着解决它。在你的问题里描述你尝试过的办法，以及为什么不行。 一次问一个问题一次问5件事情的问题：“我怎么做这件事，然后是那件，然后另一件事情，以及什么是做这个的最好办法？”，这很难回答，\b并且会让人望而却步。 为你的问题做\b一个最精简的例子当人们看到有3页代码（或者更多！)的问题时，总是会\b跳过去，把5000行的代码文件直接贴到issue里不利于得到答案(但总有人这么干)。这是一种经常得不到回报的懒惰行为。这不仅让你不太可能得到有用的答案，并且也正是消除无关因素的过程会引导你自己解决问题(这样你\b甚至不用在issue上问这个问题了)。制作最精简的例子对你的调试技能有好处，对你认真思考问题的能力也有所帮助。 如果在别给出答案之前你自己解决了问题，那就自己回答那个问题你遇到的问题很可能别人也会遇到，如果你已经解决了，本着助人为乐的精神，把你的答案放上去。","tags":[]},{"title":"GTD 时间管理方法论","date":"2018-12-22T07:28:08.000Z","path":"2018/12/22/GTD 时间管理方法论/","text":"收件箱（INBOX）这里的收件箱并不等于邮箱，照片，想看的网页，想看的书电影电视剧，邮件，临时的想法，想到要做的事情等等都可以放到这里来，这是GTD的第一步，收集（CAPTURE） 甄别(CLARIFYING)这步是要做出判断，收件箱里的东西是否是一个action 如果是，则进一步判断是单个动作还是多个动作，如果是单个动作，则要判断能否在两分钟内完成，如果能就马上去完成它。 如果不是ACTION，那么这个东西有几个去处， 一是垃圾桶，顾名思义， 二是当前没啥事能做，但在某个指定时间需要提醒自己， 三是参考材料 整理（ORGANISING）在上一步我们说到要判断是否是多个动作。现在我们来说说怎么分类处理多个动作。 首先需要多个动作才能完成的短期成果我们称之为项目。项目是可以衡量的短期成果，学好GTD不叫项目，学会如何给任务设置上下文（更好的翻译是情境）这是项目。 出于分类的方便，多个动作可以进一步分为： 日程表动作，即那些必须在特定时间或日期完成的动作，它们需要标注在日程表上提醒自己； 等待动作，这是指只有当你的同伴或队友完成了某个或多个动作并发给/告知你成果，你才能开始的动作，他们要放在等待列表里； 尽快开始动作，简称ASAP动作。对于ASAP动作的管理，除了使用项目的观念，还要引入情境，能量，时间和优先级这四个概念。 情境：完成动作必须用到的工具或必须处于的场地，比如你必须到实验室才能做实验，则实验室便是一个情境。 能量，包括生理状态和心理状态，比如阅读文件需要聚精会神，那么就是高能量。 时间，这里指的是要花费的时间多少，比如这个动作要1小时左右完成，则1小时便是时间标签。 优先级：优先级指的是在当前的情境，能量，时间条件下哪个动作能带给你最大的收益，那么就是高优先级。 事实上，随着GTD的发展，情境之外的三个条件已经被很多人设置为了情境使用。SOMEDAY动作，想做，但可能做也可能不做的事情，比如想读一本书但不确定到底要不要读。 回顾，回顾这里不妨使用GTD的六层视野模型| 六层：原则，这里是核心的价值观，比如这个项目为什么要存在 五层：愿景，这里是期望的长期成果，比如让公司上市 四层，目标，两年以内的中长期成果，比如完成收购某某集团 三层：关注的领域，这里是要维持你自己是身心健康或公司的日常运作需要不断进行的动作，最简单的例子比如买菜，健身等等 二层，项目，由多个具体可执行动作组成的短期成果 一层，接下来要做的动作，即项目下的可执行动作 需要注意的是GTD要求每周至少一次回顾自己的项目/任务列表，维护自己的系统 omnifocus 相对于其他GTD软件 可以设置顺序执行的项目类型, 比如 你有一个项目,是做饭,然后下面有2个动作,买菜,然后炒菜,炒菜要等买菜完成以后才能出现.通过设置一些顺序执行项目的分解,可以把一大部分不可用的任务给过滤掉! 设置推迟时间 ( 指定任务的出现时间 )没有一个gtd任务有,比如,我每天晚上要冥想,我就设置每天9点以后才出现这个任务.通过这样的设置,又可以过滤掉一堆任务! 项目文件夹分类,无限层级分类.这个用过的人才知道好 注释可以添加富文本,可以添加附件.这个相当强大,doit就没这功能,我有的时候,甚至会新建一个任务,然后把聊天截图的截图直接黏贴进去~. 配合mac的脚本软件,可以发送周报,日报,以及工作计划等到印象笔记 还有更强的脚本,可以把一本书,输入页,开始和结束时间,自动拆分成每天需要阅读多少页~ 手机上配合workflow可以快速添加任务! ( 从剪切板添加任务,从通知中心添加任务等 ) 为任务设置预估时间,配合脚本还可以统计总时间.配合透视,还可以把小于5分钟的任务筛选出来,然后一起处理 注意项目与行动一个项目 5 月 1 号开始，9月 30 号结束。那么这个项目肯定是由许许多多的小行动组成的。假设这个项目是抄写150条知乎问题；5月1号开始，9月30号结束。那么它也能分解成：每天抄写一条知乎问题。 行动与提醒OmniFoucs：不需要提醒的，项目一般在项目下都可以看见，每天有空做事的时候从中挑一件合适的事情做就OK了 calendar events：有明确时间要求的，比如15:00开会，这种行动应该记在日历中，不是OF中。","tags":[]},{"title":"埋点方案","date":"2018-12-22T07:26:51.000Z","path":"2018/12/22/埋点方案/","text":"tags: [组件]categories: 业务场景解决方案 埋点方式 数据监测：数据采集 | 数据传输 | 数据存储 | 数据分析挖掘 | 数据可视化 数据采集也叫埋点(加码|打点) 埋点核心参数：埋点 | 埋点参数 | 来源页面 | 来源页面参数 | 当前页面 | 当前页面参数 手工埋点 在需要监测的页面引入基础js文件，然后根据业务需求添加监测代码 手工埋点的数据监测产品：Google Analytics | Omniture | Webtrends | Coremetrics | Flurry | 百度统计 | CNZZ | 腾讯云分析 | 友盟 灵活：可以设置自定义事件属性、发送数据内容、发送时间等，可以采集自己最为关心和需要的数据 对于大型、复杂的网站，跨部门沟通成本较高 可视化埋点 通过点击交互替代手写代码 原理：在需要监测的页面引入基础JS文件，使用者进入可视化模式下，选择并配置监测内容(html元素)的信息被记录，并存放在相应位置。当真实世界的用户触发到该监测内容时，基础JS会自动加载之前配置过的信息，记录并发送该数据 产品：Mixpanel 的 Codeless 模式 | 神策分析 无埋点(全埋点) 也是通过可视化的形式添加要监测的内容 可视化埋点是需要先通过配置才能实现内容监测，而无埋点默认先尽可能多的收集能监测的内容，然后再通过配置确定哪些内容需要展示和分析 可以对想要监测的数据进行回溯，不必担心因为漏掉埋点而导致数据丢失 但由于有大量数据需要预先传输，数据时效性和网络传输对无埋点技术要求较高 产品：Heap | GrowingIO 前端埋点操作由于访问印记实现埋点是跨域的请求，\b所以前端这里用jsonp实现跨域请求。 下载并引入第三方库 jsonp npm install jsonp –save import originJsonp from ‘jsonp’ jsonp的实现原理就是动态创建script标签，并且将我们需要请求的路径通过该标签的src来实现，并且将我们要传入的参数拼接在路径后面。 jsonp请求的封装 url：需要请求的接口地址 option(Object)：jsonp的请求配置，如：timeout设置超时时间、param(String)回调函数名称 fn：回调函数，用来接受返回的错误或者成功的结果 封装调用印记方法 提供三种方法实现印记系统的登录、定时激活session、调用印记接口记录日志 将三种方法放在jsonpCMT对象中 writeLogLogin 登录印记系统 writeLogActive 激活session writeLogToDSInfo 调用印记接口记录日志 上述三种方法只需要传入一个参数params(Object)即可。该参数就是需要\b记录的状态。 实现埋点 在需要埋点的模块中导入模块 import jsonpCMT from ‘文件路径’ 在前端\b应用登录成功以后调用jsonpCMT.writeLogLogin方法，该方法成功以后则成功登录印记系统 在登录印记系统成功以后调用jsonpCMT.writeLogActive实现定时\b激活session 在需要实现埋点的地方调用jsonpCMT.writeLogToDSInfo实现日志记录","tags":[]},{"title":"随记","date":"2018-12-22T07:24:47.000Z","path":"2018/12/22/随记/","text":"随心随想随笔 PWA: 渐进式：能确保每个用户都能打开网页 响应式：PC，手机，平板，不管哪种格式，网页格式都能完美适配 离线应用：支持用户在没网的条件下也能打开网页，这里就需要 Service Worker 的帮助 APP 化：能够像 APP 一样和用户进行交互常 更新：一旦 Web 网页有什么改动，都能立即在用户端体现出来 安全：安全第一，给自己的网站加上一把绿锁–HTTPS 可搜索：能够被引擎搜索到推送：做到在不打开网页的前提下，推送新的消息 可安装：能够将Web像APP一样添加到桌面可跳转：只要通过一个连接就可以跳转到你的 Web 页面 Web要做的是把组件化、离线缓存、本地API、通知接口、自适应设备做好 service worker强大的网络请求拦截可以帮助用户更好的原生APP体验。PWA存在的问题主要是浏览器的兼容问题 service worker，pouchdb对离线体验的加持，以上几个库都没polymer做得好。 乔布斯：Design is not just what it looks like and feels like. Design is how it works 《死亡诗社》：我步入丛林，因为我希望活得深刻，吸取生命中所有的精华，把非生命的一切都击溃，以免当我生命终结时，发现自己从没有活过。 你要拼尽全力在年轻的时候给自己足够多的机会，创造更多的可能。 你要改变心态，要增长才干，积累阅历，这样你才有得选。 村上春树：你要做一个不动声色的大人了，不准情绪化，不准偷偷想念，不准回头看，去过自己另外的生活，你要听话，不是所有的鱼都会生活在同一片海里。 “If you cannot measure it, you cannot improve it” ———— William Thomson You need to be right before being good try…catch…finally: 在保持代码运行的同时，处理给定代码块中可能发生的部分或所有错误的方法。如果出现了未处理的错误，JS将提供常规错误消息。 try块包含可能引发错误的代码 catch块包含处理部分或所有错误的代码 如果try块中发生错误，则程序控件将传递exception的值给catch块 如果未发生错误，则绝不执行catch块中的代码 可以通过使用throw语句重新引发错误来将错误传递到下一级别 在执行try块中的所有语句并在catch块中完成错误处理后，无论是否已处理错误，都将执行finally块中的语句。 finally块中的代码保证能运行，除非发生未处理的错误（例如，catch块内发生的运行时错误） 只有理解细节，才有可能在特定场景里进行优化和创造 每次选择\b的时候，听内心的声音，选择似乎难一点的那条路，就是在践行理想： 自己的工作做到最高标准，不断精进； 不斤斤计较自己的得失，先人后己； 看到不公平的情况，发声； 看到需要帮助的“无关人等”\b，伸手； 对认为正确的事情，坚持； 少抱怨，多行动； 对支持创新的事，敢于冒险； 看到需要支持的人，挺身而出； 出了问题，敢于担当； React是用来替换jQuery的，那么Redux就是以替换Backbone|Ember等MVC框架为目的的。 如果你愿意限制做事方式的灵活度，你几乎总会发现可以做的更好 政治学说：谁垄断了信息的阐释权，谁就掌握了权利 经济学说：你能让信息有公信力，你就控制了一笔看不见的财富 如果说信息\b就是财富，那么得到的方法有两种： 一种是利用信息不对称赚取利益，就像利用各种面试技巧，取得面试官的信任； 一种是让自己的能力“公有化”，利用信息透明化，来降低交易成本。 面试要考虑两个问题： \b你是否能满足这个职位现在和以后的要求？——你有什么能力？ 这个人在团队中会产生什么样的作用？他是否符合公司文化的要求？——你是什么样的人？你有着怎样的故事？关键在于，如何讲这个故事。 ”弱点——挑战——解决“的情\b节建构模式 能力一般，但工作有韧劲儿，性格单纯，所以\b有些事情干得反而比聪明人更好 我喜欢观察事物，改变对事情的看法，从而解决问题。人物形象：我是一个有想法有创意的人 对于认准的事情，我非常坚持，不达目的，绝不放弃。人物形象：我是一个有毅力的人，可以打硬仗。 我的关注点常常不在具体问题，而是喜欢梳理业务逻辑，从制度层面优化办事效率。人物形象：我是一个理性、系统性很强的人。 屡战屡败是一个事实，屡败屡战就是一个故事 你并没有浪费掉一个好机会，你只是主动放弃掉一些不适合你的机会而已 只有不断放大自己的性格，你才会令人印象深刻 骤然临之而不惊，无故加之而不怒 每临大事有静气，不信今时无古贤 始终要做到精神镇静，头脑冷静，心态平静，要力戒浮躁、急躁、焦躁，培育静气、大气，始终做到不为诱惑所动、猝变所惊、名利所累、俗事所扰，讲政治、顾大局、守纪律，以无私无欲、至大至刚，涵养浩然大气，把静气当成一种境界去追求，一种情操去修炼，一种品质去磨砺，静气才会形而上为道，形而下为行，内化于心，外化于事，成为我们立身做人，为官做事的强大人格力量。 精明的最高境界是厚道，修养的最高境界是善良 https://cloud.tencent.com/developer/labs/lab/10004/console 若没有人愿意与你颠沛流离，则以梦为马，随处而栖 营销的基础是洞察受众的社会心态 数组的some和filter方法的区别 some方法返回的是boolean值，可用于检察数组中是否有某对象 filter方法返回的是一个新数组，可用于过滤数组中的对象 初级 | 小农经济 | 几乎不需要成本，不需要思考，靠人力获取价值，出现问题连基本的定位都很难，\b找到问题还是要靠大量的人力去解决重复性的劳动 \b中级 | 蒸汽时代（借助平台） | 工程化时代，借助工具快速定位，| 为了效率 高级 | 资本运作（人工智能|平台） | 资本带动资本，前期投资大，后期牵一发而动全身 | 思维方式的颠覆，具有积累效应（随着项目实践越来越多反哺从而变得越来越智能） 从依靠别人慢慢成长为成为别人的依靠 Array.prototype.filter ( callbackfn(元素的值，元素的索引，遍历的对象) ) 以企业的研究、生产、销售（“研产销”）三大功能计，原来三者之间市场交易成本太高，所以，必须把它们一体化到一家公司屋檐之下，才能顺畅运转，生产出有竞争力的产品。价值观、预设和行为习惯都不同的三大功能，一方面要充分尊重它们的差异化（differentiation），另外一方面又要实现一体化（integration），这也是管理学著名的所谓应变理论（contingency theory）的核心。现在，市场上的交易费用降低了，行业的产业组织模式发生变化了，原来必须放在一个屋檐之下的功能可以到市场上去购买了，“研产销”模式之外，还有可能出现的形式是：“研销＋产”（如电子代工业）、“研＋产销”（如新药研发）、“研产＋销”（如汽车分销业），当然，还有“研＋产＋销”（如芯片业） 渠道（客户）为王还是内容（产品）为王，从来都取决于二者的相对谈判力。小岛上十个男生，一个女生，女生为王；十个女生，一个男生，男生为王。没有谁是天生的真命天子。 互联网对产业的影响，我们主要看两个维度，一个是行业市场化的程度，一个是行业信息化的程度 行业信息化的程度，指这个行业的人流、物流、生意流多大程度上是跟着信息流走的，如果很大程度上是跟着信息流走的，互联网在这个行业就有戏；如果不跟着走，就不要去搞什么互联网，“互联网+”或者“+互联网”，都不会有太大意义。只要一个行业的信息化程度高，互联网化的潜力大，这个行业里一般就会出现专做信息的平台。 偷是这个世界上唯一的罪，偷懒也是偷 有两件事情不做好容易走弯路，一是官方文档没有看透，基础不扎实；二是该遵循的规范没有遵循 不能简单地做单目标局部短期优化，必须多目标长期地把这种商业生态需求同算法融合在一起。 互联网商业: 流量集中化:线上最重要的特点是用户和流量集中化，不再有地理位置限制，可以显著提升商业效率。这里对技术有非常强的依赖和挑战，要求我们能快速把好的商家和商品筛选出来给用户，把不好的淘汰掉，甚至要针对不同类型的用户和场景，更多体现某一类商品或商家的特点。一旦我们做不好，负向结果也会迅速扩大，会把不好的或者不适合的商品迅速推送给某个场景下某个用户群体，这样对生态对用户的损害也是非常显著的 产品化: 大数据赋能:之所以技术能够提升商业效率，核心也在于线上环境有丰富的大数据，例如用户、商品、商家、交易、评价等数据，而这些大量的数据是结构化和打通的，在这个基础上技术才能有发挥的空间，才能去提升商业效率 如果提前了解了你们要面对的人生，不知你们是否还会有勇气前来。看见的和听到的，经常会令你们沮丧。世俗是这样的强大，强大到生不出改变他们的念头来。可是如果有机会提前了解了你们的人生，知道青春也不过只有这些日子，不知你们是否还会在意那些世俗希望你们在意的事情。比如占有多少才更荣耀，拥有什么才能被爱。等你们长大你们会因绿芽冒出土地而喜悦，会对初升的朝阳欢呼跳跃，也会给别人善意和温暖。但是却会在赞美别的生命的同时，常常，甚至永远地忘了自己的珍贵。“愿你在被打击时，记起你的珍贵，抵抗恶意；愿你在迷茫时，坚信你的珍贵。爱你所爱，行你所行，听从你心，无问西东。 做出正交的设计，“正交”讲的是线性无关，非常重要，就像一个点(x,y)，在x轴的变化不会影响y，y轴的变化不会影响x，这就是正交。“正交”威力巨大，(x,y)可以表达二维平面的所有的点，如果增加一个z轴，不但能表达三维空间中所有的点，并且每个轴都可以独立变化。设计模式一直强调的『发现变化并且封装变化』其实就是这个意思。 前端技术：优先解决基础技术设施的问题 业务：对外 开发效率 VS 研发效率 性能 &amp;&amp; 用户体验 技术生态 团队驱动：结果可衡量：为团队争取时间 Move Fast and Break Things Huge Impact with Small Teams Be Bold and Innovative 代码对于一个软件工程师就是尊严。 当你遇到困惑不知道该怎么办，永远记住:Read-Search-Ask。 Read the error search google ask for help 个人学习求新，企业架构求稳。无非喜好与场景而已。 其实没有刺不穿的盾，只是攻击的成本和攻击成功后获得的利益成不成正比。 你需要的伴侣，最好是那能够和你并肩立在船头，浅斟低唱两岸风光，同时更能在惊涛骇浪中紧紧握住你的手不放的人。——龙应台 恩宜自淡而浓，先浓后淡者人忘其惠；威宜自严而宽，先宽后严者人怨其酷 阳光下像个天真烂漫的孩子，风雨里做个相互扶持的大人 何谓平庸？平庸是一种被动而又功利的谋生态度。平庸者什么也不缺少，只是无感于外部世界的精彩，人类历史的厚重，终极道义的神圣，生命涵意的丰富。 只有书籍，能把辽阔的空间和漫长的时间浇灌给你，能把一切高贵生命早已飘散的信号传递给你，能把无数的智能和美好对比着愚昧和丑陋一起呈现给你。 这个世界上多的是短平快、付出马上就有回报的立竿见影的事，也多的是需要长期投入、靠矢志不渝的坚持才有大成的事。只不过，对前一种人们常常趋之若鹜，对后一种人们却避之唯恐不及。 当爱支配一切时，权利就不存在了，当权力主宰一切时，爱就消失了 力微休负重，言轻莫劝人 逝者不可追，来者犹可待 拿破仑曾说：“能控制好自己情绪的人，比拿下一座城池的将军更伟大。” 衡量一个人的成功标志，不是看他登到顶峰的高度，而是看他跌到低谷的反弹力。 金钱教育，本质上就是教会孩子如何正确对待“获得”和“拥有”。“君子爱财取之有道” 自信的孩子，眉间有笑，心中有光，做事有决断，大多具有领导才能，内心果敢而笃定，未来会有无限可能。 这个世界上所有的爱都以聚合为最终目的，只有一种爱是以分离为目的，那就是父母对孩子的爱。 浅层学习满足输入，深度学习注重输出。 正确思考的核心是让自己的主观认知尽量与客观世界保持一致 自卑不是来自你的缺点，而来自你没有足以对抗的优点。 自己的目的是什么？ 对方的目的是什么？ 如何做才能达成我们双方共同的目的？ 对方为什么会产生这样的情绪？ 如何才能让对方感觉是处于安全的对话环境中？ 如何控制自己的情绪，客观的评价对方的观点和行为？ 《菜根谭》：冷眼观人，冷耳听语，冷情当感，冷心思理。 所谓学习，就是把原本不相关的东西联系在一起的过程 我们经常说某个人口才好，能把一个复杂的概念讲明白，那一定是因为这个人用了一个你熟悉的概念作为起点，帮助你连接到这个新概念上，这样你就能一下子听明白了。 人是在已有认知上，建立新的连接，来理解新事物的。 整理背景知识的：MECE法则。 提升沟通效果的：SCQA结构化表达。 用于策略选择的：SWOT分析。 正向演绎推理的：三段论。 用于创新思考的：加减乘除排列组合。 对创业者来说，合伙人的背景非常重要，尽量不要找一起长大的，一个学校读书的，这样你会干的事情他也会干","tags":[]},{"title":"编写一个 Loader","date":"2018-12-22T07:19:22.000Z","path":"2018/12/22/编写一个 Loader/","text":"tags: [组件]categories: 前端工程化 loaderloader是导出为一个函数的 node 模块，该函数在 loader 转换资源时调用，给定的函数将调用loader API，并通过this上下文访问本质：接收字符串(或者buffer)，再返回处理完的字符串(或者buffer)的过程 设置匹配单个 loaderwebpack.config.js123456789&#123; test: /\\.js$/ use: [ &#123; loader: path.resolve('path/to/loader.js'), // 通过rule对象指向本地文件 options: &#123;/* ... */&#125; &#125; ]&#125; 匹配多个 loaderswebpack.config.js123456resolveLoader: &#123; modules: [ 'node_modules', path.resolve(__dirname, 'loaders') // 如果你的项目中有一个 /loaders 本地目录 ]&#125; 为 loader 创建了独立的库和包使用 npm link，来将其关联到你要测试的项目Npm link 专门用于开发和调试本地Npm模块，能做到在不发布模块的情况下，把本地的一个正在开发的模块的源码链接到项目的 node_modules 目录下，让项目可以直接使用本地的 Npm 模块。由于是通过软链接的方式实现的，编辑了本地的 Npm 模块代码，在项目中也能使用到编辑后的代码。 完成 Npm link 的步骤如下： 确保正在开发的本地 Npm 模块（也就是正在开发的 Loader）的 package.json 已经正确配置好； 在本地 Npm 模块根目录下执行 npm link，把本地模块注册到全局； 在项目根目录下执行 npm link loader-name，把第2步注册到全局的本地 Npm 模块链接到项目的 node_moduels 下，其中的 loader-name 是指在第1步中的 package.json 文件中配置的模块名称。 链接好 Loader 到项目后你就可以像使用一个真正的 Npm 模块一样使用本地的 Loader 了 复杂用法链式调用多个loader时，以相反顺序调用，从右往左或从上到下 最后的loader最早调用，将会传入原始资源内容 第一个loader最后调用，期望值是传出JS和SourceMap(可选) 中间的loader执行时，会传入前一个loader传出的结果 用法准则 简单：loaders 应该只做单一任务。这不仅使每个 loader 易维护，也可以在更多场景链式调用。 链式：loader 可以被链式调用意味着不一定要输出 JavaScript。只要下一个 loader 可以处理这个输出，这个 loader 就可以返回任意类型的模块。 模块化：保证输出模块化。loader 生成的模块与普通模块遵循相同的设计原则。 无状态：确保 loader 在不同模块转换之间不保存状态。每次运行都应该独立于其他编译模块以及相同模块之前的编译结果。 loader工具库： loader-utils schema-utils loader.js 12345678910111213141516import &#123; getOptions &#125; from 'loader-utils';import validateOptions from 'schema-utils';const schema = &#123; type: 'object', properties: &#123; test: &#123; type: 'string' &#125; &#125;&#125;export default function(source) &#123; const options = getOptions(this); validateOptions(schema, options, 'Example Loader'); // 对资源应用一些转换…… return `export default $&#123; JSON.stringify(source) &#125;`;&#125;; * loader 依赖: 必须使用 addDependency 方法显式声明 12345678910import path from 'path';export default function(source) &#123; var callback = this.async(); var headerPath = path.resolve('header.js'); this.addDependency(headerPath); fs.readFile(headerPath, 'utf-8', function(err, header) &#123; if(err) return callback(err); callback(null, header + \"\\n\" + source); &#125;);&#125;; 模块依赖 通过把它们转化成 require 语句。 使用 this.resolve 函数解析路径 通用代码 在 loader 中创建一个运行时文件，并生成 require 语句以引用该共享模块 绝对路径 loader-utils 中的 stringifyRequest 方法，可以将绝对路径转化为相对路径。 同等依赖 package.json中指定peerDependency的值 处理二进制数据在默认的情况下，Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串。但有些场景下 Loader 不是处理文本文件，而是处理二进制文件，例如 file-loader，就需要 Webpack 给 Loader 传入二进制格式的数据。 12345678910module.exports = function(source) &#123; // 在 exports.raw === true 时，Webpack 传给 Loader 的 source 是 Buffer 类型的 source instanceof Buffer === true; // Loader 返回的类型也可以是 Buffer 类型的 // 在 exports.raw !== true 时，Loader 也可以返回 Buffer 类型的结果 return source;&#125;;// 通过 exports.raw 属性告诉 Webpack 该 Loader 是否需要二进制数据// 最关键的代码是最后一行,没有该行 Loader 只能拿到字符串。 module.exports.raw = true; 缓存加速在有些情况下，有些转换操作需要大量计算非常耗时，如果每次构建都重新执行重复的转换操作，构建将会变得非常缓慢。为此，Webpack 会默认缓存所有 Loader 的处理结果，也就是说在需要被处理的文件或者其依赖的文件没有发生变化时，是不会重新调用对应的 Loader 去执行转换操作的。 如果你想让 Webpack 不缓存该 Loader 的处理结果，可以这样： 12345module.exports = function(source) &#123; // 关闭该 Loader 的缓存功能 this.cacheable(false); return source;&#125;; this.callbackthis.callback 是 Webpack 给 Loader 注入的 API，以方便 Loader 和 Webpack 之间通信。this.callback 的详细使用方法如下：1234567891011this.callback( // 当无法转换原内容时，给 Webpack 返回一个 Error err: Error | null, // 原内容转换后的内容 content: string | Buffer, // 用于把转换后的内容得出原内容的 Source Map，方便调试 sourceMap?: SourceMap, // 如果本次转换为原内容生成了 AST 语法树，可以把这个 AST 返回， // 以方便之后需要 AST 的 Loader 复用该 AST，以避免重复生成 AST，提升性能 abstractSyntaxTree?: AST); 其他Loader API this.context：当前处理文件的所在目录，假如当前 Loader 处理的文件是 /src/main.js，则 this.context 就等于 /src。 this.resource：当前处理文件的完整请求路径，包括 querystring，例如 /src/main.js?name=1。 this.resourcePath：当前处理文件的路径，例如 /src/main.js。 this.resourceQuery：当前处理文件的 querystring。 this.target：等于 Webpack 配置中的 Target this.loadModule：但 Loader 在处理一个文件时，如果依赖其它文件的处理结果才能得出当前文件的结果时， 就可以通过 this.loadModule(request: string, callback: function(err, source, sourceMap, module)) 去获得 request 对应文件的处理结果。 this.resolve：像 require 语句一样获得指定文件的完整路径，使用方法为 resolve(context: string, request: string, callback: function(err, result: string))。 this.addDependency：给当前处理文件添加其依赖的文件，以便再其依赖的文件发生变化时，会重新调用 Loader 处理该文件。使用方法为 addDependency(file: string)。 this.addContextDependency：和 addDependency 类似，但 addContextDependency 是把整个目录加入到当前正在处理文件的依赖中。使用方法为 addContextDependency(directory: string)。 this.clearDependencies：清除当前正在处理文件的所有依赖，使用方法为 clearDependencies()。 this.emitFile：输出一个文件，使用方法为 emitFile(name: string, content: Buffer|string, sourceMap: {…})。 资源npm link","tags":[]},{"title":"浏览器兼容性","date":"2018-12-22T07:14:00.000Z","path":"2018/12/22/浏览器兼容性/","text":"tags: [组件]categories: 业务场景解决方案 IE9 不支持flex布局 css行数过多会不加载，需要用CSSSplitWebpackPlugin分割 1234new CSSSplitWebpackPlugin(&#123; size: 4000, filename:utils.assetsPath('css/[name]-[part].[ext]'), &#125;), 不支持websocket vue框架: 刷新多次才显示界面 滚动条 | 下拉框箭头 | 展开箭头 | 排序箭头 消息x号不居中 列表获得焦点样式,没有边框线 IE JS兼容性 事件绑定方法为attachEvent而不是通用的addEventListener 事件捕获方式由内而外而不是由外而内，一般\b\b将IE的标准定为标准 事件获取目标元素event.srcElement而不是event.target ajax是activeXObject innerHtmlIE中不能操作tr的innerHtml 获取DOM节点 IE: parentElement | parentElement.children other: parentNode | parentNode.childNodes 在HTML中禁止IE缓存IE浏览器提供的ajax对象在发送get请求时，会查看请求地址是否访问过，如果访问过，则显示第一次访问的结果（也就是说，会将第一次访问的结果缓存下来） 在Head里添加禁止使用缓存的代码 123&lt;meta http-equiv=\"Pragma\" content=\"no-cache\"&gt;&lt;meta http-equiv=\"Cache-control\" content=\"no-cache\"&gt;&lt;meta http-equiv=\"Cache\" content=\"no-cache\"&gt; 将所有的ajax调用都改为post方法 在请求地址后面添加随机数或者时间戳, 比如xhr.open(‘get’,’luck.do?’+Math.random(),true,true)); 兼容性测试工具 browserling 在HTML中禁止IE缓存 overflow 兼容性问题chrome: 容器可滚动，padding-bottom 也算在滚动尺寸之内IE和 Firefox 会忽略 padding-bottom同时会导致 scrollHeight 值不一样解决方案：如果需要留有间隙，则使用透明边框 WebP图片兼容性处理https://github.com/RicardoCao-Biker/RICO-BLOG/issues/9","tags":[]},{"title":"跨域问题解决方案","date":"2018-12-22T07:07:34.000Z","path":"2018/12/22/跨域问题解决方案/","text":"tags: [组件]categories: 业务场景解决方案 什么是跨域由于浏览器的同源策略，导致只要协议、域名、端口有任何一个不同，都被当作是不同的域，从而导致了跨域访问的需求 服务器端不存在跨域 不能通过ajax的方法去请求不同源中的文档 不同域的框架之间是不能进行JS交互操作的，不同的框架之间是可以获取window对象的，但是无法获取响应的属性和方法 如果是协议和端口造成的跨域问题“前台”是无能为力的 在跨域问题上，域仅仅是通过“URL首部”来识别，而不会去尝试判断相同的IP地址对应着两个域或两个域是否在同一个IP上 URL首部：window.location.protocol + window.location.host 针对接口的请求 针对Dom的查询 跨域的方法双向通信：即两个iframe,页面与iframe或是页面与页面之间单向跨域：一般用来获取数据 iframe + document.domain将两个页面的 document.domain 都设成相同的域名(只能设置成自身或更高一级的父域，且主域必须相同) ifame + location.hash父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URLhash一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。 H5的postMessageIE8+ 发送信息的postMessage事件: otherWindow.postMessage(message, targetOrigin) otherWindow: 目标窗口，也就是给哪个window发消息，是window.frames属性的成员或者window.open创建的窗口 message：要发送的消息，String | Object targetOrigin: 限定消息接收范围，不限制请使用“*” 监听接收信息的message事件 既可以处理Get请求也可以处理POST请求 JSONP通过script标签引入的JS是不受同源策略的限制的，可以通过script标签引入一个文件，此文件必须返回一个JS函数的调用(要和后端约定好)只能实现GET请求jquery的getJSON()会自动判断是否跨域，不跨域就调用普通的ajax()；跨域则会以异步加载JS文件的形式来调用JSONP的回调函数 JSONP优点： 不像XHR对象实现Ajax请求那样受到同源策略的限制 兼容性更好，不需要XHR或者ActiveX的支持 在请求完毕后可以通过调用callback的方式回传结果 JSONP缺点： 只支持GET而不支持POST等其它类型的HTTP请求 只支持跨域HTTP请求的情况，不能解决不同域的两个页面之间如何进行JS调用的问题 CORSIE10+ CORS： 使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。 实现CORS通信的关键是服务器，只要服务器实现了CORS接口，就可以跨源通信。 服务器端对于CORS的支持，主要通过设置Access-Control-Allow-Origin来进行。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头部信息，有时还会多出一次附加请求，但用户不会有感觉。 CORS与JSONP相比，无疑更为先进、方便和可靠： JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求 使用CORS，开发者可以使用普通的XHR发起请求和获得数据，比起JSONP有更好的错误处理 JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS window.name其他 中间件跨域 服务器代理跨域 Flash URLLoader跨域 动态创建script标签 websocket协议支持跨域 遇到的跨域问题单点登陆嵌入子系统页面通过 iframe + document.domain 的方式解决 icon-font 放到GitHub上导致跨域问题通过将icon-font 的 url 改成 base64 的形式直接嵌入到页面中 这样会产生跨域问题12345678910@font-face &#123; font-family: 'idoll-icon-online'; src: url('@&#123;icon-url&#125;/idoll-icon-online.eot?67rfls'); src: url('@&#123;icon-url&#125;/idoll-icon-online.eot?67rfls#iefix') format('embedded-opentype'), url('@&#123;icon-url&#125;/idoll-icon-online.ttf?67rfls') format('truetype'), url('@&#123;icon-url&#125;/idoll-icon-online.woff?67rfls') format('woff'), url('@&#123;icon-url&#125;/idoll-icon-online.svg?67rfls#idoll-icon-online') format('svg'); font-weight: normal; font-style: normal;&#125; 添加了base64的方式便不会跨域了1234567@font-face &#123;font-family: \"idoll-icon-pro2\"; src: url('@&#123;icon-url&#125;/idoll-icon-pro2.eot?t=1544695441349'); /* IE9*/ src: url('@&#123;icon-url&#125;/idoll-icon-pro2.eot?t=1544695441349#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAAnUAAsAAAAAD6AAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADMAAABCsP6z7U9TLzIAAAE8AAAARAAAAFY870h2Y21hcAAAAYAAAACNAAACCoOE66ZnbHlmAAACEAAABWMAAAg0ycE3gmhlYWQAAAd0AAAALwAAADYTj+MfaGhlYQAAB6QAAAAcAAAAJAfeA45obXR4AAAHwAAAAA8AAAA0NAAAAGxvY2EAAAfQAAAAHAAAABwMfA5MbWF4cAAAB+wAAAAfAAAAIAEcAGluYW1lAAAIDAAAAUUAAAJtPlT+fXBvc3QAAAlUAAAAfwAAAMqOQWaEeJxjYGRgYOBikGPQYWB0cfMJYeBgYGGAAJAMY05meiJQDMoDyrGAaQ4gZoOIAgCKIwNPAHicY2BkYWCcwMDKwMHUyXSGgYGhH0IzvmYwYuRgYGBiYGVmwAoC0lxTGByeVT5rYW7438AQw9zA0AAUZgTJAQDw3gzgeJztkckRAjEQA9usWa4NhQAIiBcZLPcVCNFNGovGepAErmpVjTz2QwLmQCe2okI5UMizl1ua37FufmXXdmr68Z4m6ZiquTZdMdN21Z89C71asmHQRc//DE0/vylG09I8GiVInIyyJM4mG4qLyazjarK9uBllTtyN0iceJtuLp1EjxMuoG7VoGL6PiyuHAAAAeJytVc1vE0cUn/fW9mY3eJ3dtb3xZ+y1vSZANyRer5VAyfIRUCitgFYt4EpNK0BUJCr0lnDAwKGoJ6QoUiVoi1Rx4Q9AvRQMUg699FiJ9FCK1AMVlVBvVPW4b+wQQY9t5d15nvcx83ufy0KMddtSWwrYIMuyCtvNGGgg58HaBQ0XTA1sF71dOJHHeATsSDw54XsOsceQFGRStfyk3LNo7BIPsrudcLhzt7ce8q9+cfXs5OTZPuH3dcuyLasWTZqImFFC6T1pKIdk2QTIm2lHDRlS8MKY1s6O+oaxIPCbMLct/hHOIODx28cgqmgaepu3z2/bYmPIswZGmfSST3G2/VWP5IlkPGI7nk8+yBGnSkzfkYlMC60RSPqNZOQVJ+72QR8crKTNPIApy+ESpHdnQkqGnDCTUVV/BfStdYxbLS+E9pZt89s3e6hp6iY4dvs4oZ7BSA8jY1KLSIHV2SRhtCM5KNY9R9ASQdEJcZHQ6S5US8SXJ/zXoZYo1msJkYTXoUgU9KKONzWjy4ys0cqUAcoZXKctQ9OMVqfVIhEwg7tI1xlaoaAZtJJCp71uEBAlbpvYrVZfTCtn0OItAbOH9XN8wpIszUoCqwyR+AjkoTbRIERF8L0qOFIVLLCdMWhYGmAzqvKdqvplbn8lGoX7/A4cVFX+h7rjMQz9wj9Ou8ZnJx6bLj4Raml1JZdFCOANNaWCrHa+X4PYQ/6VaVxsrhlmD0P3uXQTVylek+wEY5RKCg74lE4ZNMyjyKDYxWjnkPSFLJLHjb+O5XgNsvNctCMxEHUwTdtecZPYXi1XQqMOyEraVPjzXAEz9QOHZ3NcTZlKx5k7M+c7WAZTFeKnQ+DU9Bcb5+QPqgqOYZpl13ONZWGxnJl5a8bP5TJ8TU3vqcyd+aAKEcVMqfzP/Ozh/X4GCzmumGmFO6OhysXqSYdOM9Mq/12vOTAEcaW3KWNRTStQNdyaWzZNY1mwlzPZbGPmzZksX1NEekK9HLXxZq/mHTbxj6p3wRMxiFTGqZxIMJ4Y78vGw8QgSjtKGvNnAWb9/popl/1yGW5NP11ZeTrdX3mwtDo1tbrUW5Ft6Pqz90Bo++Xg0g3EG5fg8nXE65d/hsVTpxcBFk+fWhQQwz2cAbYpozJLsBTLEdJioijTC0W9tFH2pXBNL5n0wkVAzu8hlTIy3gqoYkGUeMAfBUEroLOCQsDnRLH26xlaQZcB64qroD8L4Bu6i0HdpTaTx+MalsQoq43TRSSM5+NA8+VQLJGIURfThTHTjB2iqZPIJ8J/fbcR3wKuMIWZLMNG6LSqY8fAavieXKUIU+37XliOJKexKpzBn/ZR2qzzlrL3RDga5r+eh0yYH8+iMnBBOlfAoNPGA/tUNfmppab2N0OwrrLpxwuyAlk493WBrsR+Xqn897L3+zlN0BtPWhSnRK1eEuPZb9BvBzj1fh7jcm3CEgrk51YgJWJ7DmGskv8SYRZTfBp0MUbquiUm+hg4iAvXpHfmsTSSCipBoTDlDg9b1bo6+NogLhw5soCDo9FNtYo1POxOFQrB22eF5nRZurYQVZuiJG2aMxXRDU1VYsTG6NJ7Y4dHUsUIBmQTTFnOAOTto/OI80ftPA5ULGK6wwFqS+/2FMPSwjX+rdIU7VfiD8Uggi2O6JCm0o9Ft/v/xiKS0CmLYpaJiNCXjaKje/8+Fp9oht0PQaoflIrxn2JhaHzNVuPiMHFmXK3AqGb0Z3L3kfShVKKZnGI2RUNMYNkpFV/+dOyEilUyi3oxQZyaNKfwZ1E9FOYvD/4uu3Kl3WmD6Ks2PIuqMDQoCWknWG+ndnjgzhXO8MEDYjD2N29KiC4AeJxjYGRgYADiKYu+r4vnt/nKwM3CAAI3LPwnIuj/B1gYmB2AXA4GJpAoAEB+CnwAeJxjYGRgYG7438AQw8IAAkCSkQEV8AIARxMCdnicY2FgYGAhEQMABeQANQAAAAAAAGoAvAESAVQB5AI4AnAClALQA1YD3AQaeJxjYGRgYOBliGVgZQABJiDmAkIGhv9gPgMAEzEBhgB4nGWPTU7DMBCFX/oHpBKqqGCH5AViASj9EatuWFRq911036ZOmyqJI8et1ANwHo7ACTgC3IA78EgnmzaWx9+8eWNPANzgBx6O3y33kT1cMjtyDRe4F65TfxBukF+Em2jjVbhF/U3YxzOmwm10YXmD17hi9oR3YQ8dfAjXcI1P4Tr1L+EG+Vu4iTv8CrfQ8erCPuZeV7iNRy/2x1YvnF6p5UHFockikzm/gple75KFrdLqnGtbxCZTg6BfSVOdaVvdU+zXQ+ciFVmTqgmrOkmMyq3Z6tAFG+fyUa8XiR6EJuVYY/62xgKOcQWFJQ6MMUIYZIjK6Og7VWb0r7FDwl57Vj3N53RbFNT/c4UBAvTPXFO6stJ5Ok+BPV8bUnV0K27LnpQ0kV7NSRKyQl7WtlRC6gE2ZVeOEXpc0Yk/KGdI/wAJWm7IAAAAeJxtjM0KwjAQhHfqT9vYKj5IDj5SSLYSWJIQKuLbyyY3cS473ww7NFCXof9aMeCAI044Y8SEGQYXLFhxpXup2ca0Zetj9cI2336SRdk74RRcnRsIuzp1F8uohj9s9AYW3vuLZBdiej5aXzi1/lU0bn3I76TQhrYoTPQFVnUylgA=') format('woff'), url('@&#123;icon-url&#125;/idoll-icon-pro2.ttf?t=1544695441349') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url('@&#123;icon-url&#125;/idoll-icon-pro2.svg?t=1544695441349#iconfont') format('svg'); /* iOS 4.1- */&#125; 资源前端跨域知识总结最直白的跨域访问原理浏览器的同源策略不要再问我跨域的问题了","tags":[]},{"title":"ES6|ES7|ES8","date":"2018-12-22T07:03:14.000Z","path":"2018/12/22/ES6|ES7|ES8/","text":"tags: [组件]categories: 底层原理及基础 ES6常用新特性let &amp;&amp; constlet 命令也用于变量声明，但是作用域为局部const用于声明一个常量，设定后值不会再改变 箭头函数箭头函数是 ES6 中新的函数定义形式，function name(arg1, arg2) {…}可以使用(arg1, arg2) =&gt; {…}来定义。示例如下：12345678910111213// JS 普通函数var arr = [1, 2, 3]arr.map(function (item) &#123; console.log(index) return item + 1&#125;)// ES6 箭头函数const arr = [1, 2, 3]arr.map((item, index) =&gt; &#123; console.log(index) return item + 1&#125;) 箭头函数存在的意义，第一写起来更加简洁，第二可以解决 ES6 之前函数执行中this是全局变量的问题（没有独立的作用域），看如下代码123456789101112131415function fn() &#123; console.log('real', this) // &#123;a: 100&#125; ，该作用域下的 this 的真实的值 var arr = [1, 2, 3] // 普通 JS arr.map(function (item) &#123; console.log('js', this) // window 。普通函数，这里打印出来的是全局变量，令人费解 return item + 1 &#125;) // 箭头函数 arr.map(item =&gt; &#123; console.log('es6', this) // &#123;a: 100&#125; 。箭头函数，这里打印的就是父作用域的 this return item + 1 &#125;)&#125;fn.call(&#123;a: 100&#125;) 解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）12345let [a, b, c] = [1, 2, 3];//等同于let a = 1;let b = 2;let c = 3; 对象的解构赋值：获取对象的多个属性并且使用一条语句将它们赋给多个变量 var { StyleSheet, Text, View } = React; 等同于 var StyleSheet = React.StyleSheet; var Text = React.Text; var View = React.Text; 123456789101112## 模块化 import导入模块、export导出模块如果只是输出一个唯一的对象，使用export default即可，代码如下 ```js// 创建 util1.js 文件，内容如export default &#123; a: 100&#125;// 创建 index.js 文件，内容如import obj from &apos;./util1.js&apos;console.log(obj) 如果想要输出许多个对象，就不能用default了，且import时候要加{...}，代码如下 123456789101112// 创建 util2.js 文件，内容如export function fn1() &#123; alert('fn1')&#125;export function fn2() &#123; alert('fn2')&#125;// 创建 index.js 文件，内容如import &#123; fn1, fn2 &#125; from './util2.js'fn1()fn2() 类class class 其实一直是 JS 的关键字（保留字），但是一直没有正式使用，直到 ES6 。 ES6 的 class 就是取代之前构造函数初始化对象的形式，从语法上更加符合面向对象的写法。例如： JS 构造函数的写法 1234567891011121314151617181920212223242526 function MathHandle(x, y) &#123; this.x = x; this.y = y; &#125; MathHandle.prototype.add = function () &#123; return this.x + this.y; &#125;; var m = new MathHandle(1, 2); console.log(m.add())用 ES6 class 的写法```jsclass MathHandle &#123;constructor(x, y) &#123; this.x = x; this.y = y;&#125;add() &#123; return this.x + this.y;&#125;&#125;const m = new MathHandle(1, 2);console.log(m.add()) 注意以下几点，全都是关于 class 语法的：1231、class 是一种新的语法形式，是class Name &#123;...&#125;这种形式，和函数的写法完全不一样2、两者对比，构造函数函数体的内容要放在 class 中的constructor函数中，constructor即构造器，初始化实例时默认执行3、class 中函数的写法是add() &#123;...&#125;这种形式，并没有function关键字 使用 class 来实现继承就更加简单了，至少比构造函数实现继承简单很多。看下面例子JS 构造函数实现继承123456789101112131415// 动物function Animal() &#123; this.eat = function () &#123; console.log('animal eat') &#125;&#125;// 狗function Dog() &#123; this.bark = function () &#123; console.log('dog bark') &#125;&#125;Dog.prototype = new Animal()// 哈士奇var hashiqi = new Dog() ES6 class 实现继承123456789101112131415161718192021class Animal &#123; constructor(name) &#123; this.name = name &#125; eat() &#123; console.log(`$&#123;this.name&#125; eat`) &#125;&#125;class Dog extends Animal &#123; constructor(name) &#123; super(name) this.name = name &#125; say() &#123; console.log(`$&#123;this.name&#125; say`) &#125;&#125;const dog = new Dog('哈士奇')dog.say()dog.eat() 注意以下两点：121、使用extends即可实现继承，更加符合经典面向对象语言的写法，如 Java2、子类的constructor一定要执行super()，以调用父类的constructor Set 和 Map 题目：ES6 中新增的数据类型有哪些？ Set 和 Map 都是 ES6 中新增的数据结构，是对当前 JS 数组和对象这两种重要数据结构的扩展。由于是新增的数据结构，目前尚未被大规模使用，但是作为前端程序员，提前了解是必须做到的。先总结一下两者最关键的地方：1、Set 类似于数组，但数组可以允许元素重复，Set 不允许元素重复2、Map 类似于对象，但普通对象的 key 必须是字符串或者数字，而 Map 的 key 可以是任何数据类型 SetSet 实例不允许元素有重复，可以通过以下示例证明。可以通过一个数组初始化一个 Set 实例，或者通过add添加元素，元素不能重复，重复的会被忽略。 1234567891011// 例1const set = new Set([1, 2, 3, 4, 4]);console.log(set) // Set(4) &#123;1, 2, 3, 4&#125;// 例2const set = new Set();[2, 3, 5, 4, 5, 8, 8].forEach(item =&gt; set.add(item));for (let item of set) &#123;console.log(item);&#125;// 2 3 5 4 8 Set 实例的属性和方法有123451、size：获取元素数量。2、add(value)：添加元素，返回 Set 实例本身。3、delete(value)：删除元素，返回一个布尔值，表示删除是否成功。4、has(value)：返回一个布尔值，表示该值是否是 Set 实例的元素。5、clear()：清除所有元素，没有返回值。 1234567891011121314const s = new Set();s.add(1).add(2).add(2); // 添加元素s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // falses.clear();console.log(s); // Set(0) &#123;&#125; Set 实例的遍历，可使用如下方法12341、keys()：返回键名的遍历器。2、values()：返回键值的遍历器。不过由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys()和values()返回结果一致。3、entries()：返回键值对的遍历器。4、forEach()：使用回调函数遍历每个成员 123456789101112131415161718192021222324252627let set = new Set(['aaa', 'bbb', 'ccc']);for (let item of set.keys()) &#123;console.log(item);&#125;// aaa// bbb// cccfor (let item of set.values()) &#123;console.log(item);&#125;// aaa// bbb// cccfor (let item of set.entries()) &#123;console.log(item);&#125;// [\"aaa\", \"aaa\"]// [\"bbb\", \"bbb\"]// [\"ccc\", \"ccc\"]set.forEach((value, key) =&gt; console.log(key + ' : ' + value))// aaa : aaa// bbb : bbb// ccc : ccc MapMap 的用法和普通对象基本一致，先看一下它能用非字符串或者数字作为 key 的特性。 const map = new Map(); const obj = {p: ‘Hello World’}; map.set(obj, ‘OK’) map.get(obj) // “OK” map.has(obj) // true map.delete(obj) // true map.has(obj) // false 1234567891011121314151617181920212223242526需要使用new Map()初始化一个实例，下面代码中set get has delete顾名即可思义（下文也会演示）。其中，map.set(obj, &apos;OK&apos;)就是用对象作为的 key （不光可以是对象，任何数据类型都可以），并且后面通过map.get(obj)正确获取了Map 实例的属性和方法如下： 1、size：获取成员的数量 2、set：设置成员 key 和 value 3、get：获取成员属性值 4、has：判断成员是否存在 5、delete：删除成员 6、clear：清空所有 ```js const map = new Map();map.set(&apos;aaa&apos;, 100);map.set(&apos;bbb&apos;, 200);map.size // 2map.get(&apos;aaa&apos;) // 100map.has(&apos;aaa&apos;) // truemap.delete(&apos;aaa&apos;)map.has(&apos;aaa&apos;) // falsemap.clear() Map 实例的遍历方法有： 1、keys()：返回键名的遍历器。 2、values()：返回键值的遍历器。 3、entries()：返回所有成员的遍历器。 4、forEach()：遍历 Map 的所有成员 12345678910111213141516171819202122232425262728const map = new Map();map.set('aaa', 100);map.set('bbb', 200);for (let key of map.keys()) &#123;console.log(key);&#125;// \"aaa\"// \"bbb\"for (let value of map.values()) &#123;console.log(value);&#125;// 100// 200for (let item of map.entries()) &#123;console.log(item[0], item[1]);&#125;// aaa 100// bbb 200// 或者for (let [key, value] of map.entries()) &#123;console.log(key, value);&#125;// aaa 100// bbb 200 Promise Promise是 CommonJS 提出来的这一种规范，有多个版本，在 ES6 当中已经纳入规范，原生支持 Promise 对象，非 ES6 环境可以用类似 Bluebird、Q 这类库来支持。 Promise 可以将回调变成链式调用写法，流程更加清晰，代码更加优雅。 简单归纳下 Promise：三个状态、两个过程、一个方法，快速记忆方法：3-2-1 三个状态：pending、fulfilled、rejected 两个过程： 1、pending→fulfilled（resolve） 2、pending→rejected（reject） 当然还有其他概念，如catch、 Promise.all/race，这里就不展开了 123456789101112131415161718192021222324252627282930313233343536 new Promise((resolve,reject)=&gt;&#123; $.ajax(&#123; url : \"xxxxx\", type : \"post\" success(res)&#123; resolve(res) &#125;, error(err)&#123; reject（err） &#125; &#125;); &#125;).then(()=&gt;&#123; &#125;,()=&gt;&#123; &#125;) ES6常用新特性## &lt;a name=\"778mgs\"&gt;&lt;/a&gt;let &amp;&amp; const let 命令也用于变量声明，但是作用域为局部const用于声明一个常量，设定后值不会再改变## &lt;a name=\"96mmga\"&gt;&lt;/a&gt;箭头函数箭头函数是 ES6 中新的函数定义形式，function name(arg1, arg2) &#123;...&#125;可以使用(arg1, arg2) =&gt; &#123;...&#125;来定义。示例如下：```js// JS 普通函数var arr = [1, 2, 3]arr.map(function (item) &#123; console.log(index) return item + 1&#125;)// ES6 箭头函数const arr = [1, 2, 3]arr.map((item, index) =&gt; &#123; console.log(index) return item + 1&#125;) 箭头函数存在的意义，第一写起来更加简洁，第二可以解决 ES6 之前函数执行中this是全局变量的问题（没有独立的作用域），看如下代码123456789101112131415function fn() &#123; console.log('real', this) // &#123;a: 100&#125; ，该作用域下的 this 的真实的值 var arr = [1, 2, 3] // 普通 JS arr.map(function (item) &#123; console.log('js', this) // window 。普通函数，这里打印出来的是全局变量，令人费解 return item + 1 &#125;) // 箭头函数 arr.map(item =&gt; &#123; console.log('es6', this) // &#123;a: 100&#125; 。箭头函数，这里打印的就是父作用域的 this return item + 1 &#125;)&#125;fn.call(&#123;a: 100&#125;) 解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）12345let [a, b, c] = [1, 2, 3];//等同于let a = 1;let b = 2;let c = 3; 对象的解构赋值：获取对象的多个属性并且使用一条语句将它们赋给多个变量 var { StyleSheet, Text, View } = React; 等同于 var StyleSheet = React.StyleSheet; var Text = React.Text; var View = React.Text; 123456789101112## 模块化 import导入模块、export导出模块如果只是输出一个唯一的对象，使用export default即可，代码如下 ```js// 创建 util1.js 文件，内容如export default &#123; a: 100&#125;// 创建 index.js 文件，内容如import obj from &apos;./util1.js&apos;console.log(obj) 如果想要输出许多个对象，就不能用default了，且import时候要加{...}，代码如下 123456789101112// 创建 util2.js 文件，内容如export function fn1() &#123; alert('fn1')&#125;export function fn2() &#123; alert('fn2')&#125;// 创建 index.js 文件，内容如import &#123; fn1, fn2 &#125; from './util2.js'fn1()fn2() 类class class 其实一直是 JS 的关键字（保留字），但是一直没有正式使用，直到 ES6 。 ES6 的 class 就是取代之前构造函数初始化对象的形式，从语法上更加符合面向对象的写法。例如： JS 构造函数的写法 1234567891011121314151617181920212223242526 function MathHandle(x, y) &#123; this.x = x; this.y = y; &#125; MathHandle.prototype.add = function () &#123; return this.x + this.y; &#125;; var m = new MathHandle(1, 2); console.log(m.add())用 ES6 class 的写法```jsclass MathHandle &#123;constructor(x, y) &#123; this.x = x; this.y = y;&#125;add() &#123; return this.x + this.y;&#125;&#125;const m = new MathHandle(1, 2);console.log(m.add()) 注意以下几点，全都是关于 class 语法的：1231、class 是一种新的语法形式，是class Name &#123;...&#125;这种形式，和函数的写法完全不一样2、两者对比，构造函数函数体的内容要放在 class 中的constructor函数中，constructor即构造器，初始化实例时默认执行3、class 中函数的写法是add() &#123;...&#125;这种形式，并没有function关键字 使用 class 来实现继承就更加简单了，至少比构造函数实现继承简单很多。看下面例子JS 构造函数实现继承123456789101112131415// 动物function Animal() &#123; this.eat = function () &#123; console.log('animal eat') &#125;&#125;// 狗function Dog() &#123; this.bark = function () &#123; console.log('dog bark') &#125;&#125;Dog.prototype = new Animal()// 哈士奇var hashiqi = new Dog() ES6 class 实现继承123456789101112131415161718192021class Animal &#123; constructor(name) &#123; this.name = name &#125; eat() &#123; console.log(`$&#123;this.name&#125; eat`) &#125;&#125;class Dog extends Animal &#123; constructor(name) &#123; super(name) this.name = name &#125; say() &#123; console.log(`$&#123;this.name&#125; say`) &#125;&#125;const dog = new Dog('哈士奇')dog.say()dog.eat() 注意以下两点：121、使用extends即可实现继承，更加符合经典面向对象语言的写法，如 Java2、子类的constructor一定要执行super()，以调用父类的constructor Set 和 Map 题目：ES6 中新增的数据类型有哪些？ Set 和 Map 都是 ES6 中新增的数据结构，是对当前 JS 数组和对象这两种重要数据结构的扩展。由于是新增的数据结构，目前尚未被大规模使用，但是作为前端程序员，提前了解是必须做到的。先总结一下两者最关键的地方：1、Set 类似于数组，但数组可以允许元素重复，Set 不允许元素重复2、Map 类似于对象，但普通对象的 key 必须是字符串或者数字，而 Map 的 key 可以是任何数据类型 SetSet 实例不允许元素有重复，可以通过以下示例证明。可以通过一个数组初始化一个 Set 实例，或者通过add添加元素，元素不能重复，重复的会被忽略。 1234567891011// 例1const set = new Set([1, 2, 3, 4, 4]);console.log(set) // Set(4) &#123;1, 2, 3, 4&#125;// 例2const set = new Set();[2, 3, 5, 4, 5, 8, 8].forEach(item =&gt; set.add(item));for (let item of set) &#123;console.log(item);&#125;// 2 3 5 4 8 Set 实例的属性和方法有123451、size：获取元素数量。2、add(value)：添加元素，返回 Set 实例本身。3、delete(value)：删除元素，返回一个布尔值，表示删除是否成功。4、has(value)：返回一个布尔值，表示该值是否是 Set 实例的元素。5、clear()：清除所有元素，没有返回值。 1234567891011121314const s = new Set();s.add(1).add(2).add(2); // 添加元素s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // falses.clear();console.log(s); // Set(0) &#123;&#125; Set 实例的遍历，可使用如下方法12341、keys()：返回键名的遍历器。2、values()：返回键值的遍历器。不过由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys()和values()返回结果一致。3、entries()：返回键值对的遍历器。4、forEach()：使用回调函数遍历每个成员 123456789101112131415161718192021222324252627let set = new Set(['aaa', 'bbb', 'ccc']);for (let item of set.keys()) &#123;console.log(item);&#125;// aaa// bbb// cccfor (let item of set.values()) &#123;console.log(item);&#125;// aaa// bbb// cccfor (let item of set.entries()) &#123;console.log(item);&#125;// [\"aaa\", \"aaa\"]// [\"bbb\", \"bbb\"]// [\"ccc\", \"ccc\"]set.forEach((value, key) =&gt; console.log(key + ' : ' + value))// aaa : aaa// bbb : bbb// ccc : ccc MapMap 的用法和普通对象基本一致，先看一下它能用非字符串或者数字作为 key 的特性。 const map = new Map(); const obj = {p: ‘Hello World’}; map.set(obj, ‘OK’) map.get(obj) // “OK” map.has(obj) // true map.delete(obj) // true map.has(obj) // false 1234567891011121314151617181920212223242526需要使用new Map()初始化一个实例，下面代码中set get has delete顾名即可思义（下文也会演示）。其中，map.set(obj, &apos;OK&apos;)就是用对象作为的 key （不光可以是对象，任何数据类型都可以），并且后面通过map.get(obj)正确获取了Map 实例的属性和方法如下： 1、size：获取成员的数量 2、set：设置成员 key 和 value 3、get：获取成员属性值 4、has：判断成员是否存在 5、delete：删除成员 6、clear：清空所有 ```js const map = new Map();map.set(&apos;aaa&apos;, 100);map.set(&apos;bbb&apos;, 200);map.size // 2map.get(&apos;aaa&apos;) // 100map.has(&apos;aaa&apos;) // truemap.delete(&apos;aaa&apos;)map.has(&apos;aaa&apos;) // falsemap.clear() Map 实例的遍历方法有： 1、keys()：返回键名的遍历器。 2、values()：返回键值的遍历器。 3、entries()：返回所有成员的遍历器。 4、forEach()：遍历 Map 的所有成员 12345678910111213141516171819202122232425262728const map = new Map();map.set('aaa', 100);map.set('bbb', 200);for (let key of map.keys()) &#123;console.log(key);&#125;// \"aaa\"// \"bbb\"for (let value of map.values()) &#123;console.log(value);&#125;// 100// 200for (let item of map.entries()) &#123;console.log(item[0], item[1]);&#125;// aaa 100// bbb 200// 或者for (let [key, value] of map.entries()) &#123;console.log(key, value);&#125;// aaa 100// bbb 200 Promise Promise是 CommonJS 提出来的这一种规范，有多个版本，在 ES6 当中已经纳入规范，原生支持 Promise 对象，非 ES6 环境可以用类似 Bluebird、Q 这类库来支持。 Promise 可以将回调变成链式调用写法，流程更加清晰，代码更加优雅。 简单归纳下 Promise：三个状态、两个过程、一个方法，快速记忆方法：3-2-1 三个状态：pending、fulfilled、rejected 两个过程： 1、pending→fulfilled（resolve） 2、pending→rejected（reject） 当然还有其他概念，如catch、 Promise.all/race，这里就不展开了 1234567891011121314151617181920212223242526272829303132 new Promise((resolve,reject)=&gt;&#123; $.ajax(&#123; url : \"xxxxx\", type : \"post\" success(res)&#123; resolve(res) &#125;, error(err)&#123; reject（err） &#125; &#125;); &#125;).then(()=&gt;&#123; &#125;,()=&gt;&#123; &#125;)# &lt;a name=\"hh0lph\"&gt;&lt;/a&gt;ES7新特性`1.Array.prototype.includes``2.Exponentiation Operator(求幂运算)`## &lt;a name=\"g0nhws\"&gt;&lt;/a&gt;Array.prototype.includesArray.prototype.includes用法都容易和简单。它是一个替代indexOf，开发人员用来检查数组中是否存在值，indexOf是一种尴尬的使用，因为它返回一个元素在数组中的位置或者-1当这样的元素不能被找到的情况下。所以它返回一个数字，而不是一个布尔值。开发人员需要实施额外的检查。在ES6，要检查是否存在值你需要做一些如下图所示小技巧，因为他们没有匹配到值，Array.prototype.indexOf返回-1变成了true（转换成true），但是当匹配的元素为0位置时候，该数组包含元素，却变成了false。```jslet arr = [‘react‘, ‘angular‘, ‘vue‘]// WRONGif (arr.indexOf(‘react‘)) &#123; // 0 -&gt; evaluates to false, definitely as we expectedconsole.log(‘Can use React‘) // this line would never be executed&#125;// Correctif (arr.indexOf(‘react‘) !== -1) &#123;console.log(‘Can use React‘)&#125; 或者使用一点点hack 位运算符 ~ 使代码更加紧凑一些，因为~（位异或）对任何数字相当于-(a + 1): 123456let arr = [‘react‘, ‘angular‘, ‘vue‘]// Correctif (~arr.indexOf(‘react‘)) &#123;console.log(‘Can use React‘)&#125; 在ES7中使用includes代码如下: let arr = [‘react‘, ‘angular‘, ‘vue‘] // Correct if (arr.includes(‘react‘)) { console.log(‘Can use React‘) } 123456789101112131415161718192021 还能在字符串中使用includes: ```js let str = ‘React Quickly‘ // Correct if (str.toLowerCase().includes(‘react‘)) &#123; // true console.log(‘Found &quot;react&quot;‘) &#125;除了增强了可读性语义化，实际上给开发者返回布尔值，而不是匹配的位置。includes也可以在NaN(非数字)使用。最后 ，includes第二可选参数fromIndex，这对于优化是有好处的，因为它允许从特定位置开始寻找匹配。更多例子： console.log([1, 2, 3].includes(2)) // === true) console.log([1, 2, 3].includes(4)) // === false) console.log([1, 2, NaN].includes(NaN)) // === true) console.log([1, 2, -0].includes(+0)) // === true) console.log([1, 2, +0].includes(-0)) // === true) console.log([‘a‘, ‘b‘, ‘c‘].includes(‘a‘)) // === true) console.log([‘a‘, ‘b‘, ‘c‘].includes(‘a‘, 1)) // === false) 总而言之，includes在一个数组或者列表中检查是否存在一个值，给任何开发人员带来简单性。 Exponentiation Operator(求幂运算) 求幂运算大多数是做一些数学计算，对于3D，VR，SVG还有数据可视化非常有用。在ES6或者早些版本，不得不创建一个循环，创建一个递归函数或者使用Math.pow,如果忘记了什么是指数,当你有相同数字（基数）自相相乘多次（指数）。例如，7的3次方是777 所以在ES6/2015ES，你能使用Math.pow创建一个短的递归箭头函数： 1234567891011 calculateExponent = (base, exponent) =&gt; base*((--exponent&gt;1)?calculateExponent(base, exponent):base) console.log(calculateExponent(7,12) === Math.pow(7,12)) // true console.log(calculateExponent(2,7) === Math.pow(2,7)) // true现在在ES7 /ES2016，以数学向导的开发者可以使用更短的语法:```jslet a = 7 ** 12let b = 2 ** 7console.log(a === Math.pow(7,12)) // trueconsole.log(b === Math.pow(2,7)) // true 开发者还可以操作结果:123456let a = 7a **= 12let b = 2b **= 7console.log(a === Math.pow(7,12)) // trueconsole.log(b === Math.pow(2,7)) // true ES8新特性123451、Object.values/Object.entries2、String padding(字符串填充)3、Object.getOwnPropertyDescriptors4、函数参数列表和调用中的尾逗号（Trailing commas）5、异步函数（Async Functions） Object.values/Object.entriesObject.values和 Object.entries是在ES2017规格中，它和Object.keys类似，返回数组类型，其序号和Object.keys序号对应。类似python中的dict.iteritems()。 Object.values,Object.entries和Object.keys各自项返回是数组，相对应包括key,value或者可枚举特定对象property/attribute1234let obj = &#123;a: 1, b: 2, c: 3&#125;Object.keys(obj).forEach((key, index)=&gt;&#123;console.log(key, obj[key])&#125;) 而使用ES6/ES2015 中for/of稍微好点：1234let obj = &#123;a: 1, b: 2, c: 3&#125;for (let key of Object.keys(obj)) &#123;console.log(key, obj[key])&#125; Object.values返回对象自身可以迭代属性值（values）为数组类型。我们最好使用Array.prototype.forEach迭代它，结合ES6的箭头函数隐形返回值：12let obj = &#123;a: 1, b: 2, c: 3&#125;Object.values(obj).forEach(value=&gt;console.log(value)) // 1, 2, 3 String padding(字符串填充)String.prototype.padStart 和 String.prototype.padEnd在javascript字符操作是一个不错的体验，帮助避免依赖而外的库padStart()在开始部位填充，返回一个给出长度的字符串，填充物给定字符串，把字符串填充到期望的长度。从字符串的左边开始（至少大部分西方语言），一个经典例子是使用空格创建列： 12console.log(‘react‘.padStart(10).length) // \" react\" is 10console.log(‘backbone‘.padStart(10).length) // \" backbone\" is 10 Object.getOwnPropertyDescriptorsObject.getOwnPropertyDescriptors允许创建真实的对象浅副本并创建子类,它通过给开发者描述符来做到这一点.在Object.create(prototype, object)放入描述符后，返回一个真正的浅拷贝1234Object.create(Object.getPrototypeOf(obj),Object.getOwnPropertyDescriptors(obj)) 或者你可以合并两个对象target和source如下： 1234Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)) 两种描述符号类型：121.数据描述符（Data descriptor）2.存取器描述符（Accessor descriptor） 存取描述符有必须属性：get 或者set或者get和set两个就是如你所想的getter和setter函数，然后存取描述符还有可选属性configurable和enumerable12345678let azatsBooks = &#123; books: ['React Quickly'],get latest () &#123; let numberOfBooks = this.books.length if (numberOfBooks == 0) return undefined return this.books[numberOfBooks - 1]&#125;&#125; 函数参数列表和调用中的尾逗号尾逗号在函数定义中只是一个纯粹语法变化，在ES5中，将会非法语法，在函数参数后面应该是没有逗号的：12345678var f = function(a,b,c,d) &#123; // NO COMMA!// ...console.log(d)&#125;f(1,2,3,'this') 在ES8中，这种尾逗号是没有问题的：123456789var f = function(a,b,c,d,) &#123; // COMMA? OK!// ...console.log(d)&#125;f(1,2,3,'this') 异步函数异步函数（或者async/await）特性操作是Promise最重要的功能，开发者定义一个asyc函数里面不包含或者包含await 基于Promise异步操作在ES6中我们可以使用Promise，Axios库向GraphQL服务器发送一个请求：123456axios.get(`/q?query=$&#123;query&#125;`).then(response =&gt; response.data).then(data =&gt; &#123; this.props.processfetchedData(data) // Defined somewhere else&#125;).catch(error =&gt; console.log(error)) 任何一个Promise库都能兼容新的异步函数，我们可以使用同步try/catch做错误处理 123456789async fetchData(url) =&gt; &#123;try &#123; const response = await axios.get(`/q?query=$&#123;query&#125;`) const data = response.data this.props.processfetchedData(data)&#125; catch (error) &#123; console.log(error)&#125;&#125; 异步函数返回一个Promise，所以我们像下面可以继续执行流程:123456789101112async fetchData(query) =&gt; &#123;try &#123; const response = await axios.get(`/q?query=$&#123;query&#125;`) const data = response.data return data&#125; catch (error) &#123; console.log(error)&#125;&#125;fetchData(query).then(data =&gt; &#123;this.props.processfetchedData(data)&#125;) 你可以看到这段代码在(Babel REPL)生效。请注意，这个例子中，Axios库被代替的，是通过模拟来做相同功能，而HTTP请求通过setTimout代替：123456789101112131415161718192021let axios = &#123; // mocksget: function(x) &#123;return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123;data: x&#125;) &#125;, 2000)&#125;)&#125;&#125;let query = 'mangos'async function fetchData(query) &#123;try &#123; const response = await axios.get(`/q?query=$&#123;query&#125;`) const data = response.data return data&#125; catch (error) &#123; console.log(error)&#125;&#125;fetchData(query).then(data =&gt; &#123;console.log(data) // Got data 2s later... Can use data!&#125;) async/await,我们的代码执行异步看起来像执行同步一样","tags":[]},{"title":"JS 导出EXCEL文件","date":"2018-12-22T07:02:14.000Z","path":"2018/12/22/JS 导出EXCEL文件/","text":"tags: [组件]categories: 业务场景解决方案 需求：datatable表格，每一行带有checkbox，勾选checkbox导出当前行所有数据，全选则导出所有选中行的数据即实现导出列表选中行数据的功能 1&lt;a class=&quot;download&quot; download=&quot;用户列表&quot;&gt;导出&lt;/a&gt; 12345678910111213141516171819202122232425262728293031323334353637383940function exportFile() &#123; var dataArr = [];//定义数组用来保存所勾选的列表当前行数据 // 定义表头 var str = `&lt;tr&gt; &lt;th&gt;样本名称&lt;/th&gt; &lt;th&gt;问卷编码&lt;/th&gt; &lt;th&gt;提交时间&lt;/th&gt; &lt;/tr&gt;` // 遍历列表中所购选中的行 $(&apos;table&apos;).find(&apos;tr.hover-bg&apos;).each(function() &#123; var Data = new Object(); Data.AreaName = $(this).find(&apos;td:eq(1)&apos;).html(); Data.DataID= $(this).find(&apos;td:eq(2)&apos;).html(); Data.EntryTime= $(this).find(&apos;td:eq(3)&apos;).html(); dataArr.push(Data); &#125;) if($(&apos;table&apos;).find(&apos;tr&apos;).hasClass(&apos;hover-bg&apos;)) &#123; //循环遍历，每行加入tr标签，每个单元格加td标签 for (let i = 0; i &lt; dataArr.length; i++) &#123; str += &apos;&lt;tr&gt;&apos;; for (let item in dataArr[i]) &#123; //增加\\t为了不让表格显示科学计数法或者其他格式 str += `&lt;td&gt;$&#123; dataArr[i][item] + &apos;\\t&apos;&#125;&lt;/td&gt;`; &#125; str += &apos;&lt;/tr&gt;&apos;; &#125; var template = `&lt;html xmlns:o=&quot;urn:schemas-microsoft-com:office:office&quot; xmlns:x=&quot;urn:schemas-microsoft-com:office:excel&quot; xmlns=&quot;http://www.w3.org/TR/REC-html40&quot;&gt; &lt;head&gt;&lt;!--[if gte mso 9]&gt;&lt;xml&gt;&lt;x:ExcelWorkbook&gt;&lt;x:ExcelWorksheets&gt;&lt;x:ExcelWorksheet&gt; &lt;x:Name&gt;&apos;录入列表.xls&apos;&lt;/x:Name&gt; &lt;x:WorksheetOptions&gt;&lt;x:DisplayGridlines/&gt;&lt;/x:WorksheetOptions&gt;&lt;/x:ExcelWorksheet&gt; &lt;/x:ExcelWorksheets&gt;&lt;/x:ExcelWorkbook&gt;&lt;/xml&gt;&lt;![endif]--&gt; &lt;/head&gt;&lt;body&gt;&lt;table&gt;$&#123;str&#125;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;`; // 实例化一个Blob对象，其构造函数的第一个参数是包含文件内容的数组，第二个参数是包含文件类型属性的对象 var blob = new Blob([template], &#123;type: &quot;application/vnd.ms-excel&quot;&#125;); $(&apos;.download&apos;).attr(&apos;href&apos;, URL.createObjectURL(blob)); &#125;&#125;","tags":[]},{"title":"浏览器渲染原理","date":"2018-12-22T07:00:25.000Z","path":"2018/12/22/浏览器渲染原理/","text":"参考资源How Browsers Work","tags":[]},{"title":"React Hooks","date":"2018-12-22T06:58:52.000Z","path":"2018/12/22/React Hooks/","text":"前期准备要把 react 和 react-dom 更新到 16.7.0-alpha 及以上，如果配置了 ESLint，记得添加对应的 Plugin。（安装插件能够帮助你不弄错每个盒子和状态的对应关系，书写的时候 Hooks 需要 use 开头且放在顶层作用域，即不可以包裹 if/switch/when/try 等） React Hooks 的本质 Hooks 本质是把面向生命周期编程变成了面向业务逻辑编程； Hooks 使用上是一个逻辑状态盒子，输入输出表示的是一种联系； Hooks 是 React 的未来，但还是无法完全替代原始的 Class。 面向生命周期编程 =》面向业务逻辑编程 == ===》 业务逻辑复用这里说的业务逻辑复用主要是需要跨生命周期的业务逻辑。单单按照组件堆积的形式组织代码虽然也可以达到各种复用的目的，但是会导致组件非常复杂，数据流也会很乱。组件堆积适合 UI 布局，但是不适合逻辑组织。为了解决这些问题，在 React 发展过程中，产生了很多解决方案， Mixins坏处远远大于带来的好处，因为现在已经不再支持，不多说，可以看看这篇文章：Mixins Considered Harmful。 Class Inheritance官方 很不推荐此做法 High-Order Components (HOC)React 高阶组件 在封装业务组件上简直是屡试不爽，它的实现是把自己作为一个函数，接受一个组件，再返回一个组件，这样它可以统一处理掉一些业务逻辑并达到复用目的。 比较常见的一个就是 react-redux 里的 connect 函数： 但是在调试的时候可以看到会产生“组件嵌套地狱” Render PropsRender Props 其实很常见，比如 React Context API： 1234567891011class App extends React.Component &#123; render() &#123; return ( &lt;ThemeProvider&gt; &lt;ThemeContext.Consumer&gt; &#123;val =&gt; &lt;div&gt;&#123;val&#125;&lt;/div&gt;&#125; &lt;/ThemeContext.Consumer&gt; &lt;/ThemeProvider&gt; ) &#125;&#125; 它的实现思路很简单，把原来该放「组件」的地方，换成了回调，这样当前组件里就可以拿到子组件的状态并使用。 但是，同样这会产生 Wrapper Hell 问题： 状态盒子Hooks 只能在其它 Hooks 的函数或者 React Function 组件里。 React 社区一直推崇函数式、纯函数等思想，引入 Hooks 概念后的 Functional Component 变的不再纯了，useXxx 与其说是一条执行语句，不如说是一个声明。声明这里放了一个「状态盒子」，盒子有输入和输出，剩下的内部实现就一无所知，重要的是，盒子是有记忆的，下次执行到此位置时，它有之前上下文信息。 类比「代码」和「程序」的区别，前者是死的，后者是活的。表达式 c = a + b 表示把 a 和 b 累加后的值赋值给 c，但是如果写成 c := a + b 就表示 c 的值由 a 和 b 相加得到。看起来表述差不多，但实际上，后者隐藏着一个时间的维度，它表示的是一种联系，而不单单是个运算。这在 RxJS 等库中被大量使用。 这种声明目前是通过很弱的 use 前缀标识的（但是设计上会简洁很多），为了不弄错每个盒子和状态的对应关系，书写的时候 Hooks 需要 use 开头且放在顶层作用域，即不可以包裹 if/switch/when/try 等。如果你按文章开头引入了那个 ESLint Plugin 就不用担心会弄错了。 FragmentWrapper Hell，我个人觉得使用 Fragment 也可以基本解决。 案例讲解功能需求根据 input 的输入值更改网页的 title 信息 Class Component123456789101112131415161718192021import React from 'react'class ChangeTile extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; title = '' &#125; &#125; handleChage(title) &#123; this.setState(&#123; title &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;input value=&#123;this.state.title&#125; onChange=&#123;this.handleChage(title)&#125; /&gt; &lt;/div&gt; ) &#125;&#125; Hooks 写法12 后记HOC 和 Render Props 还是有存在的必要，一方面是支持 React Class，另一方面，它们不光适用于纯逻辑封装，很多时候也适合逻辑 + 组件的封装场景，虽然此时使用 Hooks 也可以，但是会显得啰嗦点。 参考资源官网文档 Making Sense of React Hookshttps://www.yuque.com/es2049/blog","tags":[]},{"title":"搭建一个脚手架","date":"2018-12-22T06:35:16.000Z","path":"2018/12/22/搭建一个脚手架/","text":"tags: [组件]categories: 前端工程化 脚手架功能需求 代码检测 文档工具 规范的项目组织结构 ES 规范与浏览器兼容性不一致 CSS 弱编程能力 资源定位 图片压缩|base64 内嵌| CSS Sprites 模块依赖分析和压缩打包 自动化工具，提高效率 数据 mock 服务层封装 路由配置 react-devtool 配置 数据状态管理配置选型（redux|mobix) 性能提升？(immutable) 推荐工具lerna管理前端 multiple packages 项目的工具 官网 lerna 入门指南 monorepo 新浪潮 | introduce lerna 文档工具 storybook：通过 JS(JSX) 文件写 examples React Styleguidist：通过 Markdown 文件写 examples docz - markdown 与 react 的结合，十分方便的工具 docsite - 快速搭建静态站点，对国际化支持很好 推荐 npm 包 new-component：自动初始化React组件所需的初始化代码","tags":[]},{"title":"坑及报错","date":"2018-12-22T06:28:36.000Z","path":"2018/12/22/坑及报错/","text":"storybook 3 + babel 7 导致出错storybook 3 默认使用的是 babel 6如果你出现了这个问题，你可以求助于 babel-core@7.0.0-bridge.0，这个库可以做桥接工作 Can’t resolve xxxx这个问题往往是模块解析问题，但是可能原因不少，你可以考虑的几个点有： babel 的模块配置 webpack 配置（比如 resolve.modules 这些配置） tsconfig.json（如果你用了 ts 的话也请看一下 ts 的模块配置） 内置模块重复安装，模块版本不一致，将pkg中的依赖模块删除，然后删除整个node_modules重新安装 路径问题 @myc/components Not Found如果你用 yarn 直接在 storybook 目录下企图安装新依赖会失败因为这个包是我们本地正在开发的，不在 npm 上，你应该使用 lerna 的 bootstrap 命令来安装依赖（lerna 实际上是以链接的形式安装的） Failed propType: Invalid prop AAA of type BBB supplied to CCC, expected DDD. Check the render method of EEE.请确保你传递给组件的参数类型正确。 Unknown option: xxx/package.json.presets这里有一篇来自 Stack Overflow 的回答可以参考。 Invariant Violation: findComponentRoot(…): Unable to find element.你或许引入了 React 两次。如果你使用 webpack，请将 React &amp; ReactDOM 设置为 external。如果你使用其他工具（browserify 等），请阅读它们的文档并将 React &amp; ReactDOM 设置为 external。 Warning: defaultValue is invalid for getFieldDecorator will set value, please use option.initialValue instead.解决方案：外加加一个divantd中setFieldsValue和defaultVal react-styleguidist 版本 与 eslint 同时升级以后导致文档demo import 新特性无法使用 降级后得到解决 gulp less() 转换报错添加 javascriptEnabled: true 属性 less 变量会导致样式难以定位的问题最好有 source-map 文件","tags":[]},{"title":"前后端分离","date":"2018-12-22T01:59:50.000Z","path":"2018/12/22/前后端分离/","text":"tags: [组件]categories: 前端工程化 前言前后端分离为什么出现？本质上是什么？前后端分离运动对 web 应用的架构带来了怎么样的变化？前后端分离怎么分离？为什么是 Node.js? 前后端分离的未来怎样？ 互联网分层架构，为啥要前后端分离？ Why传统的后段服务支撑不了现代化的前端开发。平时工作中用到的工具链、开发框架、规范协议、浏览器等在不断涌现，这些新的技术在给开发环境、开发流程提了更多新需求。Node.js 在这个背景下能够把这些工具串联起来。 How模板层的分工最早的 Java 开发阶段需要一个包含所有内容的 war 包，整个前端的编排，像 HTML 页面、CSS、JS 很多时候包含在 HTML 页面，也会出现脚本复用、样式复用抽离出来。所以前端开发当时是围绕著名的 velocity 模版。这一层最大的问题是，后端的同学看前端资源像看天书，前端同学看后端模版也像是看天书，融合效率非常低。 静态资源独立部署 Web 前端体验最大的改进就是副客户端，客户端资源非常庞大，代码不再是直接发布到线上，而是要编译，做预处理，可能还要做 CDN 的加速。整个应用被分割成两部分，后端服务发布之后，前端服务要独立更新，这样就给应用的更新带来了便利。这里存在一个问题是接口的协调，前端的需求变更，数据的要求也会变化，需要后端去协调资源的编排。另外一个问题是测试，前端持有脚本，样式资源，而模版却在应用层，应用层的开发、发布也是很复杂的。 独立应用层（BFF） Node.js 提供 mock 数据开始，前端代码的预编译，资源编排，这些动作都合并到一个应用里面，前端形成 UI 应用层。在这一层，前端具备了更灵活、强大的能力，在数据编排这一层，Node.js 可以做轻量的粘合，服务端的开发也在往微服务方向发展，提升了开发效率。 后端相关的接口回退到 API，或者云端。 BFF 层业务层的需求很多，在流程控制、数据转换、数据安全、分析展现等方面需要有大量的组件沉淀。最大的特点是有众多独立的功能模块。 在 server 层Babeljs 可以做代码转换的事情，Bigpipe 可以优化服务端的内存，可以缩减渲染时间，提升体验优化。在数据流里可以有很多的 filter，给数据链中插入 processor，来定义处理微小的数据。用户在原始的数据到完整的可视化展现不需要再搭建一个产品去支持，只需要搭几个 filter，配几个数据源，拖几个组件就可以完成。 定制应用框架通过“定制应用框架”解决前端的编译，工程管理，数据 mock 等问题 微应用分割把各自独立的模块应用切割成微应用，一个微应用解决一个问题，便于分工和隔离处理。 具体做法是微服务拆分，搭建微应用服务，承载大量的小服务，同时也会出现很多域名的问题，很多访问入口。这里做了一些小创新，在入口可以定义端口，sever name，访问 path，当把一个场景分成 10 个应用发布，发布之后再根据不同的路径拼接成一个应用，对体验没有影响。 除了路由自动化规划之后，对应用的发布做到上下平滑，不会影响流量。前端人员自己打包发布就可以了。 运维工程化当这些应用被分割的很细致之后，随之而来的是如何管理这些小应用。 比如有两台机器做互备，把所有小 App 都发布到上面之后，由一个个小颗粒组成一个大应用，看上去很像一个蜂巢，因此命名 honeycomb，这些蜂巢组成一个大蜂窝，完成一个主功能。在应用推进过程中，有些应用压力大，需要把应用集群隔离开，把有不同业务需求场景环境，例如开发环境、预发环境、线上环境隔离开来，不同环境配置的集群资源和机器数量都不一样。随着业务发展，隔离的事情会交给容器去执行。 密集计算问题密集计算分成两层，第一层绿色部分会接收用户请求，第二层浅蓝色会处理用户请求，写很多的 processor，提供大量的进程去提供密集计算。 主要问题在于 CPU 容量是恒定的，当有很多并发请求的时候，如何保证在服务层去很好的分配计算任务。拆成两层之后，保证用户请求不会被 block 掉。如果第一层大量的密集计算，会导致用户的请求或者连接的需求被挡住，接收不到响应，所以要往后堆，做成队列，可扩容的大集群。整个结果在 Java 里就可以理解为 Java 庞大线程的处理过程。 社区里在线程库里还有一些尝试，Napa.js 是微软开源的线程库，前端同构的需求可以探索使用 Napa.js 这个工具。","tags":[]},{"title":"前端业务代码工具库","date":"2018-12-22T01:47:14.000Z","path":"2018/12/22/前端业务代码工具库/","text":"outils[ [ 前端业务代码工具库 目的：高效率完成前端业务代码 业务开发过程中，会经常用到日期格式化、url参数转对象、浏览器类型判断、节流函数等常用函数，为避免不同项目多次复制粘贴的麻烦，这里统一封装，并发布到npm，以提高开发效率。如果你也有常用的代码，欢迎为本项目提交pr。 安装使用 直接下载min目录下的outils.min.js使用，支持UMD通用模块规范 使用npm安装 浏览器:1234&lt;script src=&quot;outils.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var OS = outils.getOS()&lt;/script&gt; npm:1$ npm install --save-dev outils webpack、RequireJS、SeaJS等 123// 完整引入const outils = require(&apos;outils&apos;)const OS = outils.getOS() 推荐使用方法 你真的不需要完整引入所有函数，所以只引入需要使用的方法即可。123// 只引入部分方法(&apos;outils/&lt;方法名&gt;&apos;)const getOS = require(&apos;outils/getOS&apos;)const OS = getOS() API文档ArrayarrayEqual 判断两个数组是否相等ClassaddClass 为元素添加classhasClass 判断元素是否有某个classremoveClass 为元素移除classCookiegetCookie 根据name读取CookieremoveCookie 根据name删除CookiesetCookie 添加CookieDevicegetExplore 获取浏览器类型和版本号getOS 获取操作系统类型DomgetScrollTop 获取滚动条距顶部的距离offset 获取一个元素的距离文档(document)的位置，类似jQ中的offset()scrollTo 在\\${duration}时间内，滚动条平滑滚动到\\${to}指定位置setScrollTop 设置滚动条距顶部的距离windowResize H5软键盘缩回、弹起回调Functiondebounce 函数防抖throttle 函数节流KeycodegetKeyName 根据keycode获得键名ObjectdeepClone 深拷贝，支持常见类型isEmptyObject 判断Object是否为空RandomrandomColor 随机生成颜色randomNum 生成指定范围随机数RegexpisEmail 判断是否为邮箱地址isIdCard 判断是否为身份证号isPhoneNum 判断是否为手机号isUrl 判断是否为URL地址StringdigitUppercase 现金额转大写SupportisSupportWebP 判断浏览器是否支持webP格式图片TimeformatPassTime 格式化\\${startTime}距现在的已过时间formatRemainTime 格式化现在距\\${endTime}的剩余时间UrlparseQueryString url参数转对象stringfyQueryString 对象序列化","tags":[]},{"title":"前端工程师必备技能图谱","date":"2018-12-21T12:47:27.000Z","path":"2018/12/21/前端工程师必备技能图谱/","text":"tags: [组件]categories: 底层原理及基础","tags":[]},{"title":"如何管理好10万行代码的前端单页面应用","date":"2018-12-21T12:41:56.000Z","path":"2018/12/21/如何管理好10万行代码的前端单页面应用/","text":"tags: [Hexo]categories: service ToB产品特点 业务复杂度高、业务理解门槛高； 前端代码量巨大 架构方案架构的目的是管理复杂度，将复杂问题分而治之、有效管理 通过路由切割“页面级”粒度的功能模块 同一“页面”内的模块再划分 纵向：通过业务功能（可根据视图模块判断）划分 横向：通过Model-View-Controller三种不同职能划分 合并同类项：细分粒度，将可复用模块或组件抽离到公共区域 数据模型： Domain Model 领域模型：详见ORM层 App State Modal 应用状态模型：详见应用状态模型 UI组件： Container Component： 详见容器型组件 Presentational Component：详见展示型组件 公共服务： 所有的HTTP请求放在一起统一管理 日志服务、本地存储服务、错误监控、Mock服务等统一存放在公共服务层； 跨模块通信 合并同类项 ORM层（Domain Model Layer）持久化到数据库或localStorage中，属于可跨模块复用的公共业务数据如：Users 用户信息 | Datasets 数据集信息 | Reports 报表信息 抽离该公共层的好处： 跨模块数据同步问题不复存在： 例如：之前Users对象在A和B两个业务模块中单独存储，A模块变更Users对象后，需将Users变更同步到B模块中，如不同步，A、B模块在界面上呈现的User信息不一致，下沉到领域模型层统一管理后，问题不复存在； 除领域模型复用外，还可复用领域模型相关的CRUD Reducer： 例如：之前Users对象对应的Create Read Update Delete方法可能在A和B两个业务模块各维护一套，下沉到领域模型层统一管理后，减少了代码重复问题； 自然承担了部分跨模块通信职责： 之前数据同步相关的跨模块通信代码没有了存在的必要性； 应用状态模型应用状态模型是与视图相关的状态数据：这些数据与具体的视图模块或业务功能强相关，建议存放在业务模块的Model中。如： 当前页面选中了列表的第n行 currentSelectedRow: someId 窗口是否处于打开状态 isModalShow: false 某种视图元素是否在拖拽中 isDragging: true 容器型组件容器型组件是与store直连的组件，为展示型组件或其它容器组件提供数据和行为，尽量避免在其中做一些界面渲染相关的事情。 展示型组件展示型组件独立于应用的其它部分内容，不关心数据的加载和变更，保持职责单一，仅做视图呈现和最基本交互行为，通过props接收数据和回调函数输出结果，保证接收的数据为组件数据依赖的最小集。 如果展示型组件粒度切分能很好的遵循高内聚低耦合和职责单一原则的话，可以沉淀出很多可复用的通用业务组件。 跨模块通信模块粒度逐渐细化，会带来更多的跨模块通信诉求，为避免模块间相互耦合、确保架构长期干净可维护，建议将跨模块通信的逻辑代码放在父模块中，或者在一个叫做Mediator层中单独维护 不允许在一个模块内部直接调用其他模块的Dispatch方法（写操作、变更其他模块的state） 不允许在一个模块内部直接读取其他模块的state方法（读操作） 数据流管理纯函数：入参相同的情况下，返回值恒等非纯函数：函数中如果包含 Math.random，new Date(), 异步请求等内容，且影响到最终结果的返回，即为非纯函数 监听Store变更刷新视图的功能是由react-redux完成的： &lt;Provider&gt; 组件通过context属性向后代&lt;connect&gt;组件提供（provide）store对象； &lt;connect&gt; 是一个高阶组件，作用是将store与view层组件连接起来（这里重复提一句，redux官方将&lt;connect&gt;直接连接的组件定义为container component），&lt;connect&gt;向开发者开放了几个回调函数钩子（mapStateToProps, mapDispatchToProps…）用于自定义注入 container component 的 props 的姿势； react-redux 监听 redux store 的变更，store 改变后通知每一个 connect 组件刷新自己和后代组件，为了减少不必要的刷新提升性能，connect 实现了 shouldComponentUpdate 方法，如果 props 不变的话，不刷新 connect 包裹的 container component；","tags":[{"name":"组件","slug":"components","permalink":"http://lulustyle.net/tags/components/"}]},{"title":"Webpack 中 publicPath 详解","date":"2018-12-21T12:39:18.000Z","path":"2018/12/21/Webpack 中 publicPath 详解/","text":"tags: [组件]categories: 前端工程化 outputoutput.path 默认值：process.cwd() 只是指示输出的目录，对应一个绝对路径 output: {path: path.resolve(__dirname, &#39;../dist&#39;),} output.publicPath 默认值：空字符串 帮助你为项目中的所有资源指定一个基础路径，它被称为公共路径(publicPath) 所有资源的基础路径: 项目中引用css，js，img等资源时候的一个基础路径,要配合具体资源中指定的路径使用 静态资源最终访问路径 =output.publicPath+ 资源loader或插件等配置路径 静态资源最终访问路径: 在使用html-webpack-plugin打包后得到的html中可以看到 相对路径: 相对于build之后的index.html(如果设置publicPath: &#39;./dist/&#39;，则打包后js的引用路径为./dist/build.js) 将publicPath设置成/,则打包后访问路径为localhost:8080/dist/main.js，本地无法访问 一般情况下publicPath应该以’/‘结尾，而其他loader或插件的配置不要以’/‘开头 1234567891011121314151617181920212223output.publicPath = '/dist/'// imageoptions: &#123; name: 'img/[name].[ext]?[hash]'&#125;// 最终图片的访问路径为output.publicPath + 'img/[name].[ext]?[hash]' = '/dist/img/[name].[ext]?[hash]'// js output.filenameoutput: &#123; filename: '[name].js'&#125;// 最终js的访问路径为output.publicPath + '[name].js' = '/dist/[name].js'// extract-text-webpack-plugin cssnew ExtractTextPlugin(&#123; filename: 'style.[chunkhash].css'&#125;)// 最终css的访问路径为output.publicPath + 'style.[chunkhash].css' = '/dist/style.[chunkhash].css' webpack-dev-server中的publicPath 在开发阶段，我们借用devServer启动一个开发服务器进行开发，这里也会配置一个publicPath webpack-dev-server中的publicPath路径下的打包文件可以在浏览器中访问。而静态资源仍然使用output.publicPath webpack-dev-server打包的内容是放在内存中的，这些打包后的资源对外的的根目录就是publicPath 通过访问 http://localhost:8080/webpack-dev-server可以得到devServer启动后的资源访问路径，点击静态资源可以看到静态资源的访问路径为 http://localhost:8080${publicPath}index.html 123456// 假设devServer的publicPath为const publicPath = &apos;/dist/&apos;// 则启动devServer后index.html的位置为const htmlPath = `$&#123;pablicPath&#125;index.html`// 包的位置cosnt mainJsPath = `$&#123;pablicPath&#125;main.js` 以上可以直接通过http://lcoalhost:8080/dist/main.js访问到 html-webpack-plugin中的会受到路径影响的属性template 作用：用于定义模版文件的路径 源码：this.options.template = this.getFullTemplatePath(this.options.template, compiler.context); 因此template只有定义在webpack的context下才会被识别，webpack context的默认值为process.cwd()，即运行 node 命令时所在的文件夹的绝对路径 filename 作用：输出的HTML文件名，默认为index.html，可以直接配置带有子目录 源码：this.options.filename = path.relative(compiler.options.output.path, filename); 所以filename的路径是相对于output.path的，而在webpack-dev-server中，则是相对于webpack-dev-server配置的publicPath。 如果webpack-dev-server的publicPath和output.publicPath不一致，在使用html-webpack-plugin可能会导致引用静态资源失败，因为在devServer中仍然以output.publicPath引用静态资源，和webpack-dev-server的提供的资源访问路径不一致，从而无法正常访问。 有一种情况除外，就是output.publicPath是相对路径，这时候可以访问本地资源 所以一般情况下都要保证devServer中的publicPath与output.publicPath保持一致。 路径斜杠配置中/代表url根路径：（例如http://localhost:8080/dist/js/test.js中的http://localhost:8080/） devServer devServer.contentBase 告诉服务器从哪里提供内容。只有在你想要提供静态文件时才需要。 devServer.publicPath 将用于确定应该从哪里提供 bundle，并且此选项优先。 node中的路径文件结构：123456app/ -lib/ -common.js -model -task.js -test.js task.js 123456var path = require('path');console.log(__dirname); // console.log(__filename);console.log(process.cwd());console.log(path.resolve('./')); 在 model 目录下运行 node task.js 得到的输出是： 1234/Users/guo/Sites/learn/app/model/Users/guo/Sites/learn/app/model/task.js/Users/guo/Sites/learn/app/model/Users/guo/Sites/learn/app/model 在 app 目录下运行 node model/task.js，得到的输出是： 1234/Users/guo/Sites/learn/app/model/Users/guo/Sites/learn/app/model/task.js/Users/guo/Sites/learn/app/Users/guo/Sites/learn/app 绝对路径 __dirname: 总是返回被执行的 js 所在文件夹的绝对路径 __filename: 总是返回被执行的 js 的绝对路径 process.cwd(): 总是返回运行 node 命令时所在的文件夹的绝对路径 相对路径 ./ : 在 require() 中使用是跟 __dirname 的效果相同，不会因为启动脚本的目录不一样而改变，在其他情况下跟 process.cwd() 效果相同，是相对于启动脚本所在目录的路径。 ../ require的路径必须是相对于当前执行文件的,只有在 require() 时才使用相对路径(./, ../) 的写法，其他地方一律使用绝对路径，如下： 1234// 当前目录下path.dirname(__filename) + '/test.js';// 相邻目录下path.resolve(__dirname, '../lib/common.js');","tags":[]},{"title":"自己写 cli 提高工作效率","date":"2018-12-21T07:06:44.000Z","path":"2018/12/21/自己写 cli 提高工作效率/","text":"tags: [组件]categories: 前端工程化 cli 工具需要满足的需求 获得用户的输入，并且根据相应的输入，可以定制编程相应执行逻辑 模板代码有两种实现思路，一是采用代码生成，二是分离静态资源模板 使用包管理工具 项目需求 自动创建组件需要的目录 自动添加模版代码 添加组件 js 和 css 代码 推荐包commandercommander.js commander是目前很成熟的Node命令行交互接口实现工具，使用该工具可以很便捷很快速地实现第一点需求 git-clonegit-clone是一个很轻量的Node编写的git clone封装，可以很便捷很快速地从github上克隆执行项目模板。也就是说，我们将项目模板静态存储在github上，每当执行cli命令时，将其下载，这样我们就很轻松地得到了项目代码模板。另外，当需要改变项目模板代码时，只需要修改github上的项目代码就可以，cli工具无需修改 shelljsshelljs同样是一个很轻量的Node编写的系统命令封装，可以很便捷很快速地在Node代码中使用系统命令。在本例中，因为从github上下载的项目代码会带有.git文件，需要使用rm命令将其删除 chalk用于高亮终端打印出来的信息 request发送http请求的工具 初始化项目1234mkdir rc-newcd rc-newnpm init -yyarn add react 创建模板文件React 新建组件的方式有三种： 类组件：class.jsx 函数组件: functional.jsx 纯组件: pure-class.jsx 12345mkdir src cd srcmkdir templatecd templatetouch class.jsx functional.jsx pure-class.jsx 1234567891011// class.jsximport React, &#123; Component &#125; from 'react';// COMPONENT_NAME 是占位符class COMPONENT_NAME extends Component &#123; render() &#123; return &lt;div /&gt;; &#125;&#125;export default COMPONENT_NAME; 12345678import React from 'react';const COMPONENT_NAME = () =&gt; &#123; return &lt;div /&gt;;&#125;;export default COMPONENT_NAME; 12345678910import React, &#123; PureComponent &#125; from 'react';class COMPONENT_NAME extends PureComponent &#123; render() &#123; return &lt;div /&gt;; &#125;&#125;export default COMPONENT_NAME; 命令行工具1、package.json 设置入口文件123\"bin\": &#123; \"rc-new\": \"./src/index.js\" &#125;, 2、在 bin/index.js 顶部声明此文件需要调用 Node.js 执行1#!usr/bin/env/ node 3、命令行交互模块 commander.js1yarn add chalk commander prettier 1const program = require('commander') 执行打开命令行工具，进入当前开发文件夹,输入命令bin/index.js，即可以输出“my first cli” 我们如何像发布后一样，直接输node-cli命令就可以调用我们的主文件呢？ 在开发目录执行sudo npm link将模块链接到全局，如想去掉 link，执行sudo npm unlink","tags":[]},{"title":"webpack To V4 from V3","date":"2018-12-19T10:11:47.000Z","path":"2018/12/19/webpack To V4 from V3/","text":"tags: [组件]categories: 前端工程化 Node.jsNode.js &gt;= V6 Cliwebpack-cli 需要单独安装 插件许多插件需要更新到最新的可兼容版本 mode新特性用来区分环境1234module.exports = &#123; // ... mode: 'production',&#125; 或者通过命令行Cli命令：--mode production/--mode development 已移除|分离的插件prod 模式移除的插件123456789module.exports = &#123; // ... plugins: [- new NoEmitOnErrorsPlugin(),- new ModuleConcatenationPlugin(),- new DefinePlugin(&#123; \"process.env.NODE_ENV\": JSON.stringify(\"production\") &#125;)- new UglifyJsPlugin() ],&#125; dev 模式移除的插件123456module.exports = &#123; // ... plugins: [- new NamedModulesPlugin() ],&#125; 已经分离的插件1234567module.exports = &#123; // ... plugins: [- new NoErrorsPlugin(),- new NewWatchingPlugin() ],&#125; 再见 CommonsChunkPlugin提取公共代码 webpack4.0 不再使用CommonsChunkPlugin，取而代之的是内置的 optimization.splitChunks ，默认的配置或许可以完全满足你的需求 1、commonchunk配置项被彻底去掉，之前需要通过配置两次 new webpack.optimize.CommonsChunkPlugin 来分别获取 vendor 和 manifest 的通用chunk方式已经做了整合， 直接在optimization中配置 runtimeChunk 和 splitChunks 即可 ，提取功能也更为强大2、runtimeChunk 可以配置成 true，single 或者对象，用自动计算当前构建的一些基础chunk信息，类似之前版本中的 manifest 信息获取方式。3、webpack.optimize.UglifyJsPlugin 现在也不需要了，只需要使用 optimization.minimize 为 true 就行，production mode下面自动为 true，当然如果想使用第三方的压缩插件也可以在 optimization.minimizer 的数组列表中进行配置 1234567891011121314151617181920212223242526module.exports = &#123; //... optimization: &#123; splitChunks: &#123; chunks: 'async', minSize: 30000, maxSize: 0, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', name: true, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125; &#125; &#125;&#125;; 再见 extract-text-webpack-plugin提取 JS 中的 CSS 代码到单独的文件中 webpack4.0 不再使用 extract-text-webpack-plugin，取而代之的是mini-css-extract-plugin 123456789101112131415161718192021222324252627// webpack.dev.jsconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");const devMode = process.env.NODE_ENV !== 'production'module.exports = &#123; plugins: [ new MiniCssExtractPlugin(&#123; // Options similar to the same options in webpackOptions.output // both options are optional filename: devMode ? '[name].css' : '[name].[hash].css', chunkFilename: devMode ? '[id].css' : '[id].[hash].css', &#125;) ], module: &#123; rules: [ &#123; test: /\\.(le|c)ss$/, use: [ devMode ? 'style-loader' : MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'less-loader', ], &#125; ] &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435// webpack.prod.jsconst UglifyJsPlugin = require(\"uglifyjs-webpack-plugin\");const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");const OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\");module.exports = &#123; optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; cache: true, parallel: true, // 多线程 sourceMap: true // set to true if you want JS source maps &#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;) ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: \"[name].css\", chunkFilename: \"[id].css\" &#125;) ], module: &#123; rules: [ &#123; test: /\\.(sa|sc|c)ss$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'less-loader', ], &#125; ] &#125;&#125; import() and CommonJS当通过 import() 导入 non-esm.js 的结果时，现在你需要通过 default 属性来获取 module.exports 的值 123456# non-esm.jsmodule.exports = &#123; sayHello: () =&gt; &#123; console.log('hello world'); &#125;&#125;; 123456# example.jscfunction sayHello() &#123; import('./non-esm.js').then(module =&gt; &#123; module.default.sayHello(); &#125;);&#125; json and loaders当用自定义的loader来转换 .json 文件时，需要添加 module.rules.type1234567891011module.exports = &#123; // ... rules: [ &#123; test: /config\\.json$/, loader: 'special-loader',+ type: 'javascript/auto', options: &#123;...&#125; &#125; ]&#125;; 如果使用 json-loader ，可以移除 123456789module.exports = &#123; // ... rules: [ &#123;- test: /\\.json$/,- loader: 'json-loader' &#125; ]&#125;; module.loadersmodule.loaders 已移除，被 module.rules 取代 参考资源更多插件请见 https://webpack.js.org/plugins/ 报错信息","tags":[]},{"title":"VScode 插件工具集，不求全但求好","date":"2018-12-18T07:36:06.000Z","path":"2018/12/18/VScode 插件工具集，不求全但求好/","text":"更多插件可以到官网自行探索 根据调查发现，VScode 和 sublime 是前端开发者比较喜欢的 IDE 。“工欲善其事，必先利其器”，我是一个爱折腾的工具控，刚开始用 VScode 的时候，装了一堆的插件，导致只要开启 VScode 再接上大屏，我的 Mac 就会强烈的反抗，风扇一直呼啸，😳😳….后来就开启卸载模式，开始一直卸，最终保留一些小而美，使用率高的插件，整理一份以便不备之需。 而对于一个团队而言，大家用同一套快捷键，同一个IDE，同一套插件，那么结对编程将会是一件特别幸福的事情。和帅哥哥一起编程还是可以学到很多东西的，嘻嘻～～ 一、代码快捷键在 VScode 的首页可以设置通用快捷键，因为平常用sublime比较多，所以干脆合并成一套。 二、代码提示Path Intellisense自动路径补全 Document thisjs 的注释模板 （注意：新版的 vscode 已经原生支持,在 function 上输入 /** tab ） 三、代码格式ESlint代码规范，对不符合要求的代码或者有语法错误的JS代码进行提示，可以自定制提示规则 HTMLHinthtml代码检测 beautify格式化代码的工具 四、代码可视化改善colorize可视化颜色哦，做组件涉及很多不同的主题，个人还是蛮稀饭的 RegExp Preview and Editor这个就厉害了.可以完美的展示你写的正则,图形化给你看你写正则的形成 Better Comments最好用的注释区域高亮,对于TODO这些支持也很好 BreadCrumb in StatusBar 华丽丽的分割线，以下插件根据框架语言选择，用什么装什么，不用就不要装了，浪费内存 五、React 插件ES7 React/Redux/GraphQL/React-Native snippets涵盖的代码片段贼丰富，React 相关代码提示有这个就够了 Useful React Snippets当然如果你只用React,那用这个代码提示吧，管够了 CSS Blocks支持 css 模块化的智能提示，跳转，墙裂推荐 styled-components-snippetsstyled-components 的代码片段 六、Vue 插件vetur语法高亮、智能感知、Emmet 等 VueHelpersnippet 代码片段 Vue VSCode Snippets很全面的vue代码片段 七、Nodeeggjs蛋框的相关帮助插件,代码片段,智能提示等 egg-jump-definition蛋框的函数跳转：Cmd+4 八、微信小程序mpvue snippetsmpvue的一些代码片段,以及部分原生小程序的代码提示 minapp用VS Code写小程序必备的插件,里面有众多实用的特性集成 九、Markdown 插件Markdown All in OneMarkdown 的提示插件用这一个足以，集成了语法快捷键、Math、预览等，很实用 markdownlint对 markdown 的语法格式规范进行代码提示 十、代码审查CodeMetrics可以计算TS/JS内代码的复杂度(比如函数这些),这些与代码质量和性能是挂钩的 Import Cost就是你import一个东西的时候,可以计算改引入模块的大小! Git Lens暂时没有发现比这个看git记录更为详细了 十一、其他下面的插件可有可无，如有相应功能的需求，却也是非常棒的插件 fileheader顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间 ctrl+alt+i Paste JSON as CodeJSON 格式转换成其他的语言格式 Node.js Modules Intellisense对于 node_module 的智能提示 npm-import-package-version显示导入的 npm 包的版本信息 File Tree View提供几个常见编程语言的函数或状态的树集合展示,可以快速点击跳转!! NPM-Scripts在侧边栏可视化执行 npm 命令(项目内的package.json), 小巧实用 :emojisense: 十二、代码片段两种方式定义代码片段 菜单栏-&gt;文件-&gt;首选项-&gt;用户代码片段 ctrl+shift + p =&gt; snippet toRem: 只是一个单纯的描述 prefix: 是触发snippet的简写 body: 是展开的代码片段 \\$1,\\$2：表示占位符，用于用户展开代码片段所需要替换的，也可以写成\\${1:label}键值对的方式 description: 用户你在输出snippet之前，方便自己识别的注释，而不用强行记忆那些简写的","tags":[]},{"title":"package.json 的解读","date":"2018-12-17T07:09:31.000Z","path":"2018/12/17/package.json 的解读/","text":"tags: [组件]categories: 前端工程化 官方字段json 和 JS 对象的区别package.json，顾名思义，它是一个json文件，而不能写入JS对象。所以我们首先要搞懂的是JSON和JS对象的区别： 区别 Json Javascript对象 含义 仅仅是一种数据格式 表示类的实例 传输 可以跨平台数据传输，速度快 不能传输 表现 1、键值对方式，键必须加双引号 2、值不能是\b方法函数，不能是undefined|NaN 1、键值对方式，键不加引号 2、值可以是函数、对象、字符串、数字、boolean等 相互转换 Json转化为JS对象： 1、JSON.parse(jsonstring); 2、json=eval(“(“+jsonstring+”)”) JS对象转换为JSON: JSON.stringify(json) 【注意】 在JSON中属性名一定要加上双引号 name 字段name字段的限制 name字段必须小于214字符（这个没什么好记的～） name字段不能包含有“.”符号和下划线（这个要记一下哦～） name字段不能包含有大写字母（这个要记一下哦～） name字段不能含有非URL安全的字符，因为它将当发布的时候，它将作为你的包的相关信息被写入URL中 那么，有哪些算是非URL安全的字符呢？咱们看表说话： version 字段npm对version定义的规则要求对于”version”:”x.y.z”1.修复bug,小改动，增加z2.增加了新特性，但仍能向后兼容，增加y3.有很大的改动，无法向后兼容,增加x 例如：我原本的项目是1.0.0版本的话若是1中情况，变为1.0.1若是2中情况，变为1.1.0若是3中情况，变为2.0.0 npm 有自己的检验version的模块——node-semvernpm有自己的一套检验version正确性的模块，它叫做 node-semver，是一开始就跟随着npm一起被打包安装的。当然了，你也可以通过自己安装去在自己的项目中使用它。使用的例子像这样：先npm install –save semver然后: 123const semver = require('semver')semver.valid('1.2.3') // '1.2.3'semver.valid('a.b.c') // null keywords 和 description 字段字段要求：description：字符串keywords：字符串数组 简单地说，这两个东东是npm搜索系统中的搜索条件，所以。如果你试图发布的是一个开源插件，那么这两个字段你应该重视 license 字段这是你指定的项目的许可证，它告诉他人他们是否有权利使用你的包，以及，在使用你的包的时候他们应该受到怎样的限制 字段要求：单个license：直接写入名称 1&#123; \"license\" : \"BSD-3-Clause\" &#125; 多个license：在一对圆括号内写入license名称，且在多个license内用AND等连接 1&#123; \"license\" : \"(ISC AND GPL-3.0)\" &#125; SPDX license表达式的语法规则 2.0版本 author 字段要求：一个字符串或是一个对象。如果是一个对象，该对象包含三个属性：name属性(必填)email属性（选填）URL属性（选填） 1234&#123; \"name\" : \"Barney Rubble\", \"email\" : \"b@rubble.com\", \"url\" : \"http://barnyrubble.tumblr.com/\"&#125; main 字段这个是你项目的入口文件。简而言之，当别人安装了你发布的模块时，require你的模块的时候取得的就是你main字段规定的入口文件的输出。 例如你写入了 { “main”:”XXX.js”}，而他人通过npm install ‘你的模块名称’ . 安装了你的模块后，他通过 var X = require(‘你的模块名称’)取得的就是你在XXX.js的输出 script 字段写进scripts的命令(command),可以通过npm run 或者npm 运行对应的shell指令，例如：{“scripts”: { “start”: “node main.js”} } 可以让你在终端输入npm start的时候，等同于运行了node main.js 什么时候要加“run”,什么时候可以不用加“run”呢？一个让我们可能有些困扰的问题是，通过script字段内的npm命令运行脚本时，有时候要加“run”，有时候又不要加&quot;run&quot;,即有时候是可以直接用npm &lt;command&gt;；而有时候又要用npm run &lt;command&gt; 才能运行脚本，这该如何区分呢？ 首先要提一下的是，run的原名是run-script，是一段脚本，而run是它的一个别名（alias） 1.当run[-script]被 test, start, restart, and stop这四个自带的命令所使用时，它可以被省略（或者说不需要加“run”就可以直接调用），所以我们平时最常输入的npm start实际上相当于npm run start，只不过是为了方便省略了run而已 原文：run[-script] is used by the test, start, restart, and stop commands, but can be called directly 2.当你在package.json的script字段中定义的是除了1中的4个命令外的命令的时候，你就不能省略“run”了例如你定义 123\"scripts\": &#123; \"build\": \"XXX.js\"&#125; 的时候，你运行XXX.js就只能通过npm run build去运行了 npm 为script字段中的脚本路径都加上了node_moudles/.bin前缀npm为script字段中的脚本路径都加上了node_moudles/.bin前缀，这意味着：你在试图运行本地安装的依赖在 node_modules/.bin 中的脚本的时候，可以省略node_modules/.bin这个前缀。例如：我刚npm install webpack了，而在我的项目下的node_modules目录的.bin子目录下：就多了一个叫做webpack的脚本 本来运行这个脚本的命令应该是：node_modules/.bin webpack但由于npm已经自动帮我们加了node_modules/.bin前缀了，所以我们可以直接写成： 1\"scripts\": &#123;\"start\": \"webpack\"&#125; 而不用写成： 1\"scripts\": &#123;\"start\": \"node_modules/.bin webpack\"&#125; 原文：npm run adds node_modules/.bin to the PATH provided to scripts. Any binaries provided by locally-installed dependencies can be used without the node_modules/.bin prefix npm start是有默认值的，默认为：node server.js better-npm-run 的安装与betterScript字段的使用这个是package.json文档介绍里所没有的，但这里我想特别讲一下： 先通过npm install better-npm-run安装好包，然后你就可以在你的package.json里面使用一个新的字段—— “betterScripts”字段 故名思意，它和”scripts”字段很像，那么两者间有什么联系呢？咱还是用代码说话吧，它可以把 123\"scripts\": &#123; \"test\": \"NODE_ENV=production karma start\"&#125; 变成： 1234567891011\"scripts\": &#123; \"test\": \"better-npm-run test\"&#125;,\"betterScripts\": &#123; \"test\": &#123; \"command\": \"karma start\", \"env\": &#123; \"NODE_ENV\": \"test\" &#125; &#125;&#125; 简单地说，就是当运行”scripts”字段中的命令的时候，它会进一步去运行 “betterScripts”中对应的命令，并通过”env”对象控制运行时的环境变量，如NODE_ENV。 好处是让你的代码的可读性更强一些 另外提一下NODE_ENV的作用：用来设置环境变量（默认值为development）。通过检查这个值可以分别对开发环境和生产环境下做不同的处理 例如在服务端代码中通过检查是否是开发环境（development）决定是否启动代码热重载功能 （热重载只是为了在开发环境【developmen】提高生产效率用，在生产环境【production】没用） 123456if (process.env.NODE_ENV === 'development') &#123;// 省略诸多内容app.use(require('webpack-hot-middleware')(compiler, &#123; path: '/__webpack_hmr'&#125;))&#125; dependencies 字段和 devDependencies 字段dependencies字段和devDependencies字段分别代表生产环境依赖和开发环境依赖 与两个字段相关的npm install的命令npm install 模块 –save 安装好后写入package.json的dependencies中（生产环境依赖）npm install 模块 –save-dev 安装好后写入package.json的devDepencies中（开发环境依赖） 怎么区分到底安装包的时候放在dependencies中还是devDepencies中呢？ 很简单1.一般你去github或者npm社区里面相关包的介绍后面都会带有–save 或者–save-dev 的参数的，这时候把命令直接复制过来运行就OK了，不用管那么多 2.如果没有1中的介绍，那么请思考，这个包到底是纯粹为了开发方便使用呢？还是要放到上线后APP的代码中呢？前者则为devDepencies，后者则为dependencies 【注意】：在团队协作中，一个常见的情景是他人从github上clone你的项目，然后通过npm install安装必要的依赖，（刚从github上clone下来是没有node_modules的，需要安装）那么根据什么信息安装依赖呢？就是你的package.json中的dependencies和devDepencies。所以，在本地安装的同时，将依赖包的信息（要求的名称和版本）写入package.json中是很重要的！ prepublishOnly 字段1\"prepublishOnly\": \"npm run build\" 这样每次执行npm publish前都会先执行npm run build peerDependencies 字段同版本依赖 非官方字段yarn 相关字段yarn : 类似 npm 的依赖管理工具，但 yarn 缓存了每个下载过的包，所以再次使用时无需重复下载，同时利用并行下载以最大化资源利用率，因此安装速度更快。 flat123&#123; \"flat\": true&#125; 如果你的包只允许给定依赖的一个版本，你想强制和命令行上 yarn install –flat 相同的行为，把这个值设为 true。 详细参考 yarn - flat.. resolutions12345678&#123; \"resolutions\": &#123; \"transitive-package-1\": \"0.0.29\", \"transitive-package-2\": \"file:./local-forks/transitive-package-2\", \"dependencies-package-1/transitive-package-3\": \"^2.1.1\" &#125; &#125; 允许你覆盖特定嵌套依赖项的版本。有关完整规范，请参见选择性版本解析 RFC。 详细参考 yarn - resolutions. unpkg 相关字段unpkg: 让 npm 上所有的文件都开启 cdn 服务。 unpkg 1234# jquery&#123;\"unpkg\": \"dist/jquery.js\"&#125; 正常情况下，访问 jquery 的发布文件通过 https://unpkg.com/jquery@3.3.1/dist/jquery.js，当你使用省略的 url https://unpkg.com/jquery 时，便会按照如下的方式获取文件： [latestVersion] 指最新版本号，pkg 指 package.json 定义了 unpkg 属性时 https://unpkg.com/jquery@[latestVersion]/[pkg.unpkg] 未定义 unpkg 属性时，将回退到 main 属性 https://unpkg.com/jquery@[latestVersion]/[pkg.main]详细参考 https://unpkg.com. TypeScript 相关字段TypeScript: JavaScript 的超集types, typings1234&#123; \"main\": \"./lib/main.js\", \"types\": \"./lib/main.d.ts\"&#125; 就像 main 字段一样，定义一个针对 TypeScript 的入口文件。 详细参考 TypeScript documentation. browserslist 相关字段browserslist: 设置项目的浏览器兼容情况。browserslist 123456&#123;\"browserslist\": [\"&gt; 1%\",\"last 2 versions\"]&#125; 支持的工具： AutoprefixerBabelpostcss-preset-enveslint-plugin-compatstylelint-no-unsupported-browser-featurespostcss-normalize详细参考 browserslist. 发行打包相关字段点击 Setting up multi-platform npm packages 查看相关介绍。 module1234&#123;\"main\": \"./lib/main.js\",\"module\": \"./lib/main.m.js\"&#125; 就像 main 字段一样，定义一个针对 es6 模块及语法的入口文件。构建工具在构建项目的时候，如果发现了这个字段，会首先使用这个字段指向的文件，如果未定义，则回退到 main 字段指向的文件。 支持的工具： rollupwebpack详细参考 rollup - pkg.module. browser1234&#123; &quot;main&quot;: &quot;./lib/main.js&quot;, &quot;browser&quot;: &quot;./lib/main.b.js&quot;&#125; 指定该模块供浏览器使用的入口文件。如果这个字段未定义，则回退到 main 字段指向的文件。 支持的工具： rollupwebpackbrowserify详细参考 babel-plugin-module-resolver. esnext12345&#123;&quot;main&quot;: &quot;main.js&quot;,&quot;esnext&quot;: &quot;main-esnext.js&quot;&#125; 1234567&#123; \"main\": \"main.js\", \"esnext\": &#123; \"main\": \"main-esnext.js\", \"browser\": \"browser-specific-main-esnext.js\" &#125;&#125; 使用 es 模块化规范，stage 4 特性的源代码。详细参考 Transpiling dependencies with Babel, Delivering untranspiled source code via npm. es20151234&#123; \"main\": \"main.js\", \"es2015\": \"main-es2015.js\"&#125; Angular 定义的未转码的 es6 源码。详细参考 https://docs.google.com/document/d/1CZC2rcpxffTDfRDs6p1cfbmKNLA6x5O-NtkJglDaBVs/edit#. esm详细参考 adjusted proposal: ES module “esm”: true package.json flag. react-native 相关字段react-native: 使用 react 组件技术写原生APP。 react-native1234&#123; \"main\": \"./lib/main.js\", \"react-native\": \"./lib/main.react-native.js\"&#125; 指定该模块供 react-native 使用的入口文件。如果这个字段未定义，则回退到 main 字段指向的文件。 源代码查看. webpack 相关字段sideEffects123&#123; \"sideEffects\": true|false&#125; 声明该模块是否包含 sideEffects（副作用），从而可以为 tree-shaking 提供更大的优化空间。详细参考 sideEffects example, proposal for marking functions as pure, eslint-plugin-tree-shaking. microbundle 相关字段microbundle: 基于 rollup 零配置快速打包工具。 source123&#123; \"source\"： \"src/index.js\"&#125; 源文件入口文件。 详细参考 Specifying builds in package.json. umd:main1234&#123; \"umd:main\"： \"dist/main.umd.js\"&#125; umd 模式 bundle 文件。详细参考 Specifying builds in package.json. parcel 相关字段parcel: 零配置打包工具。 source查看 parcel-bundler/parcel#1652. babel 相关字段babel: es6 -&gt; es5 转码器。 babel配置 babel。 eslint 相关字段eslint: js 代码检查与优化。 eslintConfig配置 eslint。 jest 相关字段jest: js 测试库。 jest12345&#123; \"jest\": &#123; \"verbose\": true &#125;&#125; 配置 jest。详细参考 jest docs. stylelint 相关字段stylelint: style 代码检查与优化。 stylelint配置 stylelint。 详细参考 New configuration loader. ava 相关字段ava: js 测试库。 ava12345&#123; \"ava\": &#123; \"require\": [ \"@std/esm\" ] &#125;&#125; 配置 ava。详细参考 ava configuration. nyc 相关字段nyc: istanbul.js 命令行。 nyc123456&#123; \"nyc\": &#123; \"extension\": [\".js\", \".mjs\"], \"require\": [\"@std/esm\"] &#125;&#125; 配置 nyc。详细参考 nyc docs. CommonJS 保留字段保留字段: build, default, email, external, files, imports, maintainer, paths, platform, require, summary, test, using, downloads, uid. 不可用字段: id, type, 以 _ 和 \\$ 开头的字段。 Standard JS 相关字段Standard JS: js 代码检查与优化。 standard123456789101112&#123; \"standard\": &#123; \"parser\": \"babel-eslint\", \"ignore\": [ \"**/out/\", \"/lib/select2/\", \"/lib/ckeditor/\", \"tmp.js\" ] &#125;&#125; 配置 standard.详细参考 https://standardjs.com/. 其他style声明当前模块包含 style 部分，并指定入口文件。 支持的工具： parcelifynpm-lessrework-npmnpm-css详细参考 Package.json “style” Attribute, istf-spec. less与 style 一样，但是是 less 文件。 支持的工具： npm-less 更多参考 package.json fields explained 参考资源package.json 非官方字段集合官方字段文档：https://docs.npmjs.com/files/package.json","tags":[]},{"title":"Dbox 内部开源组件背后的故事","date":"2018-12-13T07:22:56.000Z","path":"2018/12/13/Dbox 内部开源组件背后的故事/","text":"download: 前端技术选型会 - IF-RCM ☎.pdf 前言已有组件 OR 自造组件？？？基础和灵活 VS 定制化和效率 垂直行业领域专业性组件 强主题风格组件 强交互组件 甚至是同款组件，不同配置 123&gt; 组件 -&gt; 通用组件 -&gt; 通用组件库 &gt; |-&gt; 业务组件 -&gt; 业务组件库 -&gt; 行业柱(n) -&gt; 组件平台 -&gt; 物料市场&gt; 自造组件我们得到了什么 规范 =》 体系 产品功能迭代 技术变更(UI 设计层可以不变) 人事变动、人才流失 沟通(跨部门的共通语言) 客户需求多样性 效能 团队成长 走出去的可能 什么样的产品需要组件赋能 量极大功能复杂 产品项目变动频繁，并发很多 产品间往往有较高的关联性 产品间存在共性 使用者具备很强的专业性 开放的趋势 设计体系组件纬度 Atoms原子。 为网页构成的基本元素。例如按钮，也可以为抽象的概念，例如字体、色调等。 Molecules分子。 由原子构成的简单UI组件。例如，表单标签，搜索框和按钮共同打造了一个搜索表单分子。 Organisms组织。 由原子及分子组成的相对复杂的UI构成物。 Templates模版。 将以上元素进行排版，显示设计的底层内容结构。 Pages页面。 将实际内容（图片、文章等）套件在特定模板，页面是模板的具体实例 统一的视觉风格和交互规范X 组件在 A 业务场景是一个交互，在 B 业务场景是另一个 UI 风格，这样就无法对 X 进行抽象，极大的增加了组件的构建成本。所以，设计组件之初，首先需要抽象和约定一套统一的视觉风格和交互规范。 足够的可扩展性组件在落地到实际项目中时，有各种不同的需求，默认的定制化并不能适用于任何的场景，只有具备良好拓展性的组件才能应用到不同的业务线，以“不变应万变” 一定的可控性组件封装有一定的不确定性，更多时候是在做几个方面的权衡，并且在业务不断变化中，可能还会面临一些调整和重构。将不确定性控制在一定范围内。 组件适用性检验源于业务，归于业务。确保产出可以快速的在实际场景中得到验证，快速试错。 通过开源的方式获取更多的反馈 通过内部项目落地迭代组件API 产出物 产品和技术结合最为紧密的部分 最为稳定及复用程度最高的部分 一份文档多人使用 开发者说明 设计体系规范 代码片段、工具函数 培训文档 社区化：灵活的沟通机制 前端体系代码规范 开发者说明 代码 review 工具检验 集成了 eslint、stylelint、git hook 的前端代码检查工具。 初始化 eslint/stylelint 配置文件 安装 eslint/stylelint 及其依赖到当前项目的 node_modules 里 挂载 git 钩子，在提交代码时进行强制校验 组件设计思路在UI层面视觉上的组件是一种产品形式，界限是“视觉可分”，但是在代码层面，也会存在“逻辑可分”，所以开发者开开发前应对业务场景进行分析，把控代码层的组件粒度。 什么情况下需要抽离组件 不能狭隘地认为只是为了复用（包括对于模块化的理解），认为只有一个地方用就没必要抽取封装为组件 组件化是对实现的__分层__，是更有效地代码组合方式 组件化是对资源的重组和优化，从而使项目__资源管理__更合理 组件化有利于__单元测试__ 组件化对__重构__较友好 组件封装原则高复用性 + 少组件 + 大组件 高复用性：对项目中所有Web页面的结构有清晰的把握，能准确提取样式或功能雷同的模块并将其封装成组件 少组件：当深层次的成员无需组件化时，可直接将外层的父元素组件化以减少组件的数量，该原则是基于开发效率考虑的 大组件：应更多的将零散组件拼装成更大的组件，可以简化组件的调用，提升团队开发效率 容器组件 + 展示组件 容器组件：处理数据、逻辑（数据格式化）；对接后端API，格式改变则改变该组件 展示组件：处理样式；对接视觉设计及用户体验，这些组件不关注自己何时何处被渲染 Functional Components应该最大限度的编写和使用 Functional Components : 无状态、无方法、纯组件 数据模型原则：对数据切分时，props的优先级要高于state，尽可能保证组件的无状态化，简化组件的交互逻辑 共享数据（固定数据）：props对象（单向流动性|显示传递性|只读性） &amp;&amp; store 私有数据（动态数据）：state对象 需要反复琢磨的问题Q1：这个组件可否（有必要）再分？ 组件划分的依据通常是 业务逻辑 功能，要考虑各组件之间的关系是否明确（如组件树方式管理组件间依赖关系，兄弟组件不可见），以及组件的可复用度。划分粒度的大小需要根据实际情况权衡，太小会提升维护成本，太大又不够灵活和高复用性。 每一个组件都应该有其独特的划分目的的，有的是为了复用实现，有的是为了封装复杂度清晰业务实现。 Q2：这个组件的依赖是否可再缩减？ 缩减组件依赖可以提高组件的可复用度，常用的方法是IoC（依赖注入），对外弱类型依赖。 Q3：这个组件是否对其它组件造成侵入？ 一个组件的封装性不够，或者自身越界操作，就可能对自身之外造成了侵入，这种情况应该尽量避免，确保组件的生命周期能够对其影响进行有效的管理（如destroy后不留痕迹）。较常见的一种情况是：组件运行时对window对象添加resize监听事件以实现组件响应视窗尺寸变化事件，这种需求的更好替代方案是：组件提供刷新方法，由父组件实现调用（最终由根组件统一处理）。 次优的方案是，当组件destroy前清理恢复。 一个组件不应对其它兄弟组件造成直接影响。 Q4：这个组件可否复用于其它类似场景中？ 需要考虑需要适用的不同场景，在组件接口设计时进行必要的兼容 Q5：这个组件当别人用时，会怎么想？ 接口设计符合规范和大众习惯，尽量让别人用起来简单易上手，易上手是指更符合直觉。假如业务需要不需要这个功能，是否方便清除？ 各组件之间以组合的关系互相配合，也是对功能需求的模块化抽象，当需求变化时可以将实现以模块粒度进行调整。 开发流程 组件初始化: 自动创建组件需要的目录和模版代码 组件 Coding 组件 Demo 组件文档 组件测试 开发者自测 UI 及 API 开发者互测API UI 人肉测试 开发者单元测试 测试流程开发者自测 UI 及 API开发者根据UI设计稿开发完成后，自己根据UI要求及文档分场景根据文档生产工具的 playground 完成自测。 ⚠️极端数据测试 数据为空时 数据接口调用错误时 请求参数极端情况 数据特别小时 数据特别大时 为null，NaN，undefine 开发者互测 API开发者团队内部通过结对编程的方式完成组件的API互测。 开发者单元测试 React 生态圈会推荐使用 jest + enzyme 配套工具 Jest是 Facebook 开发的一个测试框架，它集成了测试执行器、断言库、spy、mock、snapshot和测试覆盖率报告等功能。React 项目本身也是使用 Jest 进行单测的，因此它们俩的契合度相当高。但是使用 jest 做 UI 测试有局限性，只能测试基本的 dom 结构 和 样式，一些逻辑交互无法测到，只能覆盖大部分的情况。 Enzyme是由 airbnb 开发的 React 单测工具。它扩展了 React 的 TestUtils 并通过支持类似 jQuery 的 find 语法可以很方便的对 render出来的结果做各种断言。 UI 人肉测试开发团队测试流程全部走完后，提交到UI设计者测试流程，完成组件UI层面场景、视觉、交互的评审。 发包流程组件发包只有拥有发包权限的人才能操作，Dbox 是以组件库为单位发包的，使用命令 yarn publish 发包，在发包之前会跑组件测试，只有测试通过以后才能发包。 维护流程组件日常维护占整个组件库生命周期的很大一部分，组件库做起来了以后，组件功能后续会不断迭代，也许是 bug fix，也可能是 new feature。 PR / issue 的处理：PR规范 发包 管理 changelog 项目落地 UI组件 脚手架 使用文档 项目官网及社区 命令行 接口数据 mock 工具 构建工具栈 业务组件: 在业务组件库中，不必那么灵活，支持业务需要的属性配置即可。可以封装业务相关的代码进去，而不用担心影响其他业务线，更高的封装程度和业务属性会让该业务线的开发体验和效率提升一个量级 数据上报 监控体系(错误监控、性能监控、业务监控、服务监控) 持续集成: 部署流程和部署平台 自动化测试 后记组件化这条路上，我们还有很多事情要做 参考资源 教你用Sketch Libraries构建组件库/设计体系 - 优设-UISDC 重新设计 React 组件库 http://sangka-z.com/react-in-patterns-cn/chapter-11/ https://blog.csdn.net/liangklfang/article/details/74025364 https://github.com/penouc/blog/issues/7 React 组件设计模式基础 https://juejin.im/post/5a73d6435188257a6a789d0d 谈谈 Vue 业务组件 https://juejin.im/entry/5a97b8bc518825555b2e1845","tags":[{"name":"components","slug":"components","permalink":"http://lulustyle.net/tags/components/"}]},{"title":"大屏业务场景解决方案","date":"2018-12-13T04:36:21.000Z","path":"2018/12/13/大屏业务场景解决方案/","text":"tags: [组件]categories: 业务场景解决方案 无论是在科幻电影还是在真实世界里，可视化大屏都是非常常见的一种表现手法。之前在市局看到了大屏是由多个屏幕组成，看起来有两层楼那么高。 技术栈：echarts + css3 + vw + vh + rem因为运用了大量css3 新特性，所以建议使用 google浏览器，投大屏。 可视化大屏的特性可视化大屏，归根到底还是运用的可视化技术，只不过展现的屏幕比起笔记本和显示器大了很多。相比于传统的桌面级可视化运用，大屏可视化的特性有: 屏幕巨大，用户通常离屏幕比较远，文字表达出来的信息需要足够清楚，通常要在字体和颜色上做文章。 弱化交互，基于键盘和鼠标的交互方式很少，更多时候系统自己做出响应，而不是让人工介入。 视觉冲击力强，设计一般都是以深色为底色，一来科技感十足，二来可以配合突出的主体动画和强设计感的元素。 场景化，一块大屏通常用来展示一类场景，场景主要由图表构成，后台管理系统那套表单通常不会出现在大屏。 动画更重要了，用动画表现出来的数据，通常是大屏项目中最迷人的地方。说动画是大屏项目的灵魂也不为过。 大屏的自动布局和宽高自适应可视化大屏的布局部分也是一个重要的部分。在我们的项目中，准备使用纯css3的vw、vh实现自适应。 视口在CSS标准文档中，视口viewport被称为初始包含块。这个初始包含块是所有CSS百分比宽度推算的根源，它给CSS布局限制了一个最大宽度。 桌面端：视口的宽度和浏览器窗口的宽度一致 移动端 ：视口分为布局视口(layout viewport)、视觉视口(visual viewport)和理想视口(ideal viewport) 可视化大屏属于桌面 视口单位根据CSS3规范，视口单位主要包括4个： vw : 1vw 等于视口宽度的1% vh : 1vh 等于视口高度的1% vmin : 选取 vw 和 vh 中最小的那个 vmax : 选取 vw 和 vh 中最大的那个视口单位区别于%单位，视口单位是依赖于视口的尺寸，根据视口尺寸的百分比来定义的；而%单位则是依赖于元素的祖先元素。用视口单位度量，视口宽度为100vw，高度为100vh，相当于将宽高分别分成了100份。利用视口单位适配页面 vw、vh是基于视口的布局方案 rem布局-解决字体适配（rem布局原理：根据CSS的媒体查询功能，更改html根字体大小，实现字体大小随屏幕尺寸变化。） 使用vw+vh+rem的布局之外，可以再加上elementUI的栅格布局，可以满足需求。 协作 选择一种尺寸作为设计和开发基准 定义一套适配规则，自动适配剩下的两种尺寸(其实不仅这两种，你懂的) 特殊适配效果给出设计效果 参考资源终端设备参数)","tags":[]},{"title":"webpack 前端工程化","date":"2018-12-12T13:37:03.000Z","path":"2018/12/12/webpack 前端工程化/","text":"tags: [组件]categories: 前端工程化 一、webpack 常用 Loader1、加载文件 raw-loader：把文本文件的内容加载到代码中去，在 3-20加载SVG 中有介绍。 file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件，在 3-19加载图片、3-20加载 SVG、4-9 CDN 加速 中有介绍。 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去，在 3-19加载图片、3-20加载 SVG 中有介绍。 source-map-loader：加载额外的 Source Map 文件，以方便断点调试，在 3-21加载 Source Map 中有介绍。 svg-inline-loader：把压缩后的 SVG 内容注入到代码中，在 3-20加载 SVG 中有介绍。 node-loader：加载 Node.js 原生模块 .node 文件。 image-loader：加载并且压缩图片文件。 json-loader：加载 JSON 文件。 yaml-loader：加载 YAML 文件。 2、编译模版 pug-loader：把 Pug 模版转换成 JavaScript 函数返回。 handlebars-loader：把 Handlebars 模版编译成函数返回。 ejs-loader：把 EJS 模版编译成函数返回。 haml-loader：把 HAML 代码转换成 HTML。 markdown-loader：把 Markdown 文件转换成 HTML。 3、转换脚本语言 babel-loader：把 ES6 转换成 ES5，在3-1使用 ES6 语言中有介绍。 ts-loader：把 TypeScript 转换成 JavaScript，在3-2使用 TypeScript 语言中有遇到。 awesome-typescript-loader：把 TypeScript 转换成 JavaScript，性能要比 ts-loader 好。 coffee-loader：把 CoffeeScript 转换成 JavaScript。 4、转换样式文件 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性。 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。 sass-loader：把 SCSS/SASS 代码转换成 CSS，在3-4使用 SCSS 语言中有介绍。 postcss-loader：扩展 CSS 语法，使用下一代 CSS，在3-5使用 PostCSS中有介绍。 less-loader：把 Less 代码转换成 CSS 代码。 stylus-loader：把 Stylus 代码转换成 CSS 代码。 5、检查代码 eslint-loader：通过 ESLint 检查 JavaScript 代码，在 3-16检查代码中有介绍。 tslint-loader：通过 TSLint 检查 TypeScript 代码。 mocha-loader：加载 Mocha 测试用例代码。 coverjs-loader：计算测试覆盖率。 6、其它 vue-loader：加载 Vue.js 单文件组件，在3-7使用 Vue 框架中有介绍。 i18n-loader：加载多语言版本，支持国际化。 ignore-loader：忽略掉部分文件，在3-11构建同构应用中有介绍。 ui-component-loader：按需加载 UI 组件库，例如在使用 antd UI 组件库时，不会因为只用到了 Button 组件而打包进所有的组件。 二、webpack 常用 Plugin1、修改行为define-pluginhttps://webpack.js.org/plugins/define-plugin/定义环境变量 context-replacement-pluginhttps://webpack.js.org/plugins/context-replacement-plugin/修改 require 语句在寻找文件时的默认行为 ignore-pluginhttps://webpack.js.org/plugins/ignore-plugin/用于忽略部分文件 2、优化commons-chunk-plugin(V4.0移除，SplitChunksPlugin取代)https://webpack.js.org/plugins/commons-chunk-plugin/提取公共代码,避免webpack生成重复引入的模块代码，引入模块代码只生成一遍。注意该插件和DLL的功能不一样 提取公共代码对于多页面应用而言，提取公共代码： 减少网络传输流量，降低服务器成本 虽然用户第一次打开网站的速度得不到优化，但之后访问其他页面的速度将大大提高 extract-text-webpack-plugin(V4.0移除，mini-css-extract-plugin取代)https://github.com/webpack-contrib/extract-text-webpack-plugin提取 JS 中的 CSS 代码到单独的文件中 prepack-webpack-pluginhttps://github.com/gajus/prepack-webpack-plugin通过 Facebook 的 Prepack 优化输出的 JS 代码的性能：编译代码时提前将计算结果放到编译后的代码中，而不是在代码运行时才去求值 通过 Babel 将 JS 源码解析成 AST，以更细粒度分析源码 实现了一个 JS 解释器，用于执行源码。借助这个解释器，prepack 才能理解源码具体是如何执行的，并将执行过程中的结果返回到输出中 不能识别 DOM API 和 部分 Node.js API 代码在优化后性能可能更差 代码在优化后，文件的尺寸可能大大增加 现在用于线上环境还为时过早uglifyjs-webpack-pluginhttps://github.com/webpack-contrib/uglifyjs-webpack-plugin通过 UglifyJS 压缩 ES6 代码；V4.0 实例不放到 Plugin 中了，放到 optimization.minimizer 中去了参数： sourceMap: 默认不生成 beautify：是否输出可读性较强的代码，即保留空格和制表符。默认true comments: 是否保留代码中的注释。默认 true compress.warning: 是否在 uglifyJS 删除没用的代码时输出警告信息。默认 true drop_console: 是否删除代码中的所有 console 语句。默认 false collapse_vars: 是否内嵌已定义但是只用到一次的变量。默认true。 reduce_vars: 是否提取出现了多次但是没有定义成变量去引用的静态值 webpack-parallel-uglify-pluginhttps://github.com/gdborton/webpack-parallel-uglify-plugin多线程执行 UglifyJS 代码压缩，提升构建的速度，在生产环境使用使用时即不实用 UglifyJS ，直接用 ParalleUglifyPlugin，但是变成了并行执行 参数： test: 用正则匹配哪些文件需要被压缩，默认为/.js\\$/ include: 用正则命中需要被压缩的文件，默认为[] exclude: 用正则命中不需要被压缩的文件，默认为[] cacheDir: 用于配置缓存存放的目录路径，缓存压缩后的结果，下次遇到一样的输入时直接从缓存中获取压缩后的结果并返回。默认不缓存 workerCount: 开启几个子进程去并发执行压缩。默认为当前运行的 CPU 核数 -1 sourceMap: 会导致压缩过程变慢 uglifyJS: 传递给 uglifyJS 的参数 uglifyES: 传递给 uglifyES 的参数 12345678910111213141516171819202122232425262728const path = require('path')const DefinePlugin = require('webpack/lib/DefinePlugin')const ParalleUglifyPlugin = require('webpack-parallel-uglify-plugin')module.exports = &#123; plugins: [ // 使用 ParalleUglifyPlugin 并行压缩输出的 JS 代码 new ParalleUglifyPlugin(&#123; // 传递给 UglifyJS 的参数 uglifyJS: &#123; output: &#123; // 最紧凑的输出 beautify: false, // 删除所有注释 comments: false, &#125;, compress: &#123; // 在UglifyJS 删除没有用到的代码时不输出警告 warnings: false, // 删除所有的console语句，可以兼容IE浏览器 drop_console: true, &#125; &#125; &#125;) ]&#125; imagemin-webpack-pluginhttps://www.npmjs.com/package/imagemin-webpack-plugin压缩图片文件 webpack-spritesmithhttps://www.npmjs.com/package/webpack-spritesmith制作雪碧图 ModuleConcatenationPluginhttps://webpack.js.org/plugins/module-concatenation-plugin/开启 WebpackScopeHoisting 功能 dll-pluginhttps://webpack.js.org/plugins/dll-plugin/借助 DLL 的思想大幅度提升构建速度DLL：动态链接库，在一个动态链接库中可以包含为其他模块调用的函数和数据 将网页依赖的基础模块抽离出来，打包到一个个单独的动态链接库中。在一个动态链接库中可以包含多个模块 当需要导入的模块存在于某个动态链接库中时，这个模块不能被再次打包，而是去动态链接库中获取 页面依赖的所有动态链接库都需要被加载包含大量复用模块的动态链接库只需被编译一次，在之后的构建过程中被动态链接库包含的模块将不会重新编译，而是直接使用动态链接库中的代码。只要不升级这些模块的版本，动态链接库就不用重新编译 .dll： 包含了大量模块的代码，这些模块被存放在一个数组里，用数组的索引号作为ID，并且通过 _dll_react 变量将自己暴露在全局中，即可以通过 window._dll_react 访问到其中包含的模块 manifest.json: 用于描述在动态链接库文件中包含哪些模块，以及每个模块的路径和 IDDllReferencePlugin 用于在主要的配置文件中引入 DllPlugin 插件打包好的动态链接库文件1234567891011module.exports = &#123; plugins: [ // 这里的路径要和 webpack.dll.config.js 里面的对应。 new webpack.DllReferencePlugin(&#123; // 需要和webpack.dll.config.js中配置的context保持一致，用来指导webpack匹配manifest中库的路径 context: __dirname, // 用来引入webpack.dll.config.js中输出的manifest文件 manifest: path.resolve(__dirname, './dist/dll/vendors-manifest.json') &#125;), ]&#125; DllPlugin 用于打包出一个个单独的动态链接库文件123456789101112module.exports = &#123; plugins: [ new webpack.DllPlugin(&#123; // manifest文件的输出路径,[name]的部分由entry的名字替换 path: path.join(__dirname, 'dist/dll/[name]-manifest.json'), // 这里必须匹配上面的output.library中的值,dll暴露的对象名 name: library, // 解析包路径的上下文，这个要跟配置的dll user一致 context: __dirname &#125;), ]&#125; hot-module-replacement-pluginhttps://webpack.js.org/plugins/hot-module-replacement-plugin/开启模块热替换功能 其他插件serviceworker-webpack-pluginhttps://github.com/oliviertassinari/serviceworker-webpack-plugin为网页应用增加离线缓存功能 stylelint-webpack-pluginhttps://github.com/JaKXz/stylelint-webpack-plugin将stylelint集成到项目中 i18n-webpack-pluginhttps://github.com/webpack-contrib/i18n-webpack-plugin使网页支持国际化 provide-pluginhttps://webpack.js.org/plugins/provide-plugin/从环境中提供的全局变量中加载模块，而不用导入对应的文件 web-webpack-pluginhttps://github.com/gwuhaolin/web-webpack-plugin可方便地为单页应用输出HTML，比 html-webpack-plugin 好用 三、优化缩小文件搜索范围Loader 配置 test use include exclude cacheDirectory: babel 支持缓存转换出的结果12345678910module.exports = &#123; //... rules: [ &#123; test: /\\.(jsx|js)$/, use: 'babel-loader?cacheDirectory', exclude: path.resolve(__dirname, 'node_modules') &#125;, ]&#125; resolve.modules 配置配置Webpack去哪些目录下找第三方模块,默认是[‘node_modules’], 通过配置绝对路径减少搜索步骤 12345module.exports = &#123; resolve: &#123; modules: [path.resolve(__dirname, 'node_modules')] &#125;&#125; resolve.mainFields 配置用于配置第三方模块使用哪个入口文件；可用于不同的运行环境下使用不同的代码，例如在浏览器中通过原生的fetch 或者 XMLHttpRequest 实现，在 Node.js 中通过 http 模块实现 resolve.mainFields 的默认值和当前的 target 配置有关系 当 target 为 web 或者 webworker 时，值是[“browser”, “module”, “main”] 当 target 为其他情况时，值是 [“module”, “main”] 由于大多数第三方模块都采用 main 字段去描述入口文件的位置，所以可以通过配置 mainFields 字段为 main 值，减少搜索步骤，但是注意只要有一个模块出错，都可能会造成构建出的代码无法正常运行12345module.exports = &#123; resolve: &#123; mainFields: ['main'], &#125;&#125; resolve.alias 配置 通过配置alias 使得不同环境引用不同的代码，如react-native-web 的使用 由于webpack 默认会从第三方模块中的 package.json 中的指定入口文件递归解析和处理依赖文件，一般情况下该入口文件会定义成包含检查和警告的未被压缩的代码，但是直接使用单独、完整的min.js文件可以跳过耗时的递归解析操作1234567module.exports = &#123; resolve: &#123; alias: &#123; 'react': path.resolve(__dirname, './node_modules/react/dist/react.min.js') &#125;, &#125;&#125; resolve.extensions 配置 后缀尝试列表要尽可能小，不要将项目中不可能存在的情况写到后缀尝试列表中 频率出现最高的文件后缀要优先放在最前面，以做到尽快退出寻找过程 在源码中写导入语句时，要尽可能带上后缀，从而可以避免寻找过程 12345module.exports = &#123; resolve: &#123; extensions: ['js'], &#125;&#125; module.noParse 配置让 webpack 忽略对部分没采用模块化的文件的递归处理，如jQuery| react.min.js注意被忽略掉的文件里不应该包含 import | require | define 等模块化的语句，不然会导致在构建出的代码包含无法在浏览器环境下执行的模块化语句123456const path = require('path)module.exports = &#123; module: &#123; noParse: [/react\\.min\\.js$/], &#125;&#125; HappyPack将任务分解给多个子进程去并发执行，子进程处理完后再将结果发送给主进程。由于 JS 是单线程模型，所以要发挥多核 CPU 的功能，就只能通过多进程实现，而无法通过多线程实现。 接入 webpack 在 Loader 配置中，对所有文件的处理都交给 happypack/loader, 使用紧跟其后的 querystring ?id=babel 去告诉 happypack/loader 选择哪个 HappyPack 实例处理文件 在 Plugin 中新增了 HappyPack 实例，用于告诉 happypack/loader 如何处理 .js 和 .css 文件。选项中的 id 属性的值和上面 querystring 中的 ?id=babel 对应 id: loaders: 和原本Loader 配置中的一样 threads: 代表开启几个子进程去处理这一类型的文件，默认是 3 个，必须是整数 verbose: 是否允许 HappyPack 输出日志，默认是 true threadPool: 代表共享进程池，即多个 HappyPack 实例都使用同一个共享进程池中的子进程去处理任务，以防止资源占用过多。1npm i -D happypack 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const path = require('path');const HappyPack = require('happypack');module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.(jsx|js)$/, use: ['happypack/loader?id=babel'], // 将对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例 exclude: path.resolve(__dirname, 'node_modules') &#125;, &#123; test: /\\.(css|less)$/, use: ['happypack/loader?id=css'], exclude: path.resolve(__dirname, 'node_modules') &#125;, &#123; test: /\\.(png|svg|jpg|gif|webp|ico)$/, use: ['happypack/loader?id=file'], exclude: path.resolve(__dirname, 'node_modules') &#125;, &#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, use: ['happypack/loader?id=url'], include: path.resolve(__dirname, 'assets/fonts') &#125; ], plugins: [ new HappyPack(&#123; id: 'babel', loaders: ['babel-loader?cacheDirectory'], threadPool: happyThreadPool, &#125;), new HappyPack(&#123; id: 'css', loaders: ['style-loader', 'css-loader', 'less-loader'], threadPool: happyThreadPool, &#125;), new HappyPack(&#123; id: 'file', loaders: ['file-loader'], threadPool: happyThreadPool, &#125;), new HappyPack(&#123; id: 'url', loaders: ['url-loader'], threadPool: happyThreadPool, // 使用共享进程池中的子进程去处理任务 &#125;), ] &#125;&#125;; 优化文件监听1webpack --watch webpack-dev-server 默认开启文件监听在开启监听模式时，默认会监听配置的 Entry 文件和所有 Entry 递归依赖的文件，包括 node_modules 下的第三方模块。 12345module.exports = &#123; watchOptions: &#123; ignored: /node_modules/, &#125;&#125; 采用这种方法优化后，消耗的内存和 CPU 将会大大减少 watchOptions.aggregateTimeout 越大性能越好，能降低重新构建的频率 watchOptions.poll 越小越好，降低检查的频率同时注意这两个优化会导致监听模式反应和灵敏度降低 优化自动刷新自动刷新： 借助浏览器扩展去通过浏览器提供的接口刷新，如 WebStorm IDE 的 LiveEdit 功能 向要开发的网页中注入代理客户端代码，通过代理客户端去刷新整个页面 将要开发的网页装进一个 iframe 中，通过 刷新 iframe 去看到最新效果 devServer.inline : 用来控制是否向 Chunk 中注入代理客户端，默认注入。优化即关闭，从而只注入一个代理客户端，而非粗暴地为每个 chunk 都注入。 入口网址会变成 http://localhost:8080/webpack-dev-server bundle.js 中不再包含代理客户端的代码 模块热替换devServer 默认不开启 1webpack-dev-server --hot 热替换性能问题和自动刷新一样主要是因为需要监听文件的变化和注入客户端：忽略 node_modules Update module 优化1234567const NamedModulesPlugin = require('webpack/lib/NamedModulesPlugin')module.exports = &#123; plugins: [ // 显示出被替换模块的名称 new NamedModulesPlugin(), ]&#125; 压缩 CSScss-loader 内置了 cssnano，只需开启 css-loader 的 minimize 选项1use: ['css-loader?minimize'] CDN 加速内容分发网络：通过将资源部署到世界各地，使用户在访问时按照仅仅原则从离其最近的服务器获取资源，来加快资源的获取速度。通过优化物理链路层传输过程中的光速有限、丢包等问题来提升网速。 针对 HTML 文件：不开启缓存，将 HTML 放到自己的服务器上，而不是 CDN 服务器上，同时关闭自己服务器上的缓存。自己的服务器只提供 HTML 文件和数据接口 针对静态的 JS 、CSS、图片等文件：开启 CDN 和缓存，上传到 CDN 服务上，同时为每个文件名带上由文件内容算出的 Hash 值。 更改 HTML 中引入静态文件的资源引入地址为CDN 服务的 URL 地址 “//cdn.com/id/app_a6976b6d.css” 这样的 URL 省略了 http：或者 http：前缀，这样做在访问这些资源时会自动根据当前 HTML 的 URL 采用了什么模式去决定是采用 HTTP 还是 HTTPS 模式 浏览器规则：在同一时刻针对同一个域名资源的并行请求有限制(大概4个左右)，则会导致资源的加载被阻塞。可以将这些静态资源分散到不同的 CDN 服务上 用多个域名后会带来一个新问题：增加域名解析时间，对于是否采用多域名分散资源，需要根据自己的需求去衡量得失 webpack 实现 CDN 的接入 静态资源导入 URL 需要变成指向 CDN 服务的绝对路径的 URL，而不是相对于 HTML 文件的 URL 静态资源的文件名需要带上由文件内容算出来的 Hash 值，以防止被缓存 将不同类型的资源放到不同域名的 CDN 服务上，以防止资源的并行加载被阻塞 在 output.publicPath 中设置 JS 的地址 在 css-loader.publicPath 中设置被 CSS 导入的资源的地址 在 WebPlugin.stylePublicPath 中设置 CSS 文件的地址12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const path = require(&apos;path&apos;);const HappyPack = require(&apos;happypack&apos;);const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);module.exports = &#123; // ... output: &#123; filename: &apos;[name]_[chunkhash:8].js&apos;, // 为输出的 JS 加上 Hash 值 path: path.resolve(__dirname, &apos;./dist&apos;), publicPath: &apos;//js.cdn.com/id/&apos;, // 指定存放 JS 文件的 CDN 目录 URL &#125;, module: &#123; rules: [ &#123; test: /\\.(jsx|js)$/, use: [&apos;happypack/loader?id=babel&apos;], // 将对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例 exclude: path.resolve(__dirname, &apos;node_modules&apos;) &#125;, &#123; test: /\\.(css|less)$/, use: [&apos;happypack/loader?id=css&apos;], exclude: path.resolve(__dirname, &apos;node_modules&apos;) &#125;, &#123; test: /\\.(png|svg|jpg|gif|webp|ico)$/, use: [&apos;happypack/loader?id=file&apos;], exclude: path.resolve(__dirname, &apos;node_modules&apos;) &#125;, &#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, use: [&apos;happypack/loader?id=url&apos;], include: path.resolve(__dirname, &apos;assets/fonts&apos;) &#125; ], plugins: [ new HappyPack(&#123; id: &apos;babel&apos;, loaders: [&apos;babel-loader?cacheDirectory&apos;] &#125;), new HappyPack(&#123; id: &apos;css&apos;, loaders: [&apos;style-loader&apos;, &apos;css-loader?minimizer&apos;, &apos;less-loader&apos;] &#125;), new HappyPack(&#123; id: &apos;file&apos;, loaders: [&apos;file-loader?name=[name]_[hash:8].[ext]&apos;] // 为输出的图片名加上 Hash 值 &#125;), new HappyPack(&#123; id: &apos;url&apos;, loaders: [&apos;url-loader&apos;] &#125;), new ExtractTextPlugin(&#123; filename: &apos;[name]_[contenthash:8].css&apos;, // 为输出的 CSS 文件名加上 Hash 值 publicPath: &apos;//img.cdn.com/id/&apos;, // 指定存放 CSS 中导入的资源(例如图片)的 CDN 目录 URL &#125;) ] &#125;&#125;; Tree Shaking 剔除 JS 中用不上的死代码，依赖静态的 ES6 模块化语法，如果采用了 ES5 则 webpack 无法分析出可以剔除哪些代码 接入 Tree Shaking 需要配置 Babel 以让其保留 ES6 模块化语句.babelrc12345&#123; \"presets\": [\"env\", &#123; \"modules\": false // 关闭 Babel 的模块转换功能，保留原本的ES6模块化语法 &#125;],&#125; 大部分 NPM 库都会提供两份代码，一份用 CommonJS 模块化语法，一份用 ES6 模块化语法，并在 package.json 中分别指出这两份代码的入口：1234&#123; \"main\": \"lib/index.js\", // 指明采用 CommonJS 模块化的代码入口 \"jsnext:main\": \"es/index.js\" // 指明采用 ES6 模块化的代码入口,社区约定&#125; 配置 webpack 的文件寻找规则123456module.exports = &#123; resolve: &#123; // 针对 NPM 中的第三方模块优先采用 jsnext:main 中指向的 ES6 模块化语法的文件 mainFields: [&apos;jsnext:main&apos;, &apos;browser&apos;, &apos;main&apos;] &#125;&#125; Scope Hoisting 分析模块之间的依赖关系，尽可能将被打散的模块合并到一个函数中，但前提是不能造成代码冗余。因此只有那些被引用了一次的模块才能被合并 代码体积更小，因为函数申明语句会产生大量的代码 代码在运行时因为创建的函数作用域变少了，所以内存开销也变小了 对于非 ES6 模块化语法的代码，会自动降级处理，可以在启动时加上 –display-optimization-bailout 在控制台输出降级日志 123456789const ModuleConcatnationPlugin = require('webpack/lib/optimize/ModuleConcatnationPlugin');module.exports = &#123; resolve: &#123; mainFields: ['jsnext:main', 'browser', 'main'] // Scope Hoisting 依赖 ES6 模块化语法 plugins: [ new ModuleConcatnationPlugin(), // 开启 Scope Hoisting ]&#125; 分割代码以按需加载按需加载：用户当前需要用什么功能就只加载这个功能对应的代码，而不是加载所有功能对应的代码 为 SPA 做按需优化时： 将整个网站划分成一个个小功能，再按照每个功能的相关程度分成几类 将每类合并为一个 Chunk，按需加载对应的 Chunk 不要按需加载首页所对应的功能，将其放到执行入口所在的 Chunk 中，以减少用户能感知的网页加载时间 对于不依赖大量代码的功能点，例如依赖 Chart.js 去画图表、依赖 flv.js 去播放视频的功能点，可再对其进行按需加载 被分割出去的代码的加载需要一定的时机去触发，即当用户操作到了或者即将操作到对应功能时再去加载对应的代码。被分割出去的代码的加载时机需要开发者根据网页的需求去衡量和确定 分割代码按需加载ReactRouter的案例 .babelrc 123456789&#123; \"presets\": [ \"env\", \"react\" ], \"plugins\": [ \"syntax-dynamic-import\" ]&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// main.jsimport React, &#123;PureComponent, createElement&#125; from 'react';import &#123;render&#125; from 'react-dom';import &#123;HashRouter, Route, Link&#125; from 'react-router-dom';import PageHome from './pages/home';/** * 异步加载组件 * @param load 组件加载函数，load 函数会返回一个 Promise，在文件加载完成时 resolve * @returns &#123;AsyncComponent&#125; 返回一个高阶组件用于封装需要异步加载的组件 */function getAsyncComponent(load) &#123; return class AsyncComponent extends PureComponent &#123; componentDidMount() &#123; // 在高阶组件 DidMount 时才去执行网络加载步骤 load().then((&#123;default: component&#125;) =&gt; &#123; // 代码加载成功，获取到了代码导出的值，调用 setState 通知高阶组件重新渲染子组件 this.setState(&#123; component, &#125;) &#125;); &#125; render() &#123; const &#123;component&#125; = this.state || &#123;&#125;; // component 是 React.Component 类型，需要通过 React.createElement 生产一个组件实例 return component ? createElement(component) : null; &#125; &#125;&#125;// 根组件function App() &#123; return ( &lt;HashRouter&gt; &lt;div&gt; &lt;nav&gt; &lt;Link to='/'&gt;Home&lt;/Link&gt; | &lt;Link to='/about'&gt;About&lt;/Link&gt; | &lt;Link to='/login'&gt;Login&lt;/Link&gt; &lt;/nav&gt; &lt;hr/&gt; &lt;Route exact path='/' component=&#123;PageHome&#125;/&gt; &lt;Route path='/about' component=&#123;getAsyncComponent( // 异步加载函数，异步地加载 PageAbout 组件 () =&gt; import(/* webpackChunkName: 'page-about' */'./pages/about') )&#125; /&gt; &lt;Route path='/login' component=&#123;getAsyncComponent( // 异步加载函数，异步地加载 PageAbout 组件 () =&gt; import(/* webpackChunkName: 'page-login' */'./pages/login') )&#125; /&gt; &lt;/div&gt; &lt;/HashRouter&gt; )&#125;// 渲染根组件render(&lt;App/&gt;, window.document.getElementById('app')); 123456// pages/home/index.jsimport React from 'react';export default function PageHome() &#123; return &lt;div&gt;Page Home&lt;/div&gt;&#125; 123456// pages/about/index.jsimport React from 'react';export default function PageAbout() &#123; return &lt;div&gt;Page About&lt;/div&gt;&#125; 123456// pages/login/index.jsimport React from 'react';export default function PageLogin() &#123; return &lt;div&gt;Page Login&lt;/div&gt;&#125; 可视化分析工具1webpack --profile --json webpack analyse(官方) Modules: 展示所有模块，每个模块对应一个文件，且包含所有模块之间的依赖关系图、模块路径、模块ID、模块所属的 Chunk、模块的大小 Chunks: 展示所有代码块，在一个代码块中包含多个模块，并且包含代码块的 ID、名称、大小，每个代码块包含的模块数量，以及代码块之间的依赖关系图 Assets: 展示所有输出的文件资源，包括JS、CSS、图片等，并且包括文件名称、大小及该文件来自哪个代码块 Warning: 展示构建过程中出现的所有警告信息 Errors: 展示构建过程中出现的所有错误信息 Hints：展示处理每个模块所耗费的时间webpack-bundle-analyzer 没有官方的那么多功能，但更直观 打包出的文件中都包含什么 每个文件的尺寸在总体中的占比，一眼看出哪些文件的尺寸大 模块之间的包含关系 每个文件的 Gzip 后的大小 推荐配置最优构建速度123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293const path = require('path');const CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');const &#123;AutoWebPlugin&#125; = require('web-webpack-plugin');const HappyPack = require('happypack');// 自动寻找 pages 目录下的所有目录，把每一个目录看成一个单页应用const autoWebPlugin = new AutoWebPlugin('./src/pages', &#123; // HTML 模版文件所在的文件路径 template: './template.html', // 提取出所有页面公共的代码 commonsChunk: &#123; // 提取出公共代码 Chunk 的名称 name: 'common', &#125;,&#125;);module.exports = &#123; // AutoWebPlugin 会找为寻找到的所有单页应用，生成对应的入口配置， // autoWebPlugin.entry 方法可以获取到生成入口配置 entry: autoWebPlugin.entry(&#123; // 这里可以加入你额外需要的 Chunk 入口 base: './src/base.js', &#125;), output: &#123; filename: '[name].js', &#125;, resolve: &#123; // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤 // 其中 __dirname 表示当前工作目录，也就是项目根目录 modules: [path.resolve(__dirname, 'node_modules')], // 只采用 main 字段作为入口文件描述字段，以减少搜索步骤 mainFields: ['jsnext:main', 'main'], &#125;, module: &#123; rules: [ &#123; // 如果项目源码中只有 js 文件就不要写成 /\\.jsx?$/，提升正则表达式性能 test: /\\.js$/, use: ['happypack/loader?id=babel'], // 只对项目根目录下的 src 目录中的文件采用 babel-loader include: path.resolve(__dirname, 'src'), &#125;, &#123; test: /\\.js$/, use: ['happypack/loader?id=ui-component'], include: path.resolve(__dirname, 'src'), &#125;, &#123; // 增加对 CSS 文件的支持 test: /\\.css/, // 提取出 Chunk 中的 CSS 代码到单独的文件中 use: ['happypack/loader?id=css'], &#125;, ] &#125;, plugins: [ autoWebPlugin, // 使用HappyPack new HappyPack(&#123; id: 'babel', // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启 loaders: ['babel-loader?cacheDirectory'], &#125;), new HappyPack(&#123; // UI 组件加载拆分 id: 'ui-component', loaders: [&#123; loader: 'ui-component-loader', options: &#123; lib: 'antd', style: 'style/index.css', camel2: '-' &#125; &#125;], &#125;), new HappyPack(&#123; id: 'css', // 如何处理 .css 文件，用法和 Loader 配置中一样 loaders: ['style-loader', 'css-loader'], &#125;), // 4-11提取公共代码 new CommonsChunkPlugin(&#123; // 从 common 和 base 两个现成的 Chunk 中提取公共的部分 chunks: ['common', 'base'], // 把公共的部分放到 base 中 name: 'base' &#125;), ], watchOptions: &#123; // 4-5使用自动刷新：不监听的 node_modules 目录下的文件 ignored: /node_modules/, &#125;&#125;; 最佳质量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139const path = require('path');const DefinePlugin = require('webpack/lib/DefinePlugin');const ModuleConcatenationPlugin = require('webpack/lib/optimize/ModuleConcatenationPlugin');const CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');const &#123;AutoWebPlugin&#125; = require('web-webpack-plugin');const HappyPack = require('happypack');const ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin');// 自动寻找 pages 目录下的所有目录，把每一个目录看成一个单页应用const autoWebPlugin = new AutoWebPlugin('./src/pages', &#123; // HTML 模版文件所在的文件路径 template: './template.html', // 提取出所有页面公共的代码 commonsChunk: &#123; // 提取出公共代码 Chunk 的名称 name: 'common', &#125;, // 指定存放 CSS 文件的 CDN 目录 URL stylePublicPath: '//css.cdn.com/id/',&#125;);module.exports = &#123; // AutoWebPlugin 会找为寻找到的所有单页应用，生成对应的入口配置， // autoWebPlugin.entry 方法可以获取到生成入口配置 entry: autoWebPlugin.entry(&#123; // 这里可以加入你额外需要的 Chunk 入口 base: './src/base.js', &#125;), output: &#123; // 给输出的文件名称加上 hash 值 filename: '[name]_[chunkhash:8].js', path: path.resolve(__dirname, './dist'), // 指定存放 JavaScript 文件的 CDN 目录 URL publicPath: '//js.cdn.com/id/', &#125;, resolve: &#123; // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤 // 其中 __dirname 表示当前工作目录，也就是项目根目录 modules: [path.resolve(__dirname, 'node_modules')], // 只采用 main 字段作为入口文件描述字段，以减少搜索步骤 mainFields: ['jsnext:main', 'main'], &#125;, module: &#123; rules: [ &#123; // 如果项目源码中只有 js 文件就不要写成 /\\.jsx?$/，提升正则表达式性能 test: /\\.js$/, use: ['happypack/loader?id=babel'], // 只对项目根目录下的 src 目录中的文件采用 babel-loader include: path.resolve(__dirname, 'src'), &#125;, &#123; test: /\\.js$/, use: ['happypack/loader?id=ui-component'], include: path.resolve(__dirname, 'src'), &#125;, &#123; // 增加对 CSS 文件的支持 test: /\\.css/, // 提取出 Chunk 中的 CSS 代码到单独的文件中 use: ExtractTextPlugin.extract(&#123; use: ['happypack/loader?id=css'], // 指定存放 CSS 中导入的资源（例如图片）的 CDN 目录 URL publicPath: '//img.cdn.com/id/' &#125;), &#125;, ] &#125;, plugins: [ autoWebPlugin, // 4-14开启ScopeHoisting new ModuleConcatenationPlugin(), // 4-3使用HappyPack new HappyPack(&#123; // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件 id: 'babel', // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启 loaders: ['babel-loader?cacheDirectory'], &#125;), new HappyPack(&#123; // UI 组件加载拆分 id: 'ui-component', loaders: [&#123; loader: 'ui-component-loader', options: &#123; lib: 'antd', style: 'style/index.css', camel2: '-' &#125; &#125;], &#125;), new HappyPack(&#123; id: 'css', // 如何处理 .css 文件，用法和 Loader 配置中一样 // 通过 minimize 选项压缩 CSS 代码 loaders: ['css-loader?minimize'], &#125;), new ExtractTextPlugin(&#123; // 给输出的 CSS 文件名称加上 hash 值 filename: `[name]_[contenthash:8].css`, &#125;), // 4-11提取公共代码 new CommonsChunkPlugin(&#123; // 从 common 和 base 两个现成的 Chunk 中提取公共的部分 chunks: ['common', 'base'], // 把公共的部分放到 base 中 name: 'base' &#125;), new DefinePlugin(&#123; // 定义 NODE_ENV 环境变量为 production 去除 react 代码中的开发时才需要的部分 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125; &#125;), // 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码 new ParallelUglifyPlugin(&#123; // 传递给 UglifyJS 的参数 uglifyJS: &#123; output: &#123; // 最紧凑的输出 beautify: false, // 删除所有的注释 comments: false, &#125;, compress: &#123; // 在UglifyJs删除没有用到的代码时不输出警告 warnings: false, // 删除所有的 `console` 语句，可以兼容ie浏览器 drop_console: true, // 内嵌定义了但是只用到一次的变量 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125; &#125;, &#125;), ]&#125;; 参考资源《深入浅出 webpack》https://github.com/gwuhaolin/dive-into-webpack","tags":[]},{"title":"关于开源组件","date":"2018-12-12T13:27:18.000Z","path":"2018/12/12/关于开源组件/","text":"实战React业务组件库 · 语雀","tags":[]},{"title":"Function Programming","date":"2018-12-12T12:13:32.000Z","path":"2018/12/12/Function Programming/","text":"解决什么问题人工智能、区块链、AR、VR、新零售等业务场景的出现，产品界面交互正在变得越来越复杂，需要快速、正确、高效地开发出高复杂度页面。 FP 有什么特点JS 语言中的函数不同于 Java ，C/C++ 等语言, 可以被当做参数和返回值进行传递 函数为一等公民 模块化、组合 引用透明 避免状态改变 避免共享状态 案例分别实现数组所有元素相加、相乘、相与？非 FP 风格123456789101112131415161718192021222324function plus(array) &#123; var res = array[0]; for (let i = 1; i &lt; array.length; i++) &#123; res += array[i]; &#125;&#125;function mul(array) &#123; var res = array[0]; for (let i = 1; i &lt; array.length; i++) &#123; res *= array[i]; &#125;&#125;function and (array) &#123; var res = array[0]; for (let i = 1; i &lt; array.length; i++) &#123; res = res &amp; array[i]; &#125;&#125;plus(array);mul(array);and(array); FP 风格12345678910111213var ops = &#123; \"plus\": (x,y)=&gt;x+y, \"mul\" : (x,y)=&gt;x*y, \"and\" : (x,y)=&gt;x&amp;y&#125;function operation(op, array) &#123; return array.slice(1).reduce(ops[op], array[0]);&#125; operation(\"plus\", array);operation(\"mul\", array);operation(\"and\", array); React 的 FPReact 框架中，当用户操作 UI 或者 API 的返回带来了数据的改变，React 随即进行 virtual dom diff 计算得到 dom 的修改指令，对 dom 元素应用修改指令便得到最新的 html 界面，如下图所示： 不难发现，React 其实是应用数据对UI的一种映射，不同的数据会映射出不同样式的 UI 界面，我们可以得出如下的表达式： 没错，React 的本质其实是一种函数，并且还是符合 FP 要求的“引用透明”函数。所谓“引用透明”就是指函数的输出仅依赖函数参数，不受任何外部环境影响。这样的函数可测试性强，也非常容易进行组合。 在 React 的体系下，任何组件都可由一个个更小的组件构成，每个组件都只关心自己的输入，他们不断地接受新的数据并输出对应的新的UI界面。React 框架中常用的“高阶组件”可以看作引用透明”函数的组合模式。 在具体业务中我们通常还需要权衡 React 组件的复用性和开发体验，如果组件被拆分的过于细，固然复用性会提升，但文件数量会增加，对应的文档和沟通成本也会增加，这也是 FP 在实践过程中经常遭人诟病的点，即复用性提升后带来的额外开发成本。","tags":[]},{"title":"不想当架构师的前端不是一名好前端","date":"2018-12-08T12:52:10.000Z","path":"2018/12/08/不想当架构师的前端不是一名好前端/","text":"架构师能力模型团队管理能力在线运维能力 项目管理能力性能优化能力 架构能力编程能力 调试能力 编译部署能力","tags":[]},{"title":"博客搭建","date":"2018-12-08T12:48:16.000Z","path":"2018/12/08/博客搭建/","text":"前言语雀 是一款非常好用的知识管理网站（类似 GitBook)，它的编辑器非常好用，而且支持导出 Markdown，这篇文章是教你如何使用语雀的编辑器写静态博客。这里的静态博客用了 Hexo，Jekyll 也是没有问题的。 创建 Hexo 博客已经有 Hexo 博客的可以跳过。如果你是 Jekyll ，也可以跳过。 安装 Node.js 安装 Hexo 脚手架 1npm install -g hexo-cli 初始化一个博客 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 其他设置和命令见：https://hexo.io/zh-cn/docs/ 安装语雀文章下载插件yuque-hexo 是一个 Node.js 环境下的语雀下载器，使用 npm 安装 安装 yuque-hexo 1npm i -g yuque-hexo 注册语雀，创建知识库，获得你的个人路径和知识库的名字，比如我的博客的知识库是 https://www.yuque.com/page/luan.ma 在 Hexo 博客的目录下面的 package.json 中，进行下面的配置 12345678910&#123; \"name\": \"your hexo project\", //如果原来已经有这个不用再加了，直接加下面的就可以 \"yuqueConfig\": &#123; \"baseUrl\": \"https://www.yuque.com/api/v2\", \"login\": \"page\", \"repo\": \"luan.ma\", \"mdNameFormat\": \"slug\", \"postPath\": \"source/_posts/yuque\" &#125;&#125; 如果不是 Hexo 博客，则需要按照上面的文件保存一个 package.json 到博客目录，并且配置 postPath 为正确的文章目录 同步文章1yuque-hexo sync PS: 插件支持 Front-matter，在语雀写文章的时候直接写在前面，然后插入一条分割线即可，不写也没问题：123tags: [Hexo]categories: 教程date: 2018-10-05 10:43:50 启动/部署 Hexo 博客 本地启动（调试用） 1hexo s 生成 html 不部署 1hexo g 自动上传到服务器/静态空间/git （部署） 先找到一个部署插件 在配置文件中配置好相关的账号密码 在 hexo 中生成 HTML 并且部署1hexo g -d 静态博客空间选择 Github Pages： 方便，不太稳定，Git部署 Coding.net Pages： 需要挂一个链接 或者 付费，速度尚可，Git部署 腾讯云 COS + 腾讯云 CDN：需要备案，速度极快，COS 插件部署 自有服务器：可定制，速度一般 ，支持多种方式部署 后记核心是把 yuque-hexo 这个东西介绍给大家，本博客目前也是使用这个方案同步语雀的文章。 当然，关于 Hexo 皮肤、评论插件等等玩法也要折腾很久，我就不在这篇文章里面说了。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://lulustyle.net/tags/Hexo/"}]}]