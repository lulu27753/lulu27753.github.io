[{"title":"滚动穿透","date":"2019-01-09T03:50:07.000Z","path":"2019/01/09/滚动穿透/","text":"页面滑出了一个弹窗，我们用手指触摸屏幕滑动时，会发现弹窗下面的内容还是在滚动。 方案一：找到的第一个方法就是当弹窗触发的时候，给 overflow: scroll: 的元素加上一个 class (一般都是 body 元素)。退出的时候去掉这个 class。下面为了方便，会直接用 body 元素来代指弹窗下方的元素。12345678// css 部分modal_open &#123; position: fixed; height: 100%;&#125;// js 部分document.body.classList.add('modal_open');document.body.classList.remove('modal_open'); 上面的这个方法可以解决滚动穿透问题，却也会带来新的问题。即: body 的滚动位置会丢失，也就是body 的 scrollTop 属性值会变为 0。 这个新问题比起滚动穿透本身来说更加麻烦，所以这个方案是要进行优化的。 方案二：既然添加 modal_open 这个 class 会使 body 的滚动位置会丢失，那么我们为什么不在滚动位置丢失之前先保存下来，等到退出弹窗的前在將这个保存下来的滚动位置在设置回去。然后就朝着这个方向开始 coding 。1234.modal_open &#123; position: fixed; height: 100%;&#125; 12345678910111213141516171819202122232425262728293031/** * ModalHelper helpers resolve the modal scrolling issue on mobile devices * https://github.com/twbs/bootstrap/issues/15852 */var ModalHelper = (function(bodyClass) &#123; var scrollTop; return &#123; afterOpen: function() &#123; scrollTop = document.scrollingElement.scrollTop || document.documentElement.scrollTop || document.body.scrollTop; document.body.classList.add(bodyClass); document.body.style.top = -scrollTop + 'px'; &#125;, beforeClose: function() &#123; document.body.classList.remove(bodyClass); document.scrollingElement.scrollTop = document.documentElement.scrollTop = document.body.scrollTop = scrollTop; &#125; &#125;;&#125;)('modal_open');// methodmodalSwitch: function()&#123; let self = this; if( self.switchFlag === 'close' )&#123; ModalHelper.afterOpen(); self.switchFlag = 'open'; &#125;else&#123; ModalHelper.beforeClose(); self.switchFlag = 'close'; &#125;&#125; 方案二可以达到以下效果： 弹窗滚动的时候，下方的 body 是固定的无法滚动； body 的滚动位置不会丢失； body 有 scroll 事件； 方案二可以适应绝大多数的弹窗需求，提测后测试方也没有在提其他问题，这个问题算是完美的解决了。不过我在这个过程有一个疑问： IOS 自有的橡皮筋效果会导致页面会出现短暂卡顿现象，暂时没有找到原因，请教各位。 其他方案：使用 preventDefault 阻止浏览器默认事件：1234var modal = document.getElementById('modalBox');modal.addEventListener('touchmove', function(e) &#123; e.preventDefault();&#125;, false); 这个方案只适用于这个弹窗本身的高度小于屏幕的高度，即不可滚动的时候。touchmove 比 touchstart 更加合适。因为 touchstart 会连点击事件都阻止。使用插件：对于插件我的态度是，除非是自己实现起来太复杂，否则还是自己花点时间去实现。原因有二： 使用插件就意味着需要引入的文件至少多了一个。 插件过多，担心日后项目升级维护成本加大。 参考 developer.mozilla.org/en-US/docs/… uedsky.com/2016-06/mob…","tags":[]},{"title":"webpack 配置比对","date":"2019-01-07T04:13:09.000Z","path":"2019/01/07/webpack 配置比对/","text":"externals","tags":[]},{"title":"存储","date":"2019-01-06T12:28:39.000Z","path":"2019/01/06/存储/","text":"Cookie 存储的数据量非常小，只有 4K 的大小 数据会自动携带到请求头里 但服务器端可能并不关心这些数据，所以会造成带宽的浪费sessionStorage 存储的数据仅在本次会话有用，会话结束后会自动失效，而且数据仅在当前窗口有效，同一源下新窗口也访问不到localStorage 绝大多数浏览器有 5M 的大小限制 可以永久存储，而且同源下数据多窗口也能共享 在 setItem 时，可能会达到大小限制，最好加上错误捕捉 使用 Loader 加载静态文件（basket.js) 查看请求的文件 url 是否有缓存到 localStorage 过期或不匹配，到第 2 大步 文件内容有效，到第 4 大步 如果没有，到第 2 大步 如果有，判断文件是否过期或版本号是否匹配 请求远程文件 缓存最新文件内容 执行文件内容 借助服务器端将静态文件 inline 化 这个方式比上面那种更进一步，在第一次响应时把需要放入 localStorage 的文件都内联进 html 中，后面每次响应只要文件版本没有变化，都是渲染一段从 localStorage 加载该文件的代码。这样做的好处是可以有效减少请求次数，即使是第一次 使用 localStorage 缓存文件会有 XSS 的风险 其他应用场景 redux-localstorage可以快速执行localstorage: 1npm install --save redux-localstorage@rc","tags":[]},{"title":"JS 类型转换的应用","date":"2019-01-06T10:13:57.000Z","path":"2019/01/06/JS 类型转换的应用/","text":"实现一个函数，运算结果可以满足如下预期结果： add(1)(2) // 3add(1, 2, 3)(10) // 16add(1)(2)(3)(4)(5) // 15 对于一个好奇的切图仔来说，忍不住动手尝试了一下，看到题目首先想到的是会用到高阶函数以及 Array.prototype.reduce()。高阶函数(Higher-order function)：高阶函数的意思是它接收另一个函数作为参数。在 javascript 中，函数是一等公民，允许函数作为参数或者返回值传递。得到了下面这个解法： function add() { var args = Array.prototype.slice.call(arguments); return function() { var arg2 = Array.prototype.slice.call(arguments); return args.concat(arg2).reduce(function(a, b){ return a + b; }); } } 验证了一下，发现错了： add(1)(2) // 3add(1, 2)(3) // 6add(1)(2)(3) // Uncaught TypeError: add(…)(…) is not a function(…) 上面的解法，只有在 add()() 情形下是正确的。而当链式操作的参数多于两个或者少于两个的时候，无法返回结果。而这个也是这题的一个难点所在，add()的时候，如何既返回一个值又返回一个函数以供后续继续调用？后来经过高人指点，通过重写函数的 valueOf 方法或者 toString 方法，可以得到其中一种解法： function add () { var args = Array.prototype.slice.call(arguments); var fn = function () { var arg_fn = Array.prototype.slice.call(arguments); return add.apply(null, args.concat(arg_fn)); } fn.valueOf = function () { return args.reduce(function(a, b) { return a + b; }) } return fn; } 嗯？第一眼看到这个解法的时候，我是懵逼的。因为我感觉 fn.valueOf() 从头到尾都没有被调用过，但是验证了下结果： add(1) // 1add(1,2)(3) //6add(1)(2)(3)(4)(5) // 15 神奇的对了！那么玄机必然是在上面的 fn.valueOf = function() {} 内了。为何会是这样呢？这个方法是在函数的什么时刻执行的？且听我一步一步道来。 valueOf 和 toString先来简单了解下这两个方法：Object.prototype.valueOf()用 MDN 的话来说，valueOf() 方法返回指定对象的原始值。JavaScript 调用 valueOf() 方法用来把对象转换成原始类型的值（数值、字符串和布尔值）。但是我们很少需要自己调用此函数，valueOf 方法一般都会被 JavaScript 自动调用。记住上面这句话，下面我们会细说所谓的自动调用是什么意思。Object.prototype.toString()toString() 方法返回一个表示该对象的字符串。每个对象都有一个 toString() 方法，当对象被表示为文本值时或者当以期望字符串的方式引用对象时，该方法被自动调用。这里先记住，valueOf() 和 toString() 在特定的场合下会自行调用。 原始类型好，铺垫一下，先了解下 javascript 的几种原始类型，除去 Object 和 Symbol，有如下几种原始类型： Number String Boolean Undefined Null 在 JavaScript 进行对比或者各种运算的时候会把对象转换成这些类型，从而进行后续的操作，下面逐一说明： String 类型转换在某个操作或者运算需要字符串而该对象又不是字符串的时候，会触发该对象的 String 转换，会将非字符串的类型尝试自动转为 String 类型。系统内部会自动调用 toString 函数。举个例子： var obj = {name: ‘Coco’};var str = ‘123’ + obj;console.log(str); // 123[object Object] 转换规则： 如果 toString 方法存在并且返回原始类型，返回 toString 的结果。 如果 toString 方法不存在或者返回的不是原始类型，调用 valueOf 方法，如果 valueOf 方法存在，并且返回原始类型数据，返回 valueOf 的结果。 其他情况，抛出错误。 上面的例子实际上是： var obj = {name: ‘Coco’};var str = ‘123’ + obj.toString(); 其中，obj.toString() 的值为 “[object Object]”。假设是数组： var arr = [1, 2];var str = ‘123’ + arr; console.log(str); // 1231,2 上面 + arr ，由于这里是个字符串加操作，后面的 arr 需要转化为一个字符串类型，所以其实是调用了 + arr.toString() 。但是，我们可以自己改写对象的 toString，valueOf 方法: var obj = { toString: function() { console.log(‘调用了 obj.toString’); return {}; }, valueOf: function() { console.log(‘调用了 obj.valueOf’) return ‘110’; }} alert(obj);// 调用了 obj.toString// 调用了 obj.valueOf// 110 上面 alert(obj + ‘1’) ，obj 会自动调用自己的 obj.toString() 方法转化为原始类型，如果我们不重写它的 toString 方法，将输出 [object Object]1 ，这里我们重写了 toString ，而且返回了一个原始类型字符串 111 ，所以最终 alert 出了 1111。上面的转化规则写了，toString 方法需要存在并且返回原始类型，那么如果返回的不是一个原始类型，则会去继续寻找对象的 valueOf 方法：下面我们尝试证明如果在一个对象尝试转换为字符串的过程中，如果 toString() 方法不可用的时候，会发生什么。这个时候系统会再去调用 valueOf() 方法，下面我们改写对象的 toString 和 valueOf： var obj = { toString: function() { console.log(‘调用了 obj.toString’); return {}; }, valueOf: function() { console.log(‘调用了 obj.valueOf’) return ‘110’; }} alert(obj);// 调用了 obj.toString// 调用了 obj.valueOf// 110 从结果可以看到，当 toString 不可用的时候，系统会再尝试 valueOf 方法，如果 valueOf 方法存在，并且返回原始类型（String、Number、Boolean）数据，返回valueOf的结果。那么如果，toString 和 valueOf 返回的都不是原始类型呢？看下面这个例子： var obj = { toString: function() { console.log(‘调用了 obj.toString’); return {}; }, valueOf: function() { console.log(‘调用了 obj.valueOf’) return {}; }} alert(obj);// 调用了 obj.toString// 调用了 obj.valueOf// Uncaught TypeError: Cannot convert object to primitive value 可以发现，如果 toString 和 valueOf 方法均不可用的情况下，系统会直接返回一个错误。 在查证了 ECMAScript5 官方文档后，发现上面的描述有一点问题，Object 类型转换为 String 类型的转换规则远比上面复杂。转换规则为：1.设原始值为调用 ToPrimitive 的结果；2.返回 ToString(原始值) 。关于 ToPrimitive 和 ToString 的规则可以看看官方文档：ECMAScript5 — ToString Number 类型转换上面描述的是 String 类型的转换，很多时候也会发生 Number 类型的转换： 调用 Number() 函数，强制进行 Number 类型转换 调用 Math.sqrt() 这类参数需要 Number 类型的方法 obj == 1 ，进行对比的时候 obj + 1 , 进行运算的时候 与 String 类型转换相似，但是 Number 类型刚好反过来，先查询自身的 valueOf 方法，再查询自己 toString 方法： 如果 valueOf 存在，且返回原始类型数据，返回 valueOf 的结果。 如果 toString 存在，且返回原始类型数据，返回 toString 的结果。 其他情况，抛出错误。 按照上述步骤，分别尝试一下： var obj = { valueOf: function() { console.log(‘调用 valueOf’); return 5; }} console.log(obj + 1);// 调用 valueOf// 6 var obj = { valueOf: function() { console.log(‘调用 valueOf’); return {}; }, toString: function() { console.log(‘调用 toString’); return 10; }} console.log(obj + 1);// 调用 valueOf// 调用 toString// 11 var obj = { valueOf: function() { console.log(‘调用 valueOf’); return {}; }, toString: function() { console.log(‘调用 toString’); return {}; }} console.log(obj + 1);// 调用 valueOf// 调用 toString// Uncaught TypeError: Cannot convert object to primitive value Boolean 转换什么时候会进行布尔转换呢： 布尔比较时 if(obj) , while(obj) 等判断时 简单来说，除了下述 6 个值转换结果为 false，其他全部为 true： undefined null -0 0或+0 NaN ”（空字符串） Boolean(undefined) // falseBoolean(null) // falseBoolean(0) // falseBoolean(NaN) // falseBoolean(‘’) // false Function 转换好，最后回到我们一开始的题目，来讲讲函数的转换。我们定义一个函数如下： function test() { var a = 1; console.log(1);} 如果我们仅仅是调用 test 而不是 test() ，看看会发生什么？可以看到，这里把我们定义的 test 函数的重新打印了一遍，其实，这里自行调用了函数的 valueOf 方法：我们改写一下 test 函数的 valueOf 方法。 test.valueOf = function() { console.log(‘调用 valueOf 方法’); return 2;} test;// 输出如下：// 调用 valueOf 方法// 2 与 Number 转换类似，如果函数的 valueOf 方法返回的不是一个原始类型，会继续找到它的 toString 方法： test.valueOf = function() { console.log(‘调用 valueOf 方法’); return {};} test.toString= function() { console.log(‘调用 toString 方法’); return 3;} test;// 输出如下：// 调用 valueOf 方法// 调用 toString 方法// 3 破题再看回我正文开头那题的答案，正是运用了函数会自行调用 valueOf 方法这个技巧，并改写了该方法。我们稍作改变，变形如下： function add () { console.log(‘进入add’); var args = Array.prototype.slice.call(arguments); var fn = function () { var arg_fn = Array.prototype.slice.call(arguments); console.log(&apos;调用fn&apos;); return add.apply(null, args.concat(arg_fn)); } fn.valueOf = function () { console.log(&apos;调用valueOf&apos;); return args.reduce(function(a, b) { return a + b; }) } return fn; } 当调用一次 add 的时候，实际是是返回 fn 这个 function，实际是也就是返回 fn.valueOf(); add(1);// 输出如下：// 进入add// 调用valueOf// 1 其实也就是相当于： [1].reduce(function(a, b) { return a + b;})// 1 当链式调用两次的时候： add(1)(2);// 输出如下：// 进入add// 调用fn// 进入add// 调用valueOf// 3 当链式调用三次的时候： add(1)(2)(3);// 输出如下：// 进入add// 调用fn// 进入add// 调用fn// 进入add// 调用valueOf// 6 可以看到，这里其实有一种循环。只有最后一次调用才真正调用到 valueOf，而之前的操作都是合并参数，递归调用本身，由于最后一次调用返回的是一个 fn 函数，所以最终调用了函数的 fn.valueOf，并且利用了 reduce 方法对所有参数求和。除了改写 valueOf 方法，也可以改写 toString 方法，所以，如果你喜欢，下面这样也可以： function add () { var args = Array.prototype.slice.call(arguments); var fn = function () { var arg_fn = Array.prototype.slice.call(arguments); return add.apply(null, args.concat(arg_fn)); } fn.toString = function() { return args.reduce(function(a, b) { return a + b; }) } return fn; } 这里有个规律，如果只改写 valueOf() 或是 toString() 其中一个，会优先调用被改写了的方法，而如果两个同时改写，则会像 Number 类型转换规则一样，优先查询 valueOf() 方法，在 valueOf() 方法返回的是非原始类型的情况下再查询 toString() 方法。 后记在尝试了更多的浏览器之后，发现了上述解法的诸多问题，在 chrome 56 55 下，结果正常。在更新到最新的 chrome57 ，控制台下，结果都会带上 function 字段，在 firefox 下，直接不生效，感觉自己可能陷入了追求某种解法而忽略了一些底层的具体规范，","tags":[]},{"title":"JS复制内容到剪贴板","date":"2019-01-05T10:31:17.000Z","path":"2019/01/05/JS复制内容到剪贴板/","text":"两种方式 第三方方式：clipboard.js 原生方法：document.execCommand() react库：react-copy-to-clipboard clipboard官方网站 第三方库使用方式直接引用&lt;script src=&quot;dist/clipboard.min.js&quot;&gt;&lt;/script&gt;包引用npm install clipboard --save import Clipboard from &#39;clipboard&#39;; 使用从输入框复制1点我复制 12import Clipboard from 'clipboard';const btnCopy = new Clipboard('btn'); 直接复制直接从变量中取值1点我复制 123import Clipboadrd from 'clipboard';const btnCopy = new Clipboard('btn');this.copyValue = 'hello world'; 事件在处理函数中加入以下回调函数：123456789101112// 复制成功后执行的回调函数clipboard.on('success', function(e) &#123; console.info('Action:', e.action);// 动作名称，比如：Action：copy console.info('Text:', e.text);// 内容，比如：Text: hello world console.info('Trigger:', e.trigger);// 返回触发的元素：比如：点我复制 e.clearSelection();// 清除选中内容&#125;)；// 复制失败后执行的回调函数clipboard.on('error', function(e) &#123; console.error('Action', e.action); console.error('Trigger', e.trigger);&#125;); 原生方法可以允许运行命令来操作可编辑区域的内容，注意，是可编辑区域。定义：bool = document.execCommand(aCommandName, aShowDefaultUI, aValueArgument)方法返回一个 Boolean 值，表示操作是否成功。 aCommandName ：表示命令名称，比如： copy, cut 等（更多命令见命令）； aShowDefaultUI：是否展示用户界面，一般情况下都是 false； aValueArgument：有些命令需要额外的参数，一般用不到；使用从输入框复制现在页面上有一个 &lt;input&gt; 标签，我们想要复制其中的内容:1点我复制 123456789const btn = document.querySelector('#btn')btn.addEventListener('click', () =&gt; &#123; const input = document.querySelector('#demoInput'); input.select(); if (document.execCommand('copy')) &#123; document.execCommand('copy'); console.log('复制成功'); &#125;&#125;) 其他地方复制有的时候页面上并没有 &lt;input&gt; 标签，我们可能需要从一个 &lt;div&gt; 中复制内容，或者直接复制变量。但是 execCommand() 方法的定义中提到，它只能操作可编辑区域，也就是意味着除了 &lt;input&gt;、&lt;textarea&gt; 这样的输入域以外，是无法使用这个方法的。这时候我们需要曲线救国。1点我复制 123456789101112const btn = document.querySelector('#btn');btn.addEventListener('click', () =&gt; &#123; const input = document.createElement('input') document.body.appendChild(input); input.setAttribute('value', '听说你想复制我')； input.select(); if (document.execCommand('copy')) &#123; document.execCommand('copy'); console.log('复制成功'); &#125; document.body.removeChild(input)&#125;) 这个曲线救国在移动端iOS调试时会有坑 遇到的坑 点击复制时屏幕下方会出现白屏抖动，仔细看是拉起键盘又瞬间收起知道了抖动是由于什么产生的就比较好解决了。既然是拉起键盘，那就是聚焦到了输入域，那只要让输入域不可输入就好了，在代码中添加input.setAttribute(&#39;readonly&#39;, &#39;readonly&#39;); 使这个 是只读的，就不会拉起键盘了。 无法复制:这个问题是由于input.select() 在ios下并没有选中全部内容，我们需要使用另一个方法来选中内容，这个方法就是input.setSelectionRange(0, input.value.length);。12345678910111213const btn = document.querySelector('#btn');btn.addEventListener('click',() =&gt; &#123; const input = document.createElement('input'); input.setAttribute('readonly', 'readonly'); input.setAttribute('value', 'hello world'); document.body.appendChild(input); input.setSelectionRange(0, 9999); if (document.execCommand('copy')) &#123; document.execCommand('copy'); console.log('复制成功'); &#125; document.body.removeChild(input);&#125;)","tags":[]},{"title":"发布一个 npm 包并没有想象中那么简单","date":"2019-01-05T05:33:15.000Z","path":"2019/01/05/发布一个 npm 包并没有想象中那么简单/","text":"经过我们大半年的努力，Dbox-UI 终于完成了 V1.0 的开发，开心脸。以为只要将开发的代码放到 lib 下，然后执行如下命令就 Game Over了 12npm addusernpm publish 然而。。。 我们出现了几个问题： 手动将代码拷到 lib 下，只要改动一点，就得重新拷贝，效率极低 代码是 ES6 语法，通常node_modules 下面的库在使用者使用时是不会让babel 进行转换的 代码中引入的是 Less 文件 网站代码和组件代码在同一分支导致了很多无法想象的问题，例如eslint的版本升级到5.9.0，会导致网站DEMO无法运行等问题 报错信息： 12345678910111213141516ERROR in ./~/_react-dragme@1.0.11@react-dragme/src/index.js Module parse failed: g:\\gitspace\\react-dragme\\node_modules\\_react-dragme@1.0.11@react-dragme\\src\\index.js Unexpected token (109:16) You may need an appropriate loader to handle this file type. SyntaxError: Unexpected token (109:16) at Parser.pp$4.raise (g:\\gitspace\\react-dragme\\node_modules\\_acorn@3.3.0@acorn\\dist\\acorn.js:2221:15) at Parser.pp.unexpected (g:\\gitspace\\react-dragme\\node_modules\\_acorn@3.3.0@acorn\\dist\\acorn.js:603:10) at Parser.pp$3.parseExprAtom (g:\\gitspace\\react-dragme\\node_modules\\_acorn@3.3.0@acorn\\dist\\acorn.js:1822:12) at Parser.pp$3.parseExprSubscripts (g:\\gitspace\\react-dragme\\node_modules\\_acorn@3.3.0@acorn\\dist\\acorn.js:1715:21) at Parser.pp$3.parseMaybeUnary (g:\\gitspace\\react-dragme\\node_modules\\_acorn@3.3.0@acorn\\dist\\acorn.js:1692:19) at Parser.pp$3.parseExprOps (g:\\gitspace\\react-dragme\\node_modules\\_acorn@3.3.0@acorn\\dist\\acorn.js:1637:21) at Parser.pp$3.parseMaybeConditional (g:\\gitspace\\react-dragme\\node_modules\\_acorn@3.3.0@acorn\\dist\\acorn.js:1620:21) at Parser.pp$3.parseMaybeAssign (g:\\gitspace\\react-dragme\\node_modules\\_acorn@3.3.0@acorn\\dist\\acorn.js:1597:21) at Parser.pp$3.parseParenAndDistinguishExpression (g:\\gitspace\\react-dragme\\node_modules\\_acorn@3.3.0@acorn\\dist\\acorn.js:1861:32) at Parser.pp$3.parseExprAtom (g:\\gitspace\\react-dragme\\node_modules\\_acorn@3.3.0@acorn\\dist\\acorn.js:1796:19) @ ./app.js 25:19-42 webpack: Failed to compile. 遇到这些问题后，我们参考了 antd-tools 和 youzan/zent scripts我们在项目根目录下多加了一个文件夹 scripts，用于预发布的打包 es 和 lib 文件夹代码拷贝ES6 转换成 ES5 语法123\"scripts\": &#123; \"build\": \"babel src -d lib\", &#125;, Less 转换成 Css 语法","tags":[]},{"title":"代码审查","date":"2019-01-05T05:18:22.000Z","path":"2019/01/05/代码审查/","text":"EsLint1npm install --save-dev eslint eslint-loader babel-loader babel-eslint eslint-plugin-react eslint is the core JavaScript linter. eslint-loader tells webpack that you want to use eslint in our build babel-loader transpiles our code with webpack babel-eslint provides linting for valid ES6 code eslint-plugin-react extends ESLint rules to cover React 添加 eslint 配置文件，如果有不希望被限制的语法可以添加到“rule”字段1touch .eslintrc 1234567891011121314151617181920212223&#123; \"parser\": \"babel-eslint\", \"env\": &#123; \"browser\": true, \"commonjs\": true, \"es6\": true, \"node\": true &#125;, \"plugins\": [ \"react\" ], \"extends\": [\"plugin:prettier/recommended\", \"plugin:react/recommended\", \"eslint:recommended\"], \"rules\": &#123; \"quotes\": [1, \"double\", \"avoid-escape\"], \"react/prop-types\": 0, \"no-console\": 0, \"no-unused-vars\": 1, \"no-func-assign\": 2, \"no-const-assign\": 2, \"no-var\": 2, \"react/react-in-jsx-scope\": 0 &#125;&#125; prettier1npm install --save-dev prettier eslint-config-prettier eslint-plugin-prettier prettier — the core prettier library. Duh. eslint-plugin-prettier — this plugin allows you to format code using Prettier when you run –fix eslint-config-prettier — This library solves the conflicts between eslint and prettier. It turns off conflicting rules. ESLint’s rules, not Prettier’s. Obviously. vscode settings配置 vscode 编辑器，可以自动提示并修复错误 .vscode/settings.json 1234567891011&#123; \"editor.formatOnSave\": true, \"[javascript]\": &#123; \"editor.formatOnSave\": false &#125;, \"eslint.autoFixOnSave\": true, \"eslint.alwaysShowStatus\": true, \"files.associations\": &#123; \"*.js\": \"javascriptreact\" &#125;&#125; git hook1npm install --save-dev pretty-quick husky lint-staged 配置文件，使得自动修复错误 package.json 12345&quot;husky&quot;: &#123; &quot;hooks&quot;: &#123; &quot;pre-commit&quot;: &quot;pretty-quick --staged&quot; &#125;&#125;,","tags":[]},{"title":"Fronted-Book","date":"2019-01-05T04:56:55.000Z","path":"2019/01/05/Fronted-Book/","text":"电子书详见：https://github.com/lulu27753/Frontend-Book.git AboutFace4交互设计精髓4中文版（彩版）.pdf 2017科技中的设计趋势报告.pdf CSS权威指南 第3版.pdf CSS插件工具箱.pdf Clean Code（中文版）.pdf Git权威指南.pdf HTML＆XHTML权威指南.pdf HTTP权威指南.pdf JavaScript DOM编程艺术（中文第二版）.pdf JavaScript权威指南(第6版)中文版.pdf JavaScript语言精粹.pdf JavaScript高级程序设计第3版.pdf JavaScript设计模式与开发实践.pdf MVC的JavaScript Web富应用开发.pdf Mac操作说明完全指南.pdf Node.js开发指南.pdf TCP-IP详解卷1：协议.pdf Web性能权威指南.pdf front-end-handbook-2018.pdf ppk谈JavaScript.pdf 图解HTTP.pdf 剑指offer.pdf 高性能JavaScript_编程.pdf 正则指引.pdf 背包九讲2.0.pdf 深入浅出Node.js.pdf 了不起的NodeJS.pdf 深入浅出React和Redux.pdf 你不知道的JavaScript（上）.pdf 前端面试指南.pdf 《不要让我思考Don’tMakeMeThink》-克鲁格.pdf 数据结构与算法JavaScript描述.pdf 锦绣蓝图：怎样规划令人流连忘返的网站.pdf","tags":[]},{"title":"前端学习路线图","date":"2019-01-04T07:42:07.000Z","path":"2019/01/04/前端学习路线图/","text":"","tags":[]},{"title":"Retina 屏","date":"2019-01-03T08:13:55.000Z","path":"2019/01/03/Retina 屏/","text":"分辨率iPhone 6s：1334 x 750MacBook Pro：2880 x 1800普通电脑14寸：1920 x 1080 同样尺寸的图片变得模糊Retina屏 将传统的四个物理像素点模拟一个像素点 解决方案：1&lt;img src=\"pic.png\" srcset=\"pic@2x.png 2x\" /&gt; /*其中@2x.png为后缀的图片就是为Retina准备的*/ CSS中， 有一个属性为 image-set，可以为不同的屏幕配不同尺寸的图片：1234567img &#123; background: url(pic.png) 0 0 no-repeat; background-image: -webkit-image-set(url(pic.png) 1x, url(pic@2x.png) 2x); background-image: -moz-image-set(url(pic.png) 1x,url(images/pic@2x.png) 2x); background-image: -ms-image-set(url(pic.png) 1x,url(images/pic@2x.png) 2x); background-image: -o-image-set(url(url(pic.png) 1x,url(images/pic@2x.png) 2x);&#125; 网页元素宽度高度有半个像素的概念传统屏幕中一个px就是一个px，一个物理像素和一个逻辑像素是一一对应的，没有0.5px的概念。但是四个物理像素模拟一个物理像素的高分辨率屏出现后，这种特性被打破。当一个网页元素的宽度或高度不是整数，而出现小数位长度的时候，四个像素组成的一个逻辑像素中，上面两个像素被渲染为黑色，而下面两个像素并没有被渲染，从而下面两个像素组成的一条线就呈现为一条白色亮线，从逻辑上讲，它仅高0.5px。 解决方案：避免小于0.5px单位的长度出现，当长度大于0.5px的时候，就会完全占满四个物理像素组成的一个逻辑像素。因此，尽可能在一些颜色与邻近元素对比度大的元素中，采用绝对长度单位px，而不使用% em rem pt等非绝对长度单位。不过，Retina屏为更小精度的定位提供了可能，你甚至可以采用0.4px这样的方法来专门为Retina屏进行一些适配。 元素变小，错位高分辨率的屏幕，会使得在普通分辨率下看上去正常的尺寸变的比较小。传统屏幕上显示3行文本，在高分辨率屏幕上则一行就显示完了，显得很丑。 解决方案：采用屏幕适配来为不同宽度的屏幕显示不同的效果。一般而言，能够采用retina屏的电脑，都已经升级到高版本的系统，自带的浏览器版本也比较高，都支持html5的特性，因此，我们在设计制作网页的时候，需要专门为这帮高端用户设计多余的页面元素，使用responsive css的方法，展示给他们更多的内容，从而保证在高分辨率屏幕上和普通分辨率屏幕上都能很好的显示。","tags":[]},{"title":"本地 web 服务器","date":"2019-01-02T08:04:31.000Z","path":"2019/01/02/本地 web 服务器/","text":"http-server123npm install -g http-servercd &lt;your_path&gt;http-server # 会启动一个端口为8080的服务器","tags":[]},{"title":"Logo 动画实现","date":"2019-01-02T06:10:47.000Z","path":"2019/01/02/Logo 动画实现/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;style&gt; body &#123; font-family: Arial,\"Helvetica Neue\",Helvetica,sans-serif; overflow: hidden; background: #fff; &#125; .center &#123; margin: 80px auto; &#125; .so &#123; display: block; width: 500px; height: 156px; background: #ffffff; &#125; .so .inner &#123; width: 500px; height: 156px; position: absolute; &#125; .so .inner * &#123; position: absolute; animation-iteration-count: infinite; animation-duration: 3.5s; &#125; .so .inner .name &#123; position: absolute; font-size: 54px; left: 130px; top: 95px; &#125; .so .inner .name .b &#123; font-weight: bold; &#125; .so .inner .stack-box &#123; top: 100px; width: 115px; height: 56px; &#125; .so .inner .box &#123; width: 115px; height: 56px; left: 0px; &#125; .so .inner .box div &#123; background: #BCBBBB; &#125; .so .inner .box .bottom &#123; bottom: 0px; left: 0px; width: 115px; height: 12px; &#125; .so .inner .box .left &#123; bottom: 11px; left: 0px; width: 12px; height: 34px; &#125; .so .inner .box .right &#123; bottom: 11px; left: 103px; width: 12px; height: 34px; &#125; .so .inner .box .top &#123; top: 0px; left: 0px; width: 0; height: 12px; &#125; .so .inner .stack &#123; left: 22px; top: 22px; &#125; .so .inner .stack .inner-item &#123; background: #F48024; width: 71px; height: 12px; &#125; .so .inner .stack .item &#123; transition: transform 0.3s; width: 291px; &#125; .so .inner .stack div:nth-child(1) &#123; transform: rotate(0deg); &#125; .so .inner .stack div:nth-child(2) &#123; transform: rotate(12deg); &#125; .so .inner .stack div:nth-child(3) &#123; transform: rotate(24deg); &#125; .so .inner .stack div:nth-child(4) &#123; transform: rotate(36deg); &#125; .so .inner .stack div:nth-child(5) &#123; transform: rotate(48deg); &#125; .so .inner .box &#123; animation-name: box; &#125; .so .inner .box .top &#123; animation-name: box-top; &#125; .so .inner .box .left &#123; animation-name: box-left; &#125; .so .inner .box .right &#123; animation-name: box-right; &#125; .so .inner .box .bottom &#123; animation-name: box-bottom; &#125; .so .inner .stack-box &#123; animation-name: stack-box; &#125; .so .inner .stack &#123; animation-name: stack; &#125; .so .inner .stack .inner-item &#123; animation-name: stack-items; &#125; .so .inner .stack .item:nth-child(1) &#123; animation-name: stack-item-1; &#125; .so .inner .stack .item:nth-child(2) &#123; animation-name: stack-item-2; &#125; .so .inner .stack .item:nth-child(3) &#123; animation-name: stack-item-3; &#125; .so .inner .stack .item:nth-child(4) &#123; animation-name: stack-item-4; &#125; .so .inner .stack .item:nth-child(5) &#123; animation-name: stack-item-5; &#125; @keyframes stack &#123; 0% &#123; left: 22px; &#125; 15% &#123; left: 22px; &#125; 30% &#123; left: 52px; &#125; 50% &#123; left: 52px; &#125; 80% &#123; left: 22px; &#125; &#125; @keyframes stack-item-1 &#123; 0% &#123; transform: rotate(12deg * 0); &#125; 10% &#123; transform: rotate(0deg); &#125; 50% &#123; transform: rotate(0deg); &#125; 54% &#123; transform: rotate(0deg); &#125; 92% &#123; transform: rotate(12deg * 0); &#125; &#125; @keyframes stack-item-2 &#123; 0% &#123; transform: rotate(12deg * 1); &#125; 10% &#123; transform: rotate(0deg); &#125; 50% &#123; transform: rotate(0deg); &#125; 54% &#123; transform: rotate(0deg); &#125; 92% &#123; transform: rotate(12deg * 1); &#125; &#125; @keyframes stack-item-3 &#123; 0% &#123; transform: rotate(12deg * 2); &#125; 10% &#123; transform: rotate(0deg); &#125; 50% &#123; transform: rotate(0deg); &#125; 54% &#123; transform: rotate(0deg); &#125; 92% &#123; transform: rotate(12deg * 2); &#125; &#125; @keyframes stack-item-4 &#123; 0% &#123; transform: rotate(12deg * 3); &#125; 10% &#123; transform: rotate(0deg); &#125; 50% &#123; transform: rotate(0deg); &#125; 54% &#123; transform: rotate(0deg); &#125; 92% &#123; transform: rotate(12deg * 3); &#125; &#125; @keyframes stack-item-5 &#123; 0% &#123; transform: rotate(12deg * 4); &#125; 10% &#123; transform: rotate(0deg); &#125; 50% &#123; transform: rotate(0deg); &#125; 54% &#123; transform: rotate(0deg); &#125; 92% &#123; transform: rotate(12deg * 4); &#125; &#125; @keyframes stack-items &#123; 0% &#123; width: 71px; &#125; 15% &#123; width: 71px; &#125; 30% &#123; width: 12px; &#125; 50% &#123; width: 12px; &#125; 80% &#123; width: 71px; &#125; &#125; @keyframes box &#123; 0% &#123; left: 0; &#125; 15% &#123; left: 0; &#125; 30% &#123; left: 30px; &#125; 50% &#123; left: 30px; &#125; 80% &#123; left: 0; &#125; &#125; @keyframes box-top &#123; 0% &#123; width: 0; &#125; 6% &#123; width: 0; &#125; 15% &#123; width: 115px; &#125; 30% &#123; width: 56px; &#125; 50% &#123; width: 56px; &#125; 59% &#123; width: 0; &#125; &#125; @keyframes box-bottom &#123; 0% &#123; width: 115px; &#125; 15% &#123; width: 115px; &#125; 30% &#123; width: 56px; &#125; 50% &#123; width: 56px; &#125; 80% &#123; width: 115px; &#125; &#125; @keyframes box-right &#123; 15% &#123; left: 103px; &#125; 30% &#123; left: 44px; &#125; 50% &#123; left: 44px; &#125; 80% &#123; left: 103px; &#125; &#125; @keyframes stack-box &#123; 0% &#123; transform: rotate(0deg); &#125; 30% &#123; transform: rotate(0deg); &#125; 40% &#123; transform: rotate(135deg); &#125; 50% &#123; transform: rotate(135deg); &#125; 83% &#123; transform: rotate(360deg); &#125; 100% &#123; transform: rotate(360deg); &#125; &#125;&lt;/style&gt;&lt;body&gt;&lt;div class=\"so center\"&gt; &lt;div class=\"inner\"&gt; &lt;div class=\"stack-box\"&gt; &lt;div class=\"stack\"&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner-item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner-item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner-item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner-item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner-item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box\"&gt; &lt;div class=\"bottom\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"top\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"name\"&gt; stack&lt;span class=\"b\"&gt;overflow&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"居中","date":"2019-01-01T13:38:14.000Z","path":"2019/01/01/居中/","text":"一、水平居中子元素为行内元素还是块状元素，宽度一定还是宽度未定。 行内元素：对父元素设置text-align: center; 块元素定宽：设置左右margin值为auto； 块元素不定宽：设置子元素display:inline,从而转换成行内元素的解决方案，在父元素上设置text-align：center； 通用方案：flex布局，对父元素设置display:flex;justify-content:center; 二、垂直居中子元素是单行内联文本、多行内联文本还是块状元素。 \b父元素一定，子元素为单行内联文本：\b设置父元素的heig\bht等于行高line-height 父元素一定，子元素为多行内联文本：设置父元素的display: table-cell 或 inline-block，再设置vertical-align: middle 块元素：设置子元素position: fixed(absolute),然后设置margin: auto 通用方案；flex布局，给父元素设置display:flex;align-items:center;","tags":[]},{"title":"Redux","date":"2019-01-01T12:35:24.000Z","path":"2019/01/01/Redux/","text":"Redux的最根本问题在于它要求数据存储是扁平的，然而真实世界的数据模型却从未扁平——而是树状的。原生的 redux 和浏览器 api 一样，在真实项目中，不适合直接使用，约定大于配置，能提升开发效率吗？能，而且不少。约定一些东西，来减少模板代码，提升开发效率。 约定 type 和 reducer 的 key 一致， 约定 action 返回 promise 的处理方式， 约定 action 中包含某个 key 改怎么处理（即引入处理这个 key 的中间件）， 约定 promise action 都以 REQUEST, FULFILLED, REJECTED 结尾， 约定 action, reducer, selector, const 都在同一文件中（需要注意循环引用）。 缺陷1、Pure Problempure reducer 是个好东西，有很多优点想必大家都心知肚明。但是在我的职业生涯中，为了写出 pure reducer 而把一个概念拆分成2个，而且写到2个文件里，上下文切换麻烦。而带来的好处相对我频繁的建文件，切换上下文已经微乎其微了。 对策：Redux 之所以提出 Pure Reducers 主要是没办法优雅的像 Elm 那样管理副作用。所以 Redux 就不解决了，抛给 Middleware 去解决。这里我建议直接使用可以写副作用的 Reducer。由于异步函数的存在，即使是副作用我们也能写成同步的感觉。 2、Dialog Problem假如你有2个页面A和B，A里面有一个 button 组件B 和 Dialog 组件 D。现在从A组件切换到B，D组件需要被卸载。Redux 的话你需要在 store 创建阶段就要提前声明所有的状态，包括 Dialog 的状态。如果 Dialog 组件被卸载了，Dialog 的状态仍然残留在 Redux 中。这就是问题。 对策：Redux state 只适合放领域数据，包括前端的领域(eg. router、history 等等)和后端领域数据(eg. User, topic 等等)。Redux 没办法管理本地状态和临时状态。Dialog 是随着组件一起加载和卸载的，Dialog state 因此是一种临时状态(volatile state)。可以借用组件的设计思路，让 Dialog state 也可以加载和卸载，即动态加载。然而动态加载并不只是让 Reducer 动态加载就行了。Redux 有个 api 叫 replaceReducer，这个 api 只是把 store 的行为替换掉了(可以把串起来的reducer chain看做一个Behavior)。而没有让 Reducer 要处理的那部分状态动态起来。所以正确的动态应该是让 state 和 state 对应的那部分行为抽象成新的概念，让这两者动态起来，我把这层抽象叫做 Store。 3、State Problem如果你的组件触发了某个行为，这个时候你是知道需要修改 Redux 中的哪部分状态的。但是你还是得把这部分 state merge 到 Redux 中。最后组件只能把全部状态拿出来，再识别出自己需要的那部分状态。 对策：如果能让 state 动态起来，这个问题其实也好解决了。因为你只需要修改这部分状态，你的组件也只需要按需订阅需要的各种拆分出去的状态。 4、Single Store of TruthRedux 之前的状态管理方案都是多 store 架构的，Redux 提出了这个新的概念作为早期卖点之一。在多子项目架构中，父项目 portal 希望把自身的某些状态共享给所有的子项目，比如当前登录用户信息等等。这个需求 Redux 就不好实现了。 对策：早期的状态管理方案 flux 中，Store 是需要继承 event emitter 的(没记错的话…)。Redux 已经看出来问题了，多 event emitter 不好管理。却默认接受了 Store = Event System 的观点。其实我觉得多 Store 架构的缺点其实是多 Event System。我们只需要让 event system 和 store 分离，让 event system 保持 single，即 Single Event System of Truth。而让 store 仍然保持 multiple 可以实现多项目共享数据的问题。同时很方便实现动态 Store 的需求。Portal 项目创建一个 event system，把 UserStore 挂在 system 底下。子组件导入父组件的 event system，把自己的 AStore 挂在 portal 的 system 底下，就可以让 UserStore 和 AStore 交换消息了！ 5、分形项目越来越大，Store 越来越多，如果所有的 Store 都往根节点挂的话，难免有命名的问题。特别是 Portal 已经往 system 挂了一个 UserStore，当你把 system 共享给子项目A， A也有一个 UserStore。这就会有冲突了。 对策： Store 可以创建 Store。比如 Portal 可以创建 AStore，BStore 挂到 system 中。子项目A把自己的 Store 都往 AStore下面挂，而不是往 system(根节点) 下面挂。这样可以完美避免命名冲突的问题。","tags":[]},{"title":"布局","date":"2019-01-01T12:34:00.000Z","path":"2019/01/01/布局/","text":"一、基本概念1、定位(position)定义一个元素相对于其他正常元素的位置，它应该出现在哪里，这里的其他元素可以是父元素，也可以是浏览器窗口本身。 static：元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分\b；行内元素则会创建一个或多个行框，置于其\b父元素中。 relative: 元素框相对于之前正常文档流中的位置发生偏移，并且原先的位置仍然被占据。发生偏移的时候，可能会覆盖其他元素。 absolute：元素框不再占有文档流位置，并且相对于包含块进行偏移(所谓的包含块就是最近一级外层元素position不为static的元素) fixed：元素框不再占有文档流位置，并且相对于视窗进行定位 sticky:相当于relative和fixed混合。最初会被当作是relative,相对于原来的位置进行偏移；一旦超过一定\b阀值之后，会被当成fixed定位，相对于视口进行定位。 定位\b时的偏移量：top | right | bottom | left static: 偏移量不会对static元素起到作用 relative: 它的偏移是相对于原先在文档流中的位置 absolute: 它的偏移是相对于最近一级position不是static的祖先元素的 fixed: 它的偏移量是相对于视口的 在做自适应布局设计时，往往希望这些偏移量的单位能够使用百分比，或者相对的单位例如rem等。 2、尺寸当网页中的字体没有给出实际的px或pt的定义时，任意浏览器会\b给定一个默认值：1em=12pt=16px,对应浏览器中“字体大小”\b中的“中等”，以这个为标准，变大或缩小。 百分比: 百分比的参照物是父元素，50%相当于父元素width的50%； rem: 这个对于复杂的设计图相当有用，它\b是相对于 html 的 font-size 的大小，集相对大小和绝对大小的优点于一身，既可以做到只修改根元素就成比例的调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。 需要考虑兼容性，对于IE8-，所有浏览器均已支持rem 对于不支持的浏览器，就是多写一个绝对单位的声明，浏览器会忽略用rem设定的字体大小。如p{font-size:14px;font-size:0.875rem} em: 即%，它虽然也是一个相对的单位，相对于父元素的font-size，结合css继承关系使用 10px = 0.625em,通常为了简化font-size的换算，\b会在css中设置body的font-size=62.5%,使得16px * 62.5% = 10px 为 1em，也就说只需要将你原来的px数值除以10，然后换上em作为单位即可。 重新计算那些被放大的字体的em数值，避免字体大小的重复声明 避免出现1.2 * 1.2 = 1.44 的现象。比如父元素声明了字体大小为1.2em，那么子元素在声明字体大小时就只能是1em，而不是1.2em，因为此em非彼em，它因为继承了父元素的字体高而使得1em = 12px px: 像素，是屏幕上显示数据的最基本的点，用于网页设计，直观方便。 pt: 专用的印刷单位“榜”，大小为1/72英寸，是自然界标准的长度单位，也称为“绝对长度” 3、盒子模型可以通过box-sizing设置不同的模型。两种盒子模型，主要是width的不同 标准：width = content的宽度 border-box: width = border + padding + content width的默认值是auto，这个属性值会使得内部元素的长度自动填充满父元素的width。 height的默认值也是auto，auto\b表示的是浏览器自动计算。这种自动计算，需要一个基准，一般浏览器都是允许高度滚动的，所以，会导致一个问题——浏览器找不到垂直方向上的基准。 同样地道理也会被应用在margin属性上。相信如果考察居中时，水平居中你可能闭着眼睛都能写出来，但是垂直居中却绕着脑袋想。这是因为如果是块级元素水平居中只要将水平方向上的margin设置成auto就可以了。但是，垂直方向上却没有这么简单，因为你设置成auto时，margin为0。这个问题，还是需要仔细思考一下的。 二、浮动（类似于PS中的图层）浮动的元素会在浮动层上面进行排布，而在原先文档流中的元素位置，会被以某种方式进行删除，但是还是会影响布局。浮动元素，其实对于布局来说，是特别危险的。因为你可能这一块做过浮动，但未做清除，那么造成高度塌陷的问题。 overflow: 将父元素的overflow，设置成hidden。 after伪类：对子元素的after伪类进行设置。 三、flexbox(一维)flex 布局的限制：http://t.cn/EGMB2Uhflex 布局讲解： http://www.lulustyle.net/Flex/02flex%E5%B8%83%E5%B1%80.htmlhttp://www.lulustyle.net/Flex/demo.html 四、css grid(二维)grid-template-columns按百分比显示，左边 70%，右边 30%。 1234.wrapper &#123; display: grid; grid-template-columns: 70% 30%;&#125; 不仅是可以左右按比例，可以任意，比如 1234.wrapper &#123; display: grid; grid-template-columns: 40% 30% 30%;&#125; 除了按百分比，也可以按固定的大小（px）。 123.wrapper &#123; display: grid; grid-template-columns: 300px 200px 200px; fr 单位1234.wrapper &#123; display: grid; grid-template-columns: 1fr 2fr 1fr;&#125; repeat()1234.wrapper &#123; display: grid; grid-template-columns: repeat(4, 1fr);&#125; repeat，顾名思义，重复的意思，1fr 重复四次，那就是 1fr 1fr 1fr 1fr。 1234.wrapper &#123; display: grid; grid-template-columns: repeat(4, 1fr 2fr);&#125; 左边 1 个格子，右边 2 个格子，这样重复 4 次，相当于 1fr 2fr 1fr 2fr 1fr 2fr 1fr 2fr。如果你的标签元素不够，那自然就留为空白了。 网格间距grid-column-gap：列间距 12345.wrapper &#123; display: grid; grid-template-columns: 1fr 2fr 2fr; grid-column-gap: 1em;&#125; grid-row-gap: 行间距 123456.wrapper &#123; display: grid; grid-template-columns: 1fr 2fr 1fr; grid-column-gap: 1em; grid-row-gap: 1em;&#125; 简写 12345678grid-column-gap: 1em;grid-row-gap: 1em;// 等同于grid-gap: 1em// 等同于grid-gap: 1em 2em; //第一个参数是行间距，第二个参数是列间距。 grid-auto-rows(网格高度)123456.wrapper &#123; display: grid; grid-template-columns: 1fr 2fr 1fr; grid-gap: 1em; grid-auto-rows: 100px;&#125; 要解决上面的问题，可以使用 minmax() 设置最小的高度。 123456.wrapper &#123; display: grid; grid-template-columns: 1fr 2fr 1fr; grid-gap: 1em; grid-auto-rows: minmax(100px, auto);&#125; 网格排列justify-items(水平排列)1234567.wrapper &#123; display: grid; grid-template-columns: 1fr 2fr 1fr; grid-gap: 1em; grid-auto-rows: minmax(100px, auto); justify-items: start;&#125; start：最左边排列。 center：中间排列。 end：最右边排列。 stretch：默认情况。 align-items(垂直排列)12345678.wrapper &#123; display: grid; grid-template-columns: 1fr 2fr 1fr; grid-gap: 1em; grid-auto-rows: minmax(100px, auto); justify-items: stretch; align-items: start;&#125; 针对某个特定的网格进行排列使用 justify-self 和 align-self 12345678910111213141516.wrapper &#123; display: grid; grid-template-columns: 1fr 2fr 1fr; grid-gap: 1em; grid-auto-rows: minmax(100px, auto); justify-items: stretch; align-items: stretch;&#125;.box1 &#123; align-self: start;&#125;.box2 &#123; justify-self: start;&#125; 网格空间大小和位置grid-template-columns 是控制了所有的网格盒子的分布比率，如果要控制单个网格盒子的网格水平水向和垂直方向的大小，分别要使用 grid-column 和 grid-row。 这两个指令要用起来，主要是靠自己的理解和对它慢慢地调节，不断地总结经验。 123456.box1 &#123; grid-column: 1/3;&#125;.box2 &#123;&#125; 这个 1/3 表示的是 1 到 3，第一到第三个网格，我们还是来看下效果。 五、布局实现方案单列布局 常见的单列布局有两种： 一种是header、content、footer宽度都相同，其一般不会占满浏览器的最宽宽度，但当浏览器宽度缩小低于其最大宽度时，宽度会自适应。 12345&lt;div class=\"layout\"&gt; &lt;div id=\"header\"&gt;头部&lt;/div&gt; &lt;div id=\"content\"&gt;内容&lt;/div&gt; &lt;div id=\"footer\"&gt;尾部&lt;/div&gt;&lt;/div&gt; 12345.layout&#123;/* width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/ max-width: 960px; margin: 0 auto;&#125; 一种是header、footer宽度为浏览器宽度，但content以及header和footer里的内容却不会占满浏览器宽度。 1234567&lt;div id=\"header\"&gt; &lt;div class=\"layout\"&gt;头部&lt;/div&gt;&lt;/div&gt;&lt;div id=\"content\" class=\"layout\"&gt;内容&lt;/div&gt;&lt;div id=\"footer\"&gt; &lt;div class=\"layout\"&gt;尾部&lt;/div&gt;&lt;/div&gt; 12345.layout&#123;/* width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/ max-width: 960px; margin: 0 auto;&#125; 两栏布局一栏定宽，一栏自适应。这样子做的好处是定宽的那一栏可以做广告，自适应的可以作为内容主体。 实现方式：1、float + margin 1234&lt;body&gt; &lt;div class=\"left\"&gt;定宽&lt;/div&gt; &lt;div class=\"right\"&gt;自适应&lt;/div&gt;&lt;/body&gt; 123456789101112131415161718.left&#123; width: 200px; height: 600px; background: red; float: left; display: table; text-align: center; line-height: 600px; color: #fff;&#125;.right&#123; margin-left: 210px; height: 600px; background: yellow; text-align: center; line-height: 600px;&#125; 2、position+margin:参考三栏布局第二种方法 三栏布局两边定宽，然后中间的width是auto的，可以自适应内容，再加上margin边距，来进行设定。 1.float+margin：使用左右两栏使用float属性，中间栏使用margin属性进行撑开，注意的是html的结果缺点是：(1)当宽度小于左右两边宽度之和时，右侧栏会被挤下去；(2)html的结构不正确 123&lt;div class=\"left\"&gt;左栏&lt;/div&gt;&lt;div class=\"right\"&gt;右栏&lt;/div&gt;&lt;div class=\"middle\"&gt;中间栏&lt;/div&gt; 123456789101112131415161718.left&#123; width: 200px; height: 300px; background: yellow; float: left;&#125;.right&#123; width: 150px; height: 300px; background: green; float: right;&#125;.middle&#123; height: 300px; background: red; margin-left: 220px; margin-right: 160px;&#125; 2.position+margin：使用position定位实现，即左右两栏使用position进行定位，中间栏使用margin进行定位 好处是：html结构正常。缺点时：当父元素有内外边距时，会导致中间栏的位置出现偏差 123&lt;div class=\"left\"&gt;左栏&lt;/div&gt;&lt;div class=\"middle\"&gt;中间栏&lt;/div&gt;&lt;div class=\"right\"&gt;右栏&lt;/div&gt; 123456789101112131415161718192021.left&#123; background: yellow; width: 200px; height: 300px; position: absolute; top: 0; left: 0;&#125;.middle&#123; height: 300px; margin: 0 220px; background: red;&#125;.right&#123; height: 300px; width: 200px; position: absolute; top: 0; right: 0; background: green;&#125; 3、使用float和BFC配合圣杯布局(float + 负margin + padding + position) 将middle的宽度设置为100%，然后将其float设置为left，其中的main块设置margin属性，然后左边栏设置float为left，之后设置margin为-100%，右栏也设置为float：left，之后margin-left为自身大小。缺点是：1. 结构不正确 2. 多了一层标签 1234567891011&lt;div class=\"wrapper\"&gt; &lt;div class=\"middle\"&gt; &lt;div class=\"main\"&gt;中间&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt; 左栏 &lt;/div&gt; &lt;div class=\"right\"&gt; 右栏 &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425.wrapper&#123; overflow: hidden; // 清除浮动&#125;.middle&#123; width: 100%; float: left;&#125;.middle .main&#123; margin: 0 220px; background: red;&#125;.left&#123; width: 200px; height: 300px; float: left; background: green; margin-left: -100%;&#125;.right&#123; width: 200px; height: 300px; float: left; background: yellow; margin-left: -200px;&#125; 4、\bflex布局 除了兼容性，一般没有太大的缺陷 12345&lt;div class=\"wrapper\"&gt; &lt;div class=\"left\"&gt;左栏&lt;/div&gt; &lt;div class=\"middle\"&gt;中间&lt;/div&gt; &lt;div class=\"right\"&gt;右栏&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718.wrapper&#123; display: flex;&#125;.left&#123; width: 200px; height: 300px; background: green;&#125;.middle&#123; width: 100%; background: red; marign: 0 20px;&#125;.right&#123; width: 200px; height: 3000px; background: yellow;&#125; 移动端媒体查询媒体查询的主要原理：给整个 css 样式设置了断点，通过给定的条件去判断，在不同的条件下，显示不同的样式。 @media: all， 所有媒体 braille 盲文触觉设备 embossed 盲文打印机 print 手持设备 projection 打印预览 screen 彩屏设备 speech ‘听觉’类似的媒体类型 tty 不适用像素的设备 tv 电视 例如：手机端的尺寸在750px，而PC端则是大于750px的 12345678910111213@media screen and (min-width: 750px)&#123; .media&#123; height: 100px; background: red; &#125;&#125;@media (max-width: 750px)&#123; .media&#123; height: 200px; background: green; &#125;&#125; 12345678910111213@media screen &#123; p.test &#123;font-family:verdana,sans-serif;font-size:14px;&#125;&#125;@media print &#123; p.test &#123;font-family:times,serif;font-size:10px;&#125;&#125;@media screen,print &#123; p.test &#123;font-weight:bold;&#125;&#125;/*移动端样式*/@media only screen and (min-device-width : 320px) and (max-device-width : 480px) &#123; /* Styles */&#125; flex 弹性盒子移动端会经常使用到flex布局，因为在简单的页面适配方面，flex可以起到很好的拉伸的效果。往往你并不需要去反复的使用媒体查询的。整整的响应式布局是使界面能够自动的根据屏幕进行变化，做到完美的弹性布局，在必要的时候，去使用媒体查询，对页面进行调整。 (1)容器：设定 display:flex 的地方 (2)项目：\b容器内部的直接子项就是flex item (3)轴线(axis)：如坐标系，具备着x轴与y轴，flex在整个布局当中，也可分为水平方向和垂直方向，简称为主轴和交叉轴 main start: 项目到容器的开始位置 main end: 项目到容器结束的位置 cross start: 交叉轴上面的开始位置 cross end: 交叉轴上面的结束位置 main size：项目的水平距离 cross size：项目的垂直距离 (4)容器的基本属性 (a) display：表示容器展示的布局类型，可设定为flex和inline-flex。两者的设定也就是inline和block的区别。当然了，在webkit内核的浏览器(safari)中使用时，需要在其前面加上前缀(-webkit-flex) 1234.container&#123; display: -webkit-flex; display: flex; /* or inline-flex*/&#125; (b) flex-direction: 表示容器内部子项目的展示方向。row | row-reverse | column | column-reverse 123.container&#123; flex-direction: row /* 默认 行正序*/ || row-reverse /*行倒序*/ || column /* 列正序*/ || column-reverse /*列倒序*/&#125; (c) flex-wrap: 表示当容器内部内容超出容器时，容器是否分行展示 nowrap(浏览器默认，不分行) wrap(超出的部分分行处理) wrap-reverse(分行逆序) 123.container&#123; flex-wrap: nowrap || wrap || wrap-reverse;&#125; (d) flex-flow: 这个属性就是可以将上面两个属性合起来写的属性， 123.container &#123; flex-flow: row wrap;&#125; (e) justify-content: 表示容器内部的子项目的水平对齐方式。而水平的对齐方式主要有六种: flex-start: 对应的对齐方式是水平向左对齐。（浏览器默认） flex-end: 对应的对齐方式是水平向右对齐。 center: 对应的对齐方式是居中对齐。 space-between: 对应的是，每个元素之间中间流出间隙是一样的，两边无间隙。 space-around: 对应的是，每个元素周围的间隙是一样的，而不是元素之间的，因此，可以从图中看出两边的间隙会比中间小一半。 space-evenly：对应的是，每个元素之间的间隙大小一致。 1justify-content: flex-start || flex-end || center || space-between || space-around || space-evenly (f) align-items:表示容器内部的子项目的垂直对齐方式。而垂直的对齐方式主要有五种: flex-start: 对应的对齐方式是垂直向上对齐。 flex-end： 对应的对齐方式是垂直向下对齐。 center：对应的对齐方式是垂直居中对齐。 stretch：对应的对齐方式是将整个子项目的长度拉伸到最大块的高度(浏览器默认) baseline： 对应的对齐方式是子项目内部的文字基线对齐。 123.container&#123; align-items: flex-start || flex-end || center || stretch || baseline;&#125; (g) align-content: 表示在对行的情况下，每行所对应的垂直方向上的对齐方式。主要有六种对齐方式： flex-start：对应的是每一行在垂直方向上向上对齐的方式 flex-end：对应的是每一行在垂直方向上向下对齐的方式 center：对应的是每一行在垂直方向上居中对齐的方式 stretch：对应的是每一行延展到铺满整个垂直方向。 space-between：对应的就是每行之间留有空隙，而两边没有空隙 space-around：对应的就是每行周围的空隙均相等 (5) 项目的属性 (a)order：子项目的排列顺序。通常，默认情况下，子项目都是按照默认顺序进行排序的。但是，有时候你或许需要将后面的元素拿上来，那你就可以使用order这个属性,正如图中展示的： 1order: &lt;integer&gt; //如1 (b) flex-grow: 表示的是元素的所占空间的比例.在设置每个元素flex-grow为1时，一行内的子元素都是均分的，即1：1：1。但是，如果你给第一个元素设置flex-grow为2时，它们的比例就会变成2：1：1。如图： 1flex-grow: &lt;integer&gt; /默认为0/ (c) flex-shrink: 表示子项目的伸缩 1flex-shrink: number /*default to 1*/ (d) flex-basis: 表示子项目的长度,默认为auto。当设置flex-grow时，长度就为flex-grow的value，如果没有，就是块本身内容的大小。 1flex-basis：&lt;length&gt; | auto /*default auto*/ (e) flex: flex-grow、flex-shrink和flex-basis的集合写法，默认为0，1，auto 1flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt; (f) align-self: 表示子项目在垂直轴线上的放置方式。 1align-self: auto | flex-start | flex-end | center | stretch | baseline rem适配rem 可以说是移动端适配的一个神器。这种界面有个特点就是页面元素的复杂度比较高，而使用 flex 进行布局会导致页面被拉伸，但是上下的高度却没有变化等问题。从网易与淘宝的font-size思考前端设计稿与工作流","tags":[]},{"title":"Axure RP 8 注册码","date":"2019-01-01T12:15:55.000Z","path":"2019/01/01/Axure RP 8 注册码/","text":"升级了 8.1.0.3377 版本后，需要使用下面这组注册码12License：zdfans.comKey：gP5uuK2gH+iIVO3YFZwoKyxAdHpXRGNnZWN8Obntqv7++FF3pAz7dTu8B61ySxli 升级了 8.1.0.3372 版本后，需要使用下面这组注册码123License：KoshyKey：wTADPqxn3KChzJxLmUr5jTTitCgsfRkftQQ1yIG9HmK83MYSm7GPxLREGn+Ii6xY 升级了 8.1.0.3355 及之后的版本，需要使用下面这组注册码 123License：University of Science and Technology of China (CLASSROOM)Key：DTXRAnPn1P65Rt0xB4eTQ+4bF5IUF0gu0X9XBEUhM4QxY0DRFJxYEmgh4nyh7RtL 升级了 8.0.0.3321 版本后，原来的 LICENSE 失效了，解决方法就是使用下面的这组注册码12License：米 业成 (STUDENT)Key：nFmqBBvEqdvbiUjy8NZiyWiRSg3yO+PtZ8c9wdwxWse4WprphvSu9sohAdpNnJK5","tags":[]},{"title":"网盘搜索引擎","date":"2019-01-01T12:03:34.000Z","path":"2019/01/01/网盘搜索引擎/","text":"盘多多 凌风云搜索 史莱姆搜索 盘搜 西林街搜索 我的盘","tags":[]},{"title":"Dash(文档APP）","date":"2019-01-01T11:58:14.000Z","path":"2019/01/01/Dash(文档APP）/","text":"dashAPI文档浏览器(API Documentation Browser) + 代码片段管理器(Code Snippet Manager) 代码片段管理器双下划线标明占位符，在执行扩展的时候就可以通过tab键来在各个占位符之间切换 变量符号： @clipboard 自动插入当前剪贴板中的内容 @cursor 代码片段粘贴完毕之后，自动将光标定位到此处 @date 自动插入当前日期 @time 自动插入当前时间","tags":[]},{"title":"YAML(配置文件语言)","date":"2019-01-01T11:50:15.000Z","path":"2019/01/01/YAML(配置文件语言)/","text":"介绍YAML(发音 /ˈjæməl/)：专门用来写配置文件的语言 语法规则 大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 #表示注释 支持的数据结构 对象：键值对的集合，映射(mapping) | 哈希(hashes) | 字典(dictionary) 数组：一组按次序排列的值，序列(sequence) | 列表(list) 纯量(scalars)：单个的、不可再分的值；字符串 | 布尔值 | 整数 | 浮点数 | Null | 时间 | 日期 对象 冒号结构 1animal: pets 12// js&#123; animal: &apos;pets&apos; &#125; 数组123- Cat- Dog- Goldfish 12// js[ &apos;Cat&apos;, &apos;Dog&apos;, &apos;Goldfish&apos; ] 复合结构123456789languages: - Ruby - Perl - Python websites: YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org 123456789&#123; languages: [ &apos;Ruby&apos;, &apos;Perl&apos;, &apos;Python&apos; ], websites: &#123; YAML: &apos;yaml.org&apos;, Ruby: &apos;ruby-lang.org&apos;, Python: &apos;python.org&apos;, Perl: &apos;use.perl.org&apos; &#125; &#125; 纯量字符串123s1: &apos;内容\\n字符串&apos;s2: &quot;内容\\n字符串&quot;str: &apos;labor&apos;&apos;s day&apos; 1&#123; s1: &apos;内容\\\\n字符串&apos;, s2: &apos;内容\\n字符串&apos;, str: &apos;labor\\&apos;s day&apos; &#125; 多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行 +表示保留文字块末尾的换行，-表示删除字符串末尾的换行 123456789s1: | Foos2: |+ Foos3: |- Foo 1&#123; s1: &apos;Foo\\n&apos;, s2: &apos;Foo\\n\\n\\n&apos;, s3: &apos;Foo&apos; &#125; &amp;用来建立锚点（defaults），&lt;&lt;表示合并到当前数据，*用来引用锚点。 12345- &amp;showell Steve - Clark - Brian - Oren - *showell 1[ &apos;Steve&apos;, &apos;Clark&apos;, &apos;Brian&apos;, &apos;Oren&apos;, &apos;Steve&apos; ] 其他1234567number: 12.30isSet: trueparent: ~ iso8601: 2001-12-14t21:59:43.10-05:00date: 1976-07-e: !!str 123f: !!str true 12345678&#123; number: 12.30, isSet: true, parent: null, iso8601: new Date(&apos;2001-12-14t21:59:43.10-05:00&apos;), date: new Date(&apos;1976-07-31&apos;), e: &apos;123&apos;, f: &apos;true&apos;&#125;","tags":[]},{"title":"Shell","date":"2019-01-01T11:47:48.000Z","path":"2019/01/01/Shell/","text":"一、前言 在通过ssh来远程操纵Linux/Unix服务器时，都是使用 shell 而不是用户界面 相比于通过点击多个用户界面来执行操作，输入命令行更加直接和快捷 利用管道组合各种可用工具，来创建和定制宏工具 使用shell script将重复简单的任务自动化 二、Shell 基本语法Shell常用特殊变量变量 含义$0 当前脚本的文件名$n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是\\$1，第二个参数是\\$2$# 传递给脚本或函数的参数个数$* 传递给脚本或函数的所有参数$@ 传递给脚本或函数的所有参数。被双引号(” “)包含时，与 \\$* 稍有不同$? 上个命令的退出状态，或函数的返回值。成功返回0，失败返回1$$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID $* 和 $@ 都是将参数一个一个返回 &quot;$*&quot;将所有参数当做一个整体字符串返回 常用判断参数12345678910111213141516171819202122-a file exists.-b file exists and is a block special file.-c file exists and is a character special file.-d file exists and is a directory.-e file exists (just the same as -a).-f file exists and is a regular file.-g file exists and has its setgid(2) bit set.-G file exists and has the same group ID as this process.-k file exists and has its sticky bit set.-L file exists and is a symbolic link.-n string length is not zero.-o Named option is set on.-O file exists and is owned by the user ID of this process.-p file exists and is a first in, first out (FIFO) special file or named pipe.-r file exists and is readable by the current process.-s file exists and has a size greater than zero.-S file exists and is a socket.-t file descriptor number fildes is open and associated with a terminal device.-u file exists and has its setuid(2) bit set.-w file exists and is writable by the current process.-x file exists and is executable by the current process.-z string length is zero. 判断命令 命令 含义 -eq 等于 -ne 不等于 -gt 大于 -lt 小于 ge 大于等于 le 小于等于 三、推荐安装工具iterm基本配置 查看当前机器安装了哪些shell: cat /etc/shells 把bash切换成zsh: chsh -s /bin/zsh 切换到bash：chsh -s /bin/bash 安装 oh my zsh：curl -L https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh | sh 高效使用zsh： 选中即复制：无需command+c 屏幕分隔 command+d: 垂直分割 command+shift+d: 水平分割 快速唤出：设置热键为：option+空格键 显示复制历史：&lt;span data-type=&quot;background&quot; style=&quot;background-color:#FAFAFA&quot;&gt;command+shift+h&lt;/span&gt; 全屏切换：command+enter 全文查找:command + f 自动补全命令: command + ; | tab键 执行上一条命令：!! 显示所有命令别名：alias 设置别名：alias pod_update=&#39;pod update --verbose --no-repo-update&#39; autojump 快速切换路径 brew install autojump zsh: command not found: j 报错（在.zshrc文件相应的位置，找到 plugins=() 这行,添加 autojump 记得各插件名之间用英文空格隔开，然后重启item即可） tree 安装tree:brew install tree tree &lt;选项或者是参数&gt; &lt;分区或者是目录&gt; 常用参数 显示所有文件和目录: -a 显示目录名称而非内容: -d 在每个文件或目录之前，显示完整的相对路径名称: -f 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上&quot;*&quot;,&quot;/&quot;,&quot;=&quot;,&quot;@&quot;,&quot;|&quot;号: -F 以相反次序排列: -r 用文件和目录的更改时间排序: -t 只显示 n 层目录: -L n 目录显示在前,文件显示在后: --dirsfirst 不常用参数 -A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。 -C 在文件和目录清单加上色彩，便于区分各种类型。 -D 列出文件或目录的更改时间。 -g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。 -i 不以阶梯状列出文件或目录名称。 -I 不显示符合范本样式的文件或目录名称。 -l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。 -n 不在文件和目录清单加上色彩。 -N 直接列出文件和目录名称，包括控制字符。 -p 列出权限标示。 -P 只显示符合范本样式的文件或目录名称。 -q 用”?”号取代控制字符，列出文件和目录名称。 -s 列出文件或目录大小。 -u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。 -x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。 Homebrew/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;译注：在Max OS X 10.11（El Capitan)版本中，homebrew在安装软件时可能会碰到/usr/local目录不可写的权限问题。可以使用下面的命令修复：sudo chown -R whoami/usr/local Homebrew Nodebrew install node安装完node后建议设置npm镜像以加速后面的过程（或使用科学上网工具）。注意：不要使用cnpm！cnpm安装的模块路径比较奇怪，packager不能正常识别！npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global 配置npm全局文件路径在npm中安装全局文件时，npm会把他安装在npm里面配置的prefix路径下123npm config list # 查看prefixnpm config set prefix=\"/Users/ex-lulu003/nodemodules/node_global\"npm config set cache=\"/Users/ex-lulu003/nodemodules/node_cache\" 配置环境变量环境变量加载顺序1234567/etc/profile #系统级别的，系统启动就会加载/etc/paths #系统级别的，系统启动就会加载~/.bash_profile #当前用户级的环境变量~/.bash_login #当前用户级的环境变量~/.profile #当前用户级的环境变量~/.bashrc #bash shell打开的时候载入 设置PATH的语法export PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH N&gt;echo $PATH //查看当前变量值 修改全局文件设置需要root权限 /etc/paths （全局建议修改这个文件）： 编辑 paths，将环境变量添加到 paths文件中 ，一行一个路径 Hint：输入环境变量时，不用一个一个地输入，只要拖动文件夹到 Terminal 里就可以了 /etc/profile（建议不修改这个文件） 全局（公有）配置，不管是哪个用户，登录时都会读取该文件 /etc/bashrc （一般在这个文件中添加系统级环境变量） 全局（公有）配置，bash shell执行时，不管是何种方式，都会读取此文件 可以自己生成新的文件，不用把变量全都放到 paths 一个文件里，方便管理 创建一个文件：sudo touch /etc/paths.d/mysql 用 vim 打开这个文件（如果是以 open -t 的方式打开，则不允许编辑:sudo vim /etc/paths.d/mysql 编辑该文件，键入路径并保存（关闭该 Terminal 窗口并重新打开一个，就能使用 mysql 命令了:/usr/local/mysql/bin 修改单个用户设置 vi ~/.bash_profile （任意一个文件中添加用户级环境变量 vi ~/.bashrc 使得环境变量更改后，立即生效source &lt;相应的文件名&gt; Yarnnpm install -g yarn安装完yarn后同理也要设置镜像源：yarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global Watchman由Facebook提供的监视文件系统变更的工具。安装此工具可以提高开发时的性能（packager可以快速捕捉文件的变化从而实现实时刷新）brew install watchman FlowFlow是一个静态的JS类型检查工具,这一语法并不属于ES标准，只是Facebook自家的代码规范brew install flow 四、Mac-pro 命令行1234567891011121314151617control + umkdir -p!!history&amp;&amp;resetopen:双击，-a选项要求自行选择打开的程序，或使用-e强制在TextEdit中编辑此文件。open一个目录会在Finder窗口中打开此目录。一个很有用的技巧是open .打开当前目录。pbcopy 和 pbpastemdfind:即Spotlight，-onlyin选项可以约束搜索范围为一个目录 切换用户权限12sudo su # 切换至root用户su - 用户名 # -和用户名之间有空格 资源mac下添加sublime text打开快捷键 subl10 Tools To Power Up Your Command Line","tags":[]},{"title":"Git","date":"2019-01-01T11:42:15.000Z","path":"2019/01/01/Git/","text":"1. Git 基础1.1. 仓库1.1.1. 在现有项目中初始化仓库1git init # 初始化仓库 Changes to be committed: 已暂存状态 Changes not staged for commit: 已跟踪文件发生了变化，但没有放到暂存区 1.1.2. 克隆现有仓库1git clone [url] [local_name] # 会克隆每个文件的每个版本 1.1.3. 远程仓库1234567git remote # 列出指定的每一个远程服务器的简写 -v显示与其对应的 URLgit remote add &lt;shortname&gt; &lt;url&gt; # 添加一个新的远程 Git 仓库git fetch [remote-name] # 拉取远程仓库中你还没有的数据，不会自动合并|修改当前的工作git pull [remote-name] [remote-branch-name] # 自动的抓取并合并远程分支到当前分支git push [remote-name] [branch-name] # 推送数据git remote show [remote-name] # 命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 git pull 时哪些分支会自动合并。git remote rm [remote-name] # 移除一个远程仓库 git clone会自动将其添加为远程仓库并默认以 “origin” 为简写 123# 将本地已有的仓库推送到远程git remote add origin https://github.com/lulu27753/music_app.gitgit push -u origin master 1.2. gitignore 的格式规范 所有空行或以#开头的行都会被Git忽略 可以使用标准的glob模式匹配 匹配模式可以以（/）开头防止递归 匹配模式可以以（/）结尾指定目录 要忽略指定模式以外的文件和目录，可以在模式前加上（!)取反 简化的正则表达式： (*) 匹配0\b或多个任意字符 [abc] 匹配任何一个列在方括号中的字符 (?) \b只匹配一个任意字符 (-) 表示在这两个字符范围内的都可以\b匹配 (**) 匹配任意中间目录，比如a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z等。 1.3. 记录更新1234567git status # 检查当前文件的状态 -s\b状态简览git diff # \b查看未暂存的文件更新git diff --staged # 查看已暂存的文件更新git add *.c # 开始跟踪文件| 把已跟踪的文件放到暂存区 | 合并时把有冲突的文件标记为已解决git rm PROJECTS.md # 记录移除文件操作 -f强制删除在暂存区的文件 --cached 删除记录仅记录在暂存区，磁盘仍然保留文件git mv README.md README # 更改文件名字git commit -m &apos;initial project version&apos; # 提交更新，-a跳过使用git add 1.4. 历史记录1git log # 按提交时间列出提交历史 -p显示每次提交的差异 --stat仅显示文件差异 1.5. 撤销1234567git clean -f # 删除 untracked filesgit clean -fd # 连 untracked 的目录也一起删掉git clean -xfd # 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）# 加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删git clean -nxfd git clean -nf git clean -nfd 123git commit --amend # 第二次提交将代替第一次提交git reset HEAD &lt;file&gt; # 取消文件暂存git checkout -- &lt;file&gt; # 撤销文件修改 12git reset HEAD^ --hardgit push -f [remote] [branch] 1234567891011# Delete the most recent commit, keeping the work you've done:git reset --soft HEAD~1# Delete the most recent commit, destroying the work you've done:git reset --hard HEAD~1# 撤销(回退)某次commitgit revert commit_hash_id # (revert会产生一个新的commit,回退代码)# 撤销git add操作git rm --cache xxxx # 从暂存区删除,这个不会删除物理文件 临时仓库（stash)12345git stashgit stash listgit stash applygit stash popgit stash drop stash 不小心被clear或者drop git fsck –lost-found 复制dangling commit 的id（其他的dangling blob不用理会） git show [id] 查看具体内容， 找到你想要的记录，记录中会描述日期和摘要，日期是你git stash 的日期， 摘要会记录你是在哪一条commit 上进行git stash操作的， git merge [id] 1.6. \b打标签123456git tag # 以字母顺序列出所有标签git tag -a v1.4 -m 'my version 1.4' # 创建附注标签 -m指定存储在标签中的信息git show [tag-name] # 显示所有的标签信息git push origin [tag-name] # 传送标签到远程仓库git push origin --tags # 把所有不在远程仓库服务器上的标签全部上传git checkout -b [branchname] [tagname] # 在特定的标签上创建一个新分支 1.7. 别名1234567git config --global alias.co checkoutgit config --global alias.br branchgit config --global alias.ci commitgit config --global alias.st statusgit config --global alias.unstage &apos;reset HEAD --&apos;git config --global alias.last &apos;log -1 HEAD&apos;git config --global alias.visual &apos;!gitk&apos; 2. Git 分支2.1. 本地分支管理12345678910git branch [branch_name] # 创建分支git checkout [branch_name] # 切换分支git checkout -b [branch_name] #创建并切换分支git log --oneline --decorate # 查看各个分支当前所指的对象git checkout [branch_name] # 切换分支git log --oneline --decorate --graph --all # 输出提交历史、各个分支指向及项目的分支分叉情况git merge [branch_name] # 合并分支到当前分支git branch -d [branch_name] # 删除分支 -D强制删除git mergetool # 启动可视化合并工具git branch # 查看分支列表 -V查看每一个分支的最后一次提交 --merged查看已合并到当前分支的分支 --no-merged查看未合并的分支 2.2. 分支工作流（work silos） master: 保留完全稳定的代码——仅仅是已经发布或即将发布的代码 develop(next): 后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，就可以被合并入 master 分支 特性分支（短期分支): 能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布 proposed（建议）: 建议更新分支，它因包含一些不成熟的内容而不能进入develop分支,没有太大必要。 2.3. 远程分支管理12345678910git remote show (remote_name) # 远程跟踪分支git fetch origin # 从origin抓取本地没有的数据，并更新本地数据库，移动 origin/master 指针指向更新后的位置git push [remote_name] [branch_name]：[remote_branch_name] # 将本地[branch_name]分支推送到有写入权限的远程仓库git checkout -b serverfix origin/serverfix # 会创建一个用于工作的本地分支serverfix，并且起点位于 origin/serverfixgit checkout --track origin/serverfix # 创建serverfix分支从origin/serverfix拉取数据git branch -u origin/serverfix # 修改正在跟踪的上游分支 -\bu即--set-upstream-togit branch -vv # 查看设置的所有跟踪分支git fetch --all # 抓取所有的远程仓库git push origin --delete serverfix # 删除远程分支serverfixgit push -f origin lbranch-3:refs/rbranch-1 # 用本地分支lbranch-3覆盖远程分支rbranch-1 设置远程地址的文件在.git目录下的config文件中 12git remote rm origin # 删除远程地址git remote add origin [url] # 添加远程地址 1git remote origin set-url [url] # 修改远程地址 2.4. Rebase(变基) rebase将提交到某一分支上的所有修改都移至到\b另一分支上，就像“重新播放”.和merge的整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 12345git checkout experiment // 检出到experiment分支git rebase master // 将experiment分支上的修改变基到master上git checkout master // 检出到master分支git merge experiment // 将master指针快进合并git rebase --onto master server client // 取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后把它们在 master 分支上重放一遍 只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作. 交互式rebase12git checkout featuregit rebase -i master // 把-i 传入git rebase 选项来开始一个交互式的rebase过程 会打开一个文本编辑器，显示所有将被移动的提交12 项目管理12345git diff --color [branchA] [branchB] &gt; foo.diffgit diff //对比workspace与indexgit diff HEAD //对于workspace与最后一次commitgit diff &lt;source_branch&gt; &lt;target_branch&gt; //对比差异git add &lt;filename&gt; //修改完冲突，需要add以标记合并成功 资源CODING | 代码托管 项目管理 WebIDE 企业服务码云 Gitee — 开源中国 Git 代码托管平台Git BookGit Flight RuleGit教程™Code-Guide","tags":[]},{"title":"网络","date":"2019-01-01T09:51:37.000Z","path":"2019/01/01/网络/","text":"一、UDP1、不可靠性2、面向报文3、高效4、传输方式二、TCP1、头部2、状态机3、ARQ 协议4、滑动窗口5、拥塞处理三、HTTP1、POST 和 GET 的区别2、常见状态码3、HTTP 首部四、HTTPS1、TLS五、HTTP2.01、二进制传输2、多路复用3、Header 压缩4、服务端 Push5、QUIC六、webSocket七、DNS八、从输入 URL 到页面加载完成的过程","tags":[]},{"title":"前端异常捕获与上报","date":"2019-01-01T08:49:32.000Z","path":"2019/01/01/前端异常捕获与上报/","text":"经过了大量测试及联调的项目在有些时候还是会有十分隐蔽的bug存在，这种复杂而又不可预见性的问题唯有通过完善的监控机制才能有效的减少其带来的损失，因此对于直面用户的前端而言，异常捕获与上报是至关重要的 一、前端监控系统市面上非常完善的前端监控系统： sentry bugsnag 做前端监控大体从以下几个方面考虑： 二、try catch1234567try &#123; var a = 1; var b = a + c;&#125; catch (e) &#123; // 捕获处理 console.log(e); // ReferenceError: c is not defined&#125; 如 async_await 等异步代码可通过 try_catch 来捕获异常，这种方式大部分情况可行，不至于让页面挂掉，缺点是需要在捕获异常的代码上进行包裹，会导致页面臃肿不堪，不适用于整个项目的异常捕获。 三、window.onerror全局监听异常：123456789window.onerror = function(errorMessage, scriptURI, lineNo, columnNo, error) &#123; console.log('errorMessage: ' + errorMessage); // 异常信息 console.log('scriptURI: ' + scriptURI); // 异常文件路径 console.log('lineNo: ' + lineNo); // 异常行号 console.log('columnNo: ' + columnNo); // 异常列号 console.log('error: ' + error); // 异常堆栈信息&#125;;console.log(a); window.onerror 可以拦截到大部分的详细报错信息，还提供了错误行列号，可以精准的进行定位，但是无法处理跨域代码、MVVM 代码 及 Promise 异常 四、MVVM 中的错误处理在MVVM框架中使用 window.onerror 是捕获不到异常的，因为异常信息被框架自身的异常机制捕获了。 1、Vue.config.errorHandler比如Vue 2.x中我们应该这样捕获全局异常：12345678910111213Vue.config.errorHandler = function (err, vm, info) &#123; let &#123; message, // 异常信息 name, // 异常名称 script, // 异常脚本url line, // 异常行号 column, // 异常列号 stack // 异常堆栈信息 &#125; = err; // vm为抛出异常的 Vue 实例 // info为 Vue 特定的错误信息，比如错误所在的生命周期钩子&#125; 2、React 16+ 的 ErrorBoundaryreact也提供了异常处理的方式，在 React 16.x 版本中引入了 Error Boundary：123456789101112131415161718192021class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; componentDidCatch(error, info) &#123; this.setState(&#123; hasError: true &#125;); // 将异常信息上报给服务器 logErrorToMyService(error, info); &#125; render() &#123; if (this.state.hasError) &#123; return '出错了'; &#125; return this.props.children; &#125;&#125; 使用组件：123&lt;ErrorBoundary&gt; &lt;MyWidget /&gt;&lt;/ErrorBoundary&gt; 五、跨域 之 Script error跨域之后 window.onerror 是无法捕获异常信息的，所以统一返回 Script error. ，解决方案便是 script 属性配置 crossorigin=“anonymous” 并且服务器添加Access-Control-Allow-Origin。一般的CDN网站都会将Access-Control-Allow-Origin配置为*，即所有域都可以访问。 1234567&lt;!-- http://localhost:3031/ --&gt;&lt;script&gt;window.onerror = function() &#123; console.log(arguments);&#125;;&lt;/script&gt;&lt;script src=\"http://cdn.xxx.com/index.js\"&gt;&lt;/script&gt; 解决方案：1&lt;script src=&quot;http://cdn.xxx.com/index.js&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; 六、Promise使用 Promise.catch() 函数 七、SourceMap生产环境一般会将代码压缩一下再发布，这时候便出现了压缩后的代码无法找到原始报错位置的问题。 如图，我们用 webpack 将代码打包压缩成 bundle.js ：123456789101112// webpack.config.jsvar path = require('path');// webpack 4.1.1module.exports = &#123; mode: 'development', entry: './client/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'client') &#125;&#125; 最后页面引入的脚本文件是这样的：1!function(e)&#123;var o=&#123;&#125;;function n(r)&#123;if(o[r])return o[r].exports;var t=o[r]=&#123;i:r,l:!1,exports:&#123;&#125;&#125;...; 异常信息：lineNo可能是一个非常小的数字，一般是1，而columnNo会是一个很大的数字，这里是730，因为所有代码都压缩到了一行。 在webpack中开启source-map功能：12345module.exports = &#123; ... devtool: '#source-map', ...&#125; 打包压缩的文件末尾会带上 source-map 的注释：该文件对应的map文件为bundle.js.map12!function(e)&#123;var o=&#123;&#125;;function n(r)&#123;if(o[r])return o[r].exports;var t=o[r]=&#123;i:r,l:!1,exports:&#123;&#125;&#125;...;//# sourceMappingURL=bundle.js.map source-map 文件 是一个 JSON 对象：1234567version: 3, // Source map的版本sources: [\"webpack:///webpack/bootstrap\", ...], // 转换前的文件names: [\"installedModules\", \"__webpack_require__\", ...], // 转换前的所有变量名和属性名mappings: \"aACA,IAAAA,KAGA,SAAAC...\", // 记录位置信息的字符串file: \"bundle.js\", // 转换后的文件名sourcesContent: [\"// The module cache var installedModules = &#123;&#125;;...\"], // 源代码sourceRoot: \"\" // 转换前的文件所在的目录 八、栈递归对于某些浏览器可能不会显示调用栈信息，可以通过 arguments.callee.caller 来做栈递归 九、错误上报1、未压缩文件上报在脚本代码没有被压缩的情况下可以直接捕获后上传对应的异常信息，通常可以通过 img 标签的 src 发起一个请求。 2、压缩文件上报提交异常将异常信息传递给接口：12345678910111213141516171819window.onerror = function(errorMessage, scriptURI, lineNo, columnNo, error) &#123; // 构建错误对象 var errorObj = &#123; errorMessage: errorMessage || null, scriptURI: scriptURI || null, lineNo: lineNo || null, columnNo: columnNo || null, stack: error &amp;&amp; error.stack ? error.stack : null &#125;; if (XMLHttpRequest) &#123; var xhr = new XMLHttpRequest(); xhr.open('post', '/middleware/errorMsg', true); // 上报给node中间层处理 xhr.setRequestHeader('Content-Type', 'application/json'); // 设置请求头 xhr.send(JSON.stringify(errorObj)); // 发送参数 &#125;&#125; sourceMap 解析附：source-map API 前端浏览器解析前端浏览器可以对map文件进行解析，但因为前端解析速度较慢，所以这里不做推荐 服务器解析通过将异常信息提交到node 中间层，然后解析map文件后将数据传递给后台服务器：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const express = require('express');const fs = require('fs');const router = express.Router();const fetch = require('node-fetch');const sourceMap = require('source-map');const path = require('path');const resolve = file =&gt; path.resolve(__dirname, file);// 定义post接口router.post('/errorMsg/', function(req, res) &#123; let error = req.body; // 获取前端传过来的报错对象 let url = error.scriptURI; // 压缩文件路径 if (url) &#123; let fileUrl = url.slice(url.indexOf('client/')) + '.map'; // map文件路径 // 解析sourceMap let smc = new sourceMap.SourceMapConsumer(fs.readFileSync(resolve('../' + fileUrl), 'utf8')); // 返回一个promise对象 smc.then(function(result) &#123; // 解析原始报错数据 let ret = result.originalPositionFor(&#123; line: error.lineNo, // 压缩后的行号 column: error.columnNo // 压缩后的列号 &#125;); let url = ''; // 上报地址 // 将异常上报至后台 fetch(url, &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json' &#125;, body: JSON.stringify(&#123; errorMessage: error.errorMessage, // 报错信息 source: ret.source, // 报错文件路径 line: ret.line, // 报错文件行号 column: ret.column, // 报错文件列号 stack: error.stack // 报错堆栈 &#125;) &#125;).then(function(response) &#123; return response.json(); &#125;).then(function(json) &#123; res.json(json); &#125;); &#125;) &#125;&#125;);module.exports = router; 通过前端传过来的异常文件路径获取服务器端 map 文件地址，然后将压缩后的行列号传递给 sourceMap 返回的 promise 对象进行解析，通过 originalPositionFor 方法就能获取到原始的报错行列号和文件地址，最后通过 ajax 将需要的异常信息统一传递给后台存储，完成异常上报。下图可以看到控制台打印出了经过解析后的真实报错位置和文件： 注意点若你的应用访问量很大，那么一个小异常都可能会把你的服务器搞挂，所以上报的时候可以进行信息过滤和采样等。 设置一个调控开关，服务器也可以对相似的异常进行过滤，在一个时间段内不进行多次存储。","tags":[]},{"title":"安全","date":"2019-01-01T08:42:32.000Z","path":"2019/01/01/安全/","text":"一、XSS(cross-site scripting)跨网站指令码，是 代码注入 的一种 1、如何攻击通过修改 HTML 节点 或者 执行 JS 代码，利用的是用户对指定网站的信任12&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt; &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; 上述 URL 输入可能会将 HTML 改为 alert(1) ，这样页面中就凭空多了一段可执行脚本。 也有另一种场景，比如写了一篇包含攻击代码 alert(1) 的文章保存到了数据库，那么可能浏览文章的用户都会被攻击到。 2、如何防御转义转义输入输出的内容，对于引号，尖括号，斜杠进行转义：1234567891011function escape(str) &#123; str = str.replace(/&amp;/g, \"&amp;\"); str = str.replace(/&lt;/g, \"&lt;\"); str = str.replace(/&gt;/g, \"&gt;\"); str = str.replace(/\"/g, \"&amp;quto;\"); str = str.replace(/'/g, \"&amp;##39;\"); str = str.replace(/`/g, \"&amp;##96;\"); str = str.replace(/\\//g, \"&amp;##x2F;\"); return str&#125;escape('&lt;script&gt;alert(1)&lt;/script&gt;') // -&gt; &lt;script&gt;alert(1)&lt;&amp;##x2F;script&gt; 白名单(黑名单)123var xss = require(\"xss\");var html = xss('&lt;h1 id=\"title\"&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(\"xss\");&lt;/script&gt;');console.log(html); // -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(\"xss\");&lt;/script&gt; 使用了 js-xss 来实现；可以看到在输出中保留了 h1 标签且过滤了script 标签 3、CSP(内容安全策略)内容安全策略 (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。 我们可以通过 CSP 来尽量减少 XSS 攻击。CSP 本质上也是建立白名单，规定了浏览器只能够执行特定来源的代码。 通常可以通过 HTTP Header 中的 Content-Security-Policy 来开启 CSP只允许加载本站资源 1Content-Security-Policy: default-src ‘self’ 只允许加载 HTTPS 协议图片 1Content-Security-Policy: img-src https://* 允许加载任何来源框架 1Content-Security-Policy: child-src 'none' 更多属性可以查看 这里 二、CSRF(cross-site request forgery)“跨站请求伪造”是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。利用的是网站对用户网页浏览器的信任，即利用用户的登录态发起恶意请求。 1、如何攻击假设网站中有一个通过 Get 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口 1&lt;img src=\"http://www.domain.com/xxx?comment='attack'\"/&gt; 如果接口是 Post 提交的，就相对麻烦点，需要用表单来提交接口 123 &lt;form action=\"http://www.domain.com/xxx\" id=\"CSRF\" method=\"post\"&gt; &lt;input name=\"comment\" value=\"attack\" type=\"hidden\"&gt;&lt;/form&gt; 2、如何防御规则： Get 请求不对数据进行修改 不让第三方网站访问到用户 Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者 token SameSite可以对 Cookie 设置 SameSite 属性。该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。 验证 Referer对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的 Token服务器下发一个随机 Token(算法不能复杂)，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。 三、密码安全虽然前端加密对于安全防护来说意义不大，但是在遇到中间人攻击的情况下，可以避免明文密码被第三方获取。 加盐12// 加盐也就是给原密码添加字符串，增加原密码长度sha256(sha1(md5(salt + password + slat))) 使用 utility 库1234567const utility = require('utility');module.exports = &#123; md5pwd: function (pwd) &#123; const salt = 'qwertyuiopasdfghjklzxcvbnm' return utility.md5(utility.md5(pwd + salt)) &#125;&#125; 但是加盐并不能阻止别人盗取账号，只能确保即使数据库泄露，也不会暴露用户的真实密码。一旦攻击者得到了用户的账号，可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而应该提示账号或密码错误。 CryptoJS1export &#123; CryptoJS, SM2CipherMode, SM2Cipher &#125;","tags":[]},{"title":"如何渲染几万条数据并不卡住界面","date":"2019-01-01T08:27:10.000Z","path":"2019/01/01/如何渲染几万条数据并不卡住界面/","text":"tags: [性能]categories: 业务场景解决方案 如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 DOM，那么就可以通过 requestAnimationFrame 来每 16 ms 刷新一次。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt;控件&lt;/ul&gt; &lt;script&gt; setTimeout(() =&gt; &#123; // 插入十万条数据 const total = 100000 // 一次插入 20 条，如果觉得性能不好就减少 const once = 20 // 渲染数据总共需要几次 const loopCount = total / once let countOfRender = 0 let ul = document.querySelector(\"ul\"); function add() &#123; // 优化性能，插入不会造成回流 const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; once; i++) &#123; const li = document.createElement(\"li\"); li.innerText = Math. oor(Math.random() * total); fragment.appendChild(li); &#125; ul.appendChild(fragment); countOfRender += 1; loop(); &#125; function loop() &#123; if (countOfRender &lt; loopCount) &#123; window.requestAnimationFrame(add); &#125; &#125; loop(); &#125;, 0); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"性能优化","date":"2018-12-31T13:56:29.000Z","path":"2018/12/31/性能优化/","text":"一、网络相关1、DNS 预解析1&lt;link rel=\"dns-prefetch\" href=\"//lulustyle.net\"&gt; 2、缓存降低资源的重复加载提高网页的整体加载速度 强缓存：在缓存期间不需要请求(200) Expires：Wed, 22 Oct 2018 08:41:00 GMT 表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。(HTTP 1.0) Cache-Control: max-age = 30 优先级高于 Expires, 表示资源会在 30s 后过期，需要再次请求(HTTP 1.1) 协商缓存（需要请求，304）需要客户端和服务端共同实现 Last-Modified 和 If-Modified-Since Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改 ETag 和 If-None-Match 优先级高于 Last-Modified。 ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。 选择合适的缓存策略对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略： 对于某些不需要缓存的资源，可以用 Cache-Control: no-store,表示该资源不需要缓存 对于频繁变动的资源，可以用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。3、HTTP 2.01.1 的话会有并发请求限制，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间 2.0 引入多路复用，能够让多个请求使用同一个 TCP 连接，极大加快了网页的加载速度。还支持 Header 压缩 ，进一步的减少了请求的数据大小 4、预加载 兼容性不好 将一些不影响首屏但重要的文件延后加载，可以在一定程度上降低首屏的加载时间 预加载是声明式的 fetch，强制浏览器请求资源，并且不会阻塞 onload 事件1&lt;link rel=\"preload\" href=\"http://lulustyle.net/resume\"&gt; 5、预渲染 通过预渲染将下载的文件预先在后台渲染 预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染1&lt;link rel=\"prerender\" href=\"http://lulustyle.net/resume\"&gt; 二、优化渲染过程1、懒执行 可用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行 将某些逻辑延迟到使用时再计算 懒执行需要唤醒，一般通过定时器或者事件调用来唤醒2、懒加载 将不关键的资源延后加载 原理就是只加载自定义区域 (通常是可视区域 或者 即将进入可视区域) 内需要加载的东西 例如图片懒加载：先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。 三、文件优化1、图片优化计算图片大小 100px * 100px图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，每个像素有4个通道（RGB+alpha），每个通道1个字节(8byte)，图片大小 = 10000 1 4 / 1024 = 39KB 图片加载优化 减少像素点 减少每个像素点能够显示的颜色 [x] 不用图片：对于有些修饰类图片完全可以用 CSS 代替 CDN 加载：对于移动端来说，屏幕宽度较小，没必要去加载原图浪费带宽 base64：小图用 base64 直接嵌入到代码中 雪碧图：将多个图标文件整合到一张图片中 选择正确的图片格式： WebP：具有更好的图像数据压缩算法，更小的图片体积，且拥有肉眼识别无差异的图片质量，注意兼容性 PNG：小图，或者用 SVG 代替 JPEG：照片 2、其他文件优化 CSS 文件放在 head 中 服务端开启文件压缩功能 将 script 标签放在 body 底部，因为 JS 文件执行会阻塞渲染。或者放在任意位置后加上 defer，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。 对于没有任何依赖的 JS 文件可以加上 async, 表示加载和渲染后续文档元素的过程将和 JS 文件的加载与执行并行无序进行 执行 JS 时间过长会阻塞渲染，对于需要很多时间计算的代码可以考虑使用 Webworker (另开一个线程执行脚本而不影响渲染) 3、CDN 静态资源尽量使用 CDN 浏览器对于单个域名有并发请求上限，可以考虑使用多个域名 对于 CDN 加载资源要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie 四、webpack4 优化webpack 配置详见 : https://www.yuque.com/lulu27753/lulu/nxdb9r producttion 模式：自动开启代码压缩 tree shaking：移除没有用的代码 按需加载：按路由拆分代码 添加哈希：文件名加上hash，实现浏览器缓存文件","tags":[]},{"title":"你不知道的 console.log","date":"2018-12-31T12:53:04.000Z","path":"2018/12/31/你不知道的 console.log/","text":"console.log()console.log 是支持像 C 里的 sprintf 那种 format 方式的。12345// Syntaxconsole.log(msg, values)// Democonst a = &#123; x: &#123; xx: &apos;123&apos;, yy: &apos;4545&apos; &#125;, y: &#123; zz: &apos;6543&apos;&#125; &#125;;console.log(&quot;test hhh %o&quot;, a) 占位符可以有 %s、%o（对象）、%d 等等。 还有一种比较骚的是 %c，它事实上是 css 的占位符： 如果是用来做点 log，其实还蛮炫的，不过用法在细节上有些 weird。 console.dir()一般情况下，它的结果和 console.log 是一样的。但是当传入的是一个 DOM 时，就有如下区别： 可以看出，当你想看一个 DOM 元素细节的时候，console.dir 打印出来的可能更符合我们的期待。 console.warn()它和 console.log 唯一的区别就是会变黄，但也不止于此，你可以在下图所示的地方做 filter，这样 log 就会变得更清晰： console.table()这个东西是极其骚的，但是以前没关注过。如果我们有下面这种数组数据： 123456789101112131415161718192021const data = [&#123; id: &quot;7cb1-e041b126-f3b8&quot;, seller: &quot;WAL0412&quot;, buyer: &quot;WAL3023&quot;, price: 203450, time: 1539688433&#125;,&#123; id: &quot;1d4c-31f8f14b-1571&quot;, seller: &quot;WAL0452&quot;, buyer: &quot;WAL3023&quot;, price: 348299, time: 1539688433&#125;,&#123; id: &quot;b12c-b3adf58f-809f&quot;, seller: &quot;WAL0012&quot;, buyer: &quot;WAL2025&quot;, price: 59240, time: 1539688433&#125;]; console.table 和 console.log 的对比如下： 还可以通过第二个参数指定打印出的列： 1console.table(data, [&quot;id&quot;, &quot;price&quot;]) 效果如下： 需要指出的是，console.table 方法最多打印 1000 行。 原文连接：https://medium.com/@mattburgess/beyond-console-log-2400fdf4a9d8","tags":[]},{"title":"2018年总结","date":"2018-12-30T11:02:35.000Z","path":"2018/12/30/2018年总结/","text":"关于学习成长接触了 react 全家桶并且开始学习 Node、SQL、HTTP、设计模式、算法等；停了一年的博客因为开始把本地所有的笔记以及 Github 上整理的一些外链资源整合到语雀上又重新搭建了起来； 关于团队管理及人性认知一直以来我觉得以诚待人会是一种比较不累的沟通方式，并且无论自己还是对方都能体会到这种诚的可贵，然而这个真的只能是对自己重要的人而言。 2018 年命运让我遇到了两个人，一个我欣赏的人和一个欣赏我的人，很残忍不是同一个，对于后者不忍伤害，希望你能走好自己的路，一步一步变成更好的自己，没有谁是离不开谁的，因为前者我知道当你成为一个人的“结”，很多事情变得不由自主，变得无法自拔，变得难以理喻，变得深信不已，可是相信我，我离开，你得到的是解脱。 2018年我开始站在更高的角度上去看问题，去尝试着输出自己的价值观，尝试着帮助身边的人成长，了解我的人知道我会“怒其不争”，但是很庆幸有人因为我的帮助，不断的变得更好，并没有因为我的“厉害”而觉得我不好相处。 虽然这样还是会有一些人觉得这种帮助理所当然，职场上没有谁是有义务去帮助你成长的，你是来工作的，拿多少钱就应该干好最基本的事情，不要给身边的人带来负担。 今年我冒了一些”风险“去选择相信一些人，有人说你最应该控制自己的就是“要知道什么该说，什么不该说”，我知道对一些人说了“不该说的话”我会失去一些本来会属于我的东西，但是我觉得这些东西未来我可以凭实力拿回来，而你要选择一起并肩战斗的人一定要经得起这样的考验。人性就是这样，有些人因为“背叛“就永远都不能再出现在你的名单里，我们要学会去找到那些“你用后背都可以去相信的人”，这很重要。 关于2019年2018年学了很多东西，2019年要开始用起来尝试着去捡起一些东西，一些人，给彼此一个机会吧 写一个小的开源库，并尝试推广 数据可视化 Electron","tags":[]},{"title":"可视化界面配置解决方案","date":"2018-12-29T05:54:49.000Z","path":"2018/12/29/可视化界面配置解决方案/","text":"tags: [组件]categories: 业务场景解决方案 流程图GGEditorGGEditor | A visual graph editor based on G6 and React flowchart.js语雀流程图解决方案adrai/flowchart.js: Draws simple SVG flow chart diagrams from textual representation of the diagram mxgraphjgraph/mxgraph: mxGraph is a fully client side JavaScript diagramming library GoJShttps://gojs.net/latest/samples/flowchart.html","tags":[]},{"title":"React 16+","date":"2018-12-28T06:43:16.000Z","path":"2018/12/28/React 16+/","text":"Fiber 架构Reconciler(协调)：跟踪组件的状态变化，并将更新的状态映射到到新的界面。React 的元素、生命周期、 render 方法，以及应用于组件子元素的 diffing 算法综合起到的作用 Stack ReconcilerV16- 中更新过程是同步的，React 挂载或者更新的时候，递归调用各个组件生命周期，对比VDOM 更新 DOM 树，整个过程一旦开始，不可被打断。 浏览器主线程被渲染过程占用比较长的时间，导致进程阻塞 渲染过程没有优先级可言，不同状态变化是需要有优先级的 Fiber ReconcilerFiber 把渲染过程分成了一个个 chunk，变同步为异步，提升性能： 增量渲染：将渲染任务拆分成块，匀到多帧 渲染过程中有机会将主线程交给 react 以外的 JS 调用(如用户操作) 渲染有了优先级，能让高优先级的工作先做 Fiber 之后，将更新分了两个部分 render/reconciliation(可中断) componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate commit(不可中断) componentDidMount componentDidUpdate componentWillUnmount 已改变的生命周期即将移除的 componentWillMount: UNSAFE_componentWillMount componentWillReceiveProps: UNSAFE_componentWillReceiveProps componentWillUpdate: UNSAFE_componentWillUpdate 新增的 getDerivedStateFromProps(props, state): getSnapshotBeforeUpdate(prevProps, prevState): 更好的错误处理方式V16-：handleError(error)123unstable_handleError: function(error)&#123; this.setState(&#123;error: \"oops\"&#125;)&#125; 只能处理 render() 抛出 Error，其他的生命周期函数触发不了 能捕获当前组件本身抛出的 Error，但是还是会阻碍接下来的渲染 V 16+：componentDidCatch(error, info ) error: 捕获的错误 info: 错误信息栈123456// infocomponentStack: \" in BuggyCounter (created by App) in ErrorBoundary (created by App) in div (created by App) in App\" 使用方法1234567891011121314151617class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; hasError: false &#125; &#125; componentDidCatch(err, info) &#123; this.setState(&#123; hasError: false &#125;) // 上报错误 logErrorToMyService(err, info) &#125; render() &#123; if (this.state.hasError) &#123; return &lt;h1&gt;Something is wrong&lt;/h1&gt; &#125; return this.props.children &#125;&#125; 123&lt;ErrorBoundary&gt; &lt;otherComponent&gt;&lt;/otherComponent&gt;&lt;ErrorBoundary&gt; ErrorBoundary 作为一个专门处理错误的异常边界组件 能捕获所有子组件，任何生命周期函数抛出的异常 只能捕获子组件抛出的 error,组件本身的异常无法捕获。因此我们的异常边界组件不能涉及业务代码，否则将无法捕获自身逻辑错误 子组件抛出的错误会层层往上传递，直到被捕获，一到捕获之后，就不会再往上传播。 注意：Error boundaries 不能捕获的错误 事件处理 异步(e.g.setTimeout or requestAnimationFrame callbacks) 服务端渲染 组件自身的错误 错误处理表现在 React16 之后，未被捕获的错误，错误会一直往上抛，直到 React 将 React Tree 全部卸载。同时，在开发环境，控制台会输出所有的错误，包括被捕获的错误。 新的 Render 返回 React elements Booleans OR null V16.0.0 Arrays and V16.2.0 Fragments123// 需要给每个 item 添加 keyrender 参考资源Lin Clark 的演讲视频React Fiber是什么完全理解React FiberInside Fiber: in-depth overview of the new reconciliation algorithm in React","tags":[]},{"title":"二维码生成外链(判断是否是微信扫描）","date":"2018-12-26T12:35:10.000Z","path":"2018/12/26/二维码生成外链(判断是否是微信扫描）/","text":"需求通过二维码生成 sketch 下载链接，可以扫描下载 问题初始方案：通过二维码生成 sketch 静态资源链接，然而 用安卓微信是直接解析的，会直接下载文件，用IOS 手机微信扫描后会产生乱码 改进方案通过二维码生成一个静态 HTML 的页面，并判断“用户代理” 信息，确认是否是微信客户端，从而实现返回不同的文字效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Download&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; html, body &#123; height: 100%; width: 100%; &#125; #holder &#123; height: 25%; &#125; #content &#123; text-align: center; &#125; #content p &#123; font-size: 20px; line-height: 36px; margin-bottom: 20px; &#125; #link &#123; display: inline-block; width: 80%; color: #2D71DB; text-align: left; font-size: 12px; word-break:break-all; &#125; #link a &#123; color: #2D71DB !important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"holder\"&gt;&lt;/div&gt; &lt;div id=\"content\"&gt; &lt;p&gt; &lt;span id=\"tar\"&gt;请复制网址后使用浏览器下载&lt;/span&gt;&lt;br&gt; 或发送下载链接至PC端微信下载 &lt;/p&gt; &lt;div id=\"link\"&gt; https://obs-cn-shanghai.yun.pingan.com/xdc/PAT%20Design%20UI%20Kit%20Orange_V1.1.sketch?response-content-disposition=attachment%3Bfilename%3DPAT%2520Design%2520UI%2520Kit%2520Orange_V1.1.sketch &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var ua = navigator.userAgent.toLocaleLowerCase(); var isWeixin = ua.indexOf('micromessenger') != -1; var tar = document.getElementById('tar'); var link = 'https://obs-cn-shanghai.yun.pingan.com/xdc/PAT%20Design%20UI%20Kit%20Orange_V1.1.sketch?response-content-disposition=attachment%3Bfilename%3DPAT%2520Design%2520UI%2520Kit%2520Orange_V1.1.sketch'; var linkWrap = document.getElementById('link'); if (!isWeixin) &#123; tar.innerText = '可点击直接下载'; linkWrap.innerHTML = '&lt;a href=\"' + link + '\"&gt;' + link + '&lt;/a&gt;'; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最终效果浏览器 微信","tags":[]},{"title":"node 命令","date":"2018-12-25T13:54:33.000Z","path":"2018/12/25/node 命令/","text":"12# 查询全局模块路径npm root -g # /usr/local/lib/node_modules","tags":[]},{"title":"webpack 工作原理","date":"2018-12-24T10:24:23.000Z","path":"2018/12/24/webpack 工作原理/","text":"tags: [组件]categories: 底层原理及基础 流程概括 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，通过执行对象的 run 方法开始执行编译 确定入口：根据配置中的 entry 找出所有入口文件 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容及它们之间的依赖关系 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk, 再将每个 Chunk 转换成一个单独的文件加入输出列表中，这是可以修改输出内容后的最后机会 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入到文件系统中 流程细节初始化启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler 事件 解释 初始化参数 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。在这个过程中还会执行配置文件中的插件实例化语句 new Plugin() 实例化 Compiler 用上一步得到的参数初始化 Compiler 实例，Compiler 负责文件监听和启动编译。在Compiler 实例中包含了完整的 webpack 配置，全局只有一个 Compiler 实例 加载插件 依次调用插件的 apply 方法，让插件可以监听后续的所有事件节点。同时向插件传入 compiler 实例的引用，以方便插件通过 compiler 调用 webpack 提供的 API environment 开始应用 Node.js 风格的文件系统到 compiler 对象，以方便后续的文件寻找和读取 entry-option 读取配置的Entrys,为每个 Entry 实例化一个对应的 EntryPlugin，为后面该 Entry 的递归解析工作做准备 after-plugins 调用完所有内置的和配置的插件的 apply 方法 after-resolvers 根据配置初始化 resolver, resolver 负责在文件系统中寻找指定路径的文件 编译从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module, 递归地进行编译处理 事件 解释 run 启动一次新的编译 watch-run 和 run 类似，区别在于它是在监听模式下启动编译，在这个事件中可以获取是哪些文件发生了变化从而导致重新启动一次新的编译 compile 该事件是为了告诉插件一次新的编译将要启动，同时会给插件带上 compiler 对象 compilation 当webpack 以开发模式运行时，每当检测到文件的变化，便有一次新的 compilation 被创建。一个 Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。Compilation 对象也提供了很多事件回调给插件进行拓展 build-module: 使用对应的 Loader 去转换一个模块 normal-module-loader: 在用 Loader 转换完一个模块后，使用 acorn 解析转换后的内容，输出对应的抽象语法树(AST)，以方便 Webpack 在后面对代码进行分析 program: c make 一个新的 Compilation 创建完毕，即将从 Entry 开始读取文件，根据文件的类型和配置的 Loader 对文件进行编译，编译完后再找出该文件依赖的文件，递归地编译和解析 after-compile 一次 Compilation 执行完成 invalid 当遇到文件不存在、文件编译错误等异常时会触发该事件，该事件不会导致 webpack 退出 输出将编译后的 Module 组合成 Chunk,将 Chunk 转换成文件，输出到文件系统中","tags":[]},{"title":"mobx","date":"2018-12-23T02:45:00.000Z","path":"2018/12/23/mobx/","text":"mobx状态管理工具 VS Redux 开发难度低：redux函数式编程思想；mobx响应式编程风格，同时集成度高，避免引入众多第三方库 开发代码量少：redux有reducer等众多概念，而mobx只要在store中更新即可 渲染性能好：redux通过shouldComponentUpdate优化，但是当应用大到一定程度，就比较难实现；mobx精确的指出了哪些需要重复渲染，将re-render限制在最小范围之内 mobx核心思想 状态变化引起的副作用应该被自动触发 数据流：类redux单向数据流模式（action =》 State =〉Reaction） 基础知识实现继承和多态1234567mkdir mobx_testcd mobx_testmkdir srctouch src/index.jsnpm init -ytouch webpack.config.jsyarn add webpack webpack-cli babel-core babel-preset-env babel-loader -D 配置webpack.config.js 1234567891011121314151617181920212223const path = require('path')module.exports = &#123; mode: 'development', // 'production' entry: path.resolve(__dirname, 'src/index.js'), output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'main.js', &#125;, module: &#123; rules: [&#123; test: /\\.js$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['env'], &#125; &#125; &#125;] &#125;, devtool: 'inline-source-map', // 方便调试&#125; 配置package.json 123\"scripts\": &#123; \"start\": \"webpack -w\" // -w：js文件更改自动执行编译 &#125;, 编写index.html123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src= \"src/index.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 编写src/index.js 用原生实现继承和多态 继承：Dog.prototype.proto === Animal.prototype 多态：重写Dog的name属性 Dog的原型对象的构造函数应该指向Dog而不是Animal 12345678910111213141516171819202122232425262728293031323334353637function Animal() &#123; // body...&#125;function Dog() &#123; // body...&#125;Object.defineProperties(Animal.prototype, &#123; name: &#123; value() &#123; return 'Animal' &#125; &#125;, say: &#123; value() &#123; return `I'm $&#123;this.name()&#125;` &#125; &#125;&#125;)// dog instanceOf Animal === true// dog.__proto__.__proto__ === Animal.prototype// dog.__proto__ === Dog.prototype// Dog.prototype.__proto__ === Animal.prototypeDog.prototype = Object.create(Animal.prototype, &#123; constructor: &#123; value: Dog, enumerable: false, &#125;, name: &#123; value() &#123; return `Dog` &#125; &#125;&#125;)// document.write(new Dog() instanceOf Animal())// document.write(new Dog().say())document.write(Dog.prototype.constructor) 通过ES6来实现 12345678910111213141516class Animal &#123; name() &#123; return 'Animal' &#125; say() &#123; return `I'm $&#123;this.name()&#125;` &#125;&#125;class Dog extends Animal &#123; name() &#123; return 'Dog' &#125;&#125;console.log(new Dog() instanceOf Animal 安装babel插件，使其支持在类中声明成员变量yarn add babel-plugin-transform-class-properties -D配置webpack.config.jsmodule.rules下面的use.plugins: [‘transform-class-properties’] decoratorDecorator是在声明阶段实现类与类成员注解的一种语法.本质上是特殊的函数。 安装babel插件yarn add babel-plugin-transform-decorators-legacy -D配置webpack.config.jsmodule.rules下面的use.plugins: [‘transform-decorators-legacy’] mobx 常用 API安装mobx依赖：yarn add mobx observable(可观察的数据)是一种让数据的变化可以被观察的方法 哪些数据可以被观察： 原始类型：String | Number | Boolean | Symbol 对象 数组 PS：一定要检查数组的长度以避免越界访问，在mobx中越界的数组值是不被观察的.同样要检查对象是否含有属性hasOwnProperty 1234567891011import &#123; observable &#125; from 'mobx';class Store &#123; @observable array = [] @observable obj = &#123;&#125; @observable map = new Map() @observable string = 'hello' @observable number = 20 @observable bool = false&#125; 对可观察的数据作出反应方式： computed observe() get() autorun when reaction mobx 实现 todoListyarn add mobx-react react react-dom prop-typesyarn add babel-preset-react 配置webpack.config.jspresets: [[&#39;env&#39;, &#39;react&#39;]], 资源mobx-state-tree","tags":[]},{"title":"单元测试","date":"2018-12-23T02:25:20.000Z","path":"2018/12/23/单元测试/","text":"前言前端单测是一个可有可无的东西？ 写单测比较费时，有这个时间不如多做几个需求！ 测试在验收的时候对页面的功能都会操作一遍，写单测相当于无用功 后端提供给前端的接口需要保证质量，因此需要做单测，但前端很少需要提供接口给其他人。 什么情况下需要单测在大部分情况下，如果公司业务不复杂，我是认同完全没有必要做单测的观点的。但如果涉及到了以下几个方面，则要好好考虑一下： 业务比较复杂，前端参与的人员超过3人 公司非常注重代码的质量，想尽一切办法杜绝线上出bug 是跨项目组件的提供方 在做一个开源项目 组件化单测的必要性： 虽然单元测试需要花费时间且所花时间会比模块本身更多，但是性价比却是随着使用的次数越来越高 在工作中或开源社区中，我们写库的目的都是为了能更好的为别人使用，这个时候单元测试应该是必须的 好的单元测试可以作为优秀的文档，并且保证模块行为的确定性。 UI库并不涉及业务逻辑，所以只写单元测试足够 测哪些方面 模块应被渲染的DOM树是否正确 模块的属性传递是否正确,(属性是方法,则是否被正确调用;属性是布尔值或对象,则是否被正确传递且达到预期的目的） 模块内的各个行为是否正确 甚至可以测试各个DOM节点是否被应用预期的class，且这些class是不是预期的样式 测试工具 Jest是Facebook开发的一个测试框架，它集成了测试执行器、断言库、spy、mock、snapshot和测试覆盖率报告等功能。React项目本身也是使用Jest进行单测的，因此它们俩的契合度相当高。 Enzyme是由airbnb开发的React单测工具。它扩展了React的TestUtils并通过支持类似jQuery的find语法可以很方便的对render出来的结果做各种断言。 \bJEST 跑一个简单的测试用例 技术栈：React@16 + webpack@3 编写测试用例流程： Arrange（准备）：设置测试场景，准备测试数据 Act（执行）：调用被测试代码 Assert（断言）：验证被测代码是否与预期相同 安装Jest并让其支持ES6语法1npm install --save-dev jest jest-cli babel-jest # babel-jest的作用是让单测代码支持ES6 \b新建单测文件夹并新建一个单测文件1.在项目的根目录新建__jest__文件夹和\bcomponents文件夹 __jest__ __mocks__ __tests__ mudules // 存放各个模块的单测代码 utils // 对一些公用函数写的测试代码 sum.test.js // 单测用例 components Math.js // 被测试对象 2.新建单测文件 123456// __jest__/__test__/sum.test.jsconst sum = require('../../../components/Math');test('adds 1 + 2 to equal 3', () =&gt; &#123; expect(sum(1, 2)).toBe(3);&#125;); 1234function sum(a, b) &#123; return a + b;&#125;module.exports = sum; 配置package.json1234567891011121314151617\"jest\": &#123; // moduleFileExtensions对应webpack中的extensions； \"moduleFileExtensions\": [ \"js\", \"jsx\" ], // moduleDirectories对应webpack中的modulesDirectories； \"moduleDirectories\": [ \"node_modules\" ], // moduleNameMapper对应webpack中的alias \"moduleNameMapper\": &#123; \"\\\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$\": \"&lt;rootDir&gt;/__jest__/__mocks__/fileMock.js\", \"\\\\.(css|scss)$\": \"identity-obj-proxy\", // 对于css等样式文件，使用identity-obj-proxy来mock，它会在引用到class的地方直接返回class的类名 \"^cpn(.*)$\": \"&lt;rootDir&gt;/src/components$1\" //这里的&lt;rootDir&gt;对应我们项目的根目录。 &#125; &#125; 同时添加以下script： 123\"scripts\": &#123; \"test\": \"jest __jest__/__tests__\"&#125; 运行测试脚本在命令行输入：npm run test出现以下结果，则说明Jest安装成功并通过第一个测试!👏 create-react-app create-react-app 自带 Jest 库 Jest 会自动在当前目录下寻找满足条件的JS文件作为单测代码来执行 文件名以 .test.js 为后缀的代码文件 存于 _test_ 目录下的代码文件 目录结构 在根目录创建test目录，单测文件以 .test.js 为后缀 在每个组件目录下创建 _test_ 子目录 语法测试用例it()1234// 它在什么样的情况下是什么行为it(&apos;should return object when invoked&apos;, () =&gt; &#123; // 增加断言语句&#125;) 测试套件 describe() 测试套件 = 测试用例 + 测试套件 从外到里顺序执行 重用共同的环境设置 123456describe('action', () =&gt; &#123; it('should return object when invoked', () =&gt; &#123; // 增加断言语句 &#125;) // 可以有更多的it函数调用&#125;) 钩子函数 beforeAll: 在开始测试套件开始之前执行一次 afterAll: 在结束测试套件中所有测试用例之后执行一次 beforeEach: 每个测试用例在执行之前都执行一次 afterEach: 每个测试用例在执行之后都执行一次","tags":[]},{"title":"项目启动流程","date":"2018-12-23T02:19:17.000Z","path":"2018/12/23/项目启动流程/","text":"前言假设接到一个新项目，首先考虑以下几点 使用何种类库，如何考虑技术选型？分别从哪几个维度去考虑？ 项目目录如何组织(按角色还是按功能) dev和prod不同环境如何配置 团队内部其他系统都用了什么 多人合作开发，团队环境和代码规范问题如何解决?是否需要统一编辑器 是否需要出文档，教其他团队成员配置环境、安装依赖等 如果每个项目皆是如此，请考虑效率？(脚手架、cli) 如何稳定高效的推动项目，请考虑成本收益比，并考虑项目所需的人力、物力的各项支持 技术框架选型考虑以下几个问题： 框架自身成熟度？ 框架生态圈 框架主要解决什么问题？ 团队：学习成本 项目周期： 项目维护成本 结论：最终决定在中小型项目中使用Vue，而大中型项目中使用React，而对于金融科技公司而言，中台复杂项目较多，从而选定以React为主，当项目周期短且交付压力大时仍采用使用Vue的策略。 项目目录按角色12345678reducers/ #包含所有Redux 的reducer; todoReducer.jsactions/ #包含所有action 构造函数； todoActions.jscomponents/ #包含所有的傻瓜组件； todoList.jscontainers/ #包含所有的容器组件。 todoListContainer.js “按照角色组织”的方式非常不利于应用的扩展。当你需要对一个功能进行修改，虽然这个功能只是针对某一个具体的应用模块，但是却牵扯到多个角色，而不得不在多个目录间跳转。 按功能12345678910111213141516todoList/ actions.js #定义action 类型； actionTypes.js #定义action 构造函数，决定了这个功能模块可以接受的动作； index.js #导出该组件需要导出的所有内容，每个文件夹下都包含一个index文件也有利于直接引用文件夹名称就可以导出模块 reducer.jS #定义这个功能模块如何对应actions.js 中定义的动作； views/ #包含这个功能模块中所有的React 组件 component.js #傻瓜组件 container.js #容器组件filter/ actions.js actionTypes.js index.js reducer.js views/ component.js container.js 每个功能模块对应一个目录，每个目录下包含同样名字的角色文件。当需要修改某个功能模块的代码时，只要关注对应的目录即可，所有需要修改的代码文件都能在当前目录下找到。 脚手架为什么不用create-react-app 不满足当前团队的需求 不可以定制化，需要二次修改配置 没有开发组件的能力 结论：为什么不自己开发一个cli工具呢？？ yeoman npm install yo -g 把全局环境node_modules包下面的模板工程 copy 到你的当前项目路径文件夹下","tags":[]},{"title":"机器学习","date":"2018-12-23T01:50:20.000Z","path":"2018/12/23/机器学习/","text":"Python 廖雪峰 Python 教程 Python 入门教程 Tensorflow Tensorflow中文文档 资源 机器学习干货Top10，附项目地址 机器学习速成课程","tags":[]},{"title":"开源管理","date":"2018-12-23T01:45:43.000Z","path":"2018/12/23/开源管理/","text":"督导小组 核心功能的监督把控， 整体功能的规划设计， 督导新功能的引入， 制定开发计划， 提交代码 Review 编译小组 代码文件编译到不同端的实现， 微信小程序端 JSX 编译， 快应用端 JSX 编译等 ESLint 插件维护 开发工具小组负责 cli 工具的开发与优化工作 组件库小组 标准组件库的规范制定、 文档编写， 标准组件库在不同端的实现， 标准组件库官网建设 运行框架小组 负责不同端运行框架的实现 端能力 API 小组 端能力 API 的规范制定、 端能力 API 的文档编写， 端能力 API 在不同端的实现 UI 库小组 负责 Dbox UI 库的实现 社区维护小组 社区内答疑解惑， GitHub ISSUE 维护， 问题搜集， 社区项目发起与引导， 第三方库适配与生态管理等","tags":[]},{"title":"如何做一个 Github 开源项目","date":"2018-12-23T01:44:09.000Z","path":"2018/12/23/如何做一个 Github 开源项目/","text":"适合开源 整理收藏的 Markdown 笔记 框架全家桶的脚手架搭建 炫酷的动画效果 各种工具库、框架 cache工具(缓存工具，整合localStorage,以及合理的内存销毁机制) query2json,解析url参数为json格式 移动端打印console.log,方便移动端输出内容 版本号 一级：重构版本 二级：重大功能改进 三级：小升级或者bug修复 0.X.X: 非正式版本Semantic Versioning使用 semantic-release 实现全自动更新版本号和发布，这个工具会判断 Commit Message 的不同，fix 增加修订号，feat 增加次版本号，而包含 BREAKING CHANGE 的提交增加大版本号。 开源协议开源协议是软件的授权许可，表述了用户获得你开源的代码后拥有的权利和义务，可以参考Choose an open source license | Choose a License 规范提交记录方便使用工具根据提交记录自动生成更新说明 (CHANGELOG)Angular 规范 (Git Commit Message Conventions ) 12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;body&gt;&lt;footer&gt; commitizen : 进行交互式的 Commit 填写，如下图所示，只需要按照提示选择更新的 type 和填写必要的信息，就能自动生成符合规范的提交记录；@semantic-release/changelog: 根据 Commit 中 type 自动增量生成 CHANGELOG 目录结构 src: 源代码 release: 发布结果 test：单元测试用例 doc: 文档 example：实例 Readme 产品简介(此处要突出特点，打差异化竞争) 产品安装和下载 快速使用(详细的使用文档或者二次开发文档，外链即可) 交流提问区(QQ、微信群) 关于作者(博客链接和收款二维码) 最好有英文版本 文档和测试用例1234npm i gitbook-cli -gSUMMARY.mdgitbook initgitbook build 配置.gitignore加上_book 静态网站部署 github pages: 将网站名称改为docs，静态资源路径容易出问题，因为引用的资源会在启动服务器的根目录(docs)寻找，而不是在相对路径 ./docs里面寻找 购置一个服务器、域名，将我们的代码推到服务器上，从域名中访问。 Netlify：免费 发布npm模块123npm add usernpm loginnpm publish . 不能重名 升级 新建分支 修改版本号 修改代码、文档和测试用例 自测 将新的分支提交到远程 再次确认版本号，因为版本号非常重要 将新的分支合并到master，并提交master到远程 创建tag并提交到远程 提交到npm 宣传一个公司的核心竞争力，一是技术，二是营销。 npmjs.com 展示下载量变化的折线图bestofjs.org 展示了项目 Star 数变化的日历色块图 博客围绕产品功能第一类技术干货文章第二类产品介绍以第一类为主 如何 坑 预防 总结 半年记 回答相关的问题 知乎 sf.gg stackoverflow 字数只能多不能少，最好图文并茂，还能讲个笑话 回答要专业，经过亲自测试，不要想当然的瞎猜 回答问题的最后，顺便推广自己的产品 需求采纳 很多用户都提过这个需求，即大众需求 自己判断这个需求对大部分用户都有用 该需求符合产品定位以及产品发展的方向 该需求能抹平和竞品的差距，或者能和竞品差异化竞争","tags":[]},{"title":"微博运营","date":"2018-12-23T01:42:52.000Z","path":"2018/12/23/微博运营/","text":"微博运营 微博重点扶持行业：母婴、金融、汽车、美妆、饮料等 要想有粉丝 》要先有曝光 》先有流量 平台根据用户反馈给内容分配流量：微博是通过1个小时内评判流量是否倾斜 符合平台运营的基本规范 + 生产用户喜欢的优质内容 微博加权规则 账号因素： 认证：媒体账号 会员 绑定手机号 丰富账号信息 内容因素：热门话题 | 九图 | 头条文章 | 视频 微博降权 不被推荐到热门流 减少部分曝光量 减少大部分曝光量 封号 向外引流：微信 | 抖音 广告关键词： 易导致账号被降权，降低在热门展现的几率或者是禁止展现 “购买” “优惠” “券”等 淘宝 | 京东 | 亚马逊 | 。。。| 5 折。。。都要避免 电商领域会有外链的特权 微博向微信引流 将微信号插在图片，被监测的几率相对较低 设置私信自动回复，用“VX”字样 微博蹭热搜、公众号蹭热点 选择可蹭的话题 撰写蹭热文案：关键词必须相同、完全关联，且要保证文案的相关性 长文关注： 新账号扶植功能，仅粉丝可阅读全文，否则需关注账号看全文 总粉丝两万以下的账号有此功能，一旦突破，功能自动取消 利用大 V 流量增粉 找垂直领域大V 谈价格 写文章 资源公众号运营工具导航微信机器人：https://github.com/Hanson/vbot","tags":[]},{"title":"this 指向","date":"2018-12-23T01:30:22.000Z","path":"2018/12/23/this 指向/","text":"this 介绍this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境 this 的指向 作为对象的方法调用：指向该对象 作为普通函数调用：指向全局对象(严格模式下：undefined) 构造器调用: 指向new出来的实例对象 Function.prototype.call 或 Function.prototype.apply 调用：动态绑定的对象 document.getElementById()的内部实现中需要用到 this，并且这个 this 被期望指向 document 123456789document.getElementById = ( function(func) &#123; return function() &#123; return func.apply(document, arguments) &#125; &#125;)(document.getElementById)var getId = document.getElementById call &amp;&amp; apply 传入的第一个参数为null, 函数体内的 this 会指向默认的宿主对象，在浏览器中则是window.但是在严格模式下，函数体内的 this 还是为 null 有时候使用 call 或 apply 的目的不在于指定 this 指向，而是借用其他对象的方法 如 Math.max.apply(null, [1,2,3,4,5]) 等同于 Math.max(...[1,2,3,4,5]) 改变this的指向123456789101112131415161718Function.prototype.bind = function() &#123; var self = this // 保存原函数 var context = [].shift.call(arguments) // 需要绑定的 this 上下文 var args = [].slice.call(arguments) // 剩余的参数转成数组 return function() &#123; // 返回一个新的函数 return self.apply(context, [].concat.call(args, [].slice.call(arguments))) // 执行新的函数的时候，会把之前传入的context当作新函数体内的this // 并且组合两次分别传入的参数，作为新函数的参数 &#125;&#125;var obj = &#123; name: 'lulu'&#125;var func = function(a, b, c, d) &#123; alert(this.name) alert([a, b, c, d])&#125;.bind(obj, 1, 2)func(3, 4) 借用其他对象的方法 借用构造函数从而实现一些类似继承的效果 1234567891011var A = function(name)&#123; this.name = name&#125;var B = function() &#123; A.apply(this, arguments)&#125;B.prototype.getName = function(name) &#123; return this.name&#125;var b = new B('lulu')console.log(b.getName()) // lulu 操作arguments对象时借用Array.prototype上的方法 向 arguments 中添加一个新的元素：Array.prototype.push.call(arguments, …) 把 arguments 转换成一个真的数组：Array.prototype.slice.call(arguments) 截去 arguments 的头一个元素：Array.prototype.shift.call(arguments) 1234(function() &#123; Array.prototype.push.call(arguments, 3) console.log(arguments) // [1,2,3]&#125;)(1,2) 12345678910// V8 源码实现上面的代码function ArrayPush () &#123; var n = TO_UINT32(this.length) // 被 push 的对象的 length var m = %_ArgumentsLength() // push 的参数个数 for (var i = 0; i &lt; m; i++) &#123; this[n + i] = %_Arguments[i] // 对象本身要可以存取属性 &#125; this.length = n + m // 修正 length 属性的值 return this.length // 对象的 length 属性要可读写&#125;","tags":[]},{"title":"闭包和高阶函数","date":"2018-12-23T01:04:56.000Z","path":"2018/12/23/闭包和高阶函数/","text":"closure看是否对自由变量进行了捕获 变量作用域 函数作用域 全局作用域 作用域链：变量的搜索从内而外。函数像一层半透明的玻璃，在函数里面可以看到函数外面的变量，而函数外面则无法看到函数里面的变量 变量的生命周期 全局变量：永久，除非主动销毁 局部变量：退出函数时就没有了价值，即随着函数调用的结束而被销毁 闭包的作用 封装变量 延续局部变量的寿命 12345678910111213// 然而闭包可以延续局部变量的生命周期var func = function() &#123; var a = 1; return function() &#123; a++; alert(a) &#125;&#125;var f = func()f() // 2f() // 3f() // 4f() // 5 当退出函数时，局部变量a并没有消失，而是似乎一直在某个地方存活着。这是因为当执行var f = func()时，f返回了一个匿名函数的引用，它可以访问到func()被调用时产生的环境，而局部变量a一直处在这个环境里。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。 1234567891011var Type = &#123;&#125;for (var i = 0; type = ['String', 'Array', 'Number']; i++) &#123; (function(type)&#123; Type[`is$&#123;type&#125;`] = function(obj) &#123; return Object.prototype.toString.call(obj) === '[object $&#123;type&#125;]' &#125; &#125;)(type)&#125;Type.isArray([])Type.isString('str') 1234567891011121314// 对于相同的参数来说，每次都进行计算时一种浪费，引入缓存机制提高函数性能var cache = &#123;&#125;;function mult() &#123; var args = Array.prototype.join.call(arguments, ',') if (cache[args]) return cache[args] var result = 1 for (var i = 0; i &lt; arguments.length; i++) &#123; result = result * arguments[i] &#125; return cache[args] = result&#125;console.log(mult(1, 2, 3)) // 6console.log(mult(1, 2, 3)) // 6console.log(cache) 代码重构：1. 去掉全局变量 2. 独立可复用的代码12345678910111213141516171819202122var mult = ( function()&#123; var cache = &#123;&#125;; return function () &#123; var args = Array.prototype.join.call(arguments, ',') if (cache[args]) return cache[args] // return cache[args] = calculate.apply(null, arguments) // null 即 windows 对象 return cache[args] = calculate(...arguments) &#125; &#125;)()var calculate = function () &#123; var result = 1 for (var i = 0; i &lt; arguments.length; i++) &#123; result = result * arguments[i] &#125; return result&#125;console.log(mult(1, 2, 3)) // 6console.log(mult(1, 2, 3)) // 6 12345678var report = function (src) &#123; var imgs = [] return function(src)&#123; var img = new Image() imgs.push(img) img.src = src &#125;&#125; 面向对象设计 过程与数据的结合是形容面向对象中的“对象”时经常使用的表达对象以方法的形式包含了过程而闭包则是在过程中以环境的形式包含了数据 12345678910111213// 闭包var extent = function() &#123; var value = 0 return &#123; call: function() &#123; value++ console.log(value) &#125; &#125;&#125;var extent = extent()extent.call()extent.call() 1234567891011// 面向对象var extent = &#123; value: 0, call: function() &#123; this.value++ console.log(this.value) &#125;&#125;extent.call() // 1extent.call() // 2extent.call() // 3 123456789101112// 构造函数var Extent = function() &#123; this.value = 0&#125;Extent.prototype.call = function() &#123; this.value++ console.log(this.value)&#125;var extent = new Extent()extent.call() // 1extent.call() // 2extent.call() // 3 用闭包实现命令模式命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者(执行者)之间的耦合关系。在命令被执行之前，可以预先往命令对象中植入命令的接收者。12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;div&gt; &lt;button id=\"execute\"&gt;点我执行命令&lt;/button&gt; &lt;button id=\"undo\"&gt;点我执行命令&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var Tv = &#123; open: function() &#123; console.log('打开电视机') &#125; close: function() &#123; console.log('关上电视机') &#125; &#125; var OpenTvCommand = function(receiver) &#123; this.receiver = receiver &#125; OpenTvCommand.prototype.execute = function() &#123; this.receiver.open() // 执行命令，打开电视机 &#125; OpenTvCommand.prototype.undo = function() &#123; this.receiver.close() // 执行命令，关闭电视机 &#125; var setCommand = function(command) &#123; document.getElementById('execute').onclick = function() &#123; command.execute() &#125; document.getElementById('undo').onclick = function() &#123; command.undo() &#125; &#125; setCommand(new OpenTvCommand(Tv)) &lt;/script&gt;&lt;/body&gt; 12345678910111213141516171819202122232425262728293031&lt;script type=\"text/javascript\"&gt; var Tv = &#123; open: function() &#123; console.log('打开电视机') &#125; close: function() &#123; console.log('关上电视机') &#125; &#125; var createCommand = function(receiver) &#123; var execute = function() &#123; return receiver.open() // 执行命令，打开电视机 &#125; var undo = function() &#123; return receiver.close() // 执行命令，关闭电视机 &#125; return &#123; execute: execute, undo: undo &#125; &#125; var setCommand = function(command) &#123; document.getElementById('execute').onclick = function() &#123; command.execute() &#125; document.getElementById('undo').onclick = function() &#123; command.undo() &#125; &#125; setCommand(createCommand(Tv)) &lt;/script&gt; 闭包与内存管理局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的。如果在将来需要回收这些变量，可以手动把这些变量设为null 使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些DOM节点，就有可能造成内存泄露。在IE浏览器中，由于 BOM 和 DOM 中的对象是使用 C++ 以 COM 对象的方式实现的，而 COM 对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收。 高阶函数 函数可以作为参数被传递 函数可以作为返回值输出 作为参数被传递分离业务代码中变化和不变的部分 回调函数 异步请求 当一个函数不适合执行一些请求时，可以把这些请求封装成一个函数，“委托”给另外一个函数来执行 作为返回值输出123456789101112var getSingle = function(fn) &#123; var ret return function() &#123; return ret || (ret = fn.apply(this, arguments)) &#125;&#125;var getScript = getSingle(function() &#123; return document.createElement('script')&#125;)var script1 = getScript()var script2 = getScript()alert(script1 === script2) // true 高阶函数实现AOPAOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。123456789101112131415161718192021222324252627Function.prototype.before = function(beforefn) &#123; var _self = this // 保存原函数的引用,this 值是func -&gt; &#123;console.log(2)&#125; return function() &#123; // 返回包含了原函数和新函数的“代理”函数 beforefn.apply(this, arguments) // 执行新函数，修正this,this是window return _self.apply(this, arguments) // 执行原函数 &#125;&#125;Function.prototype.after = function(afterfn) &#123; var _self = this // this 值是“代理”函数 return function() &#123; var ret = _self.apply(this, arguments) afterfn.apply(this, arguments) return ret &#125;&#125;var func = function() &#123; console.log(2) return 2&#125;func = func.before(function() &#123; console.log(1) return 1&#125;).after(function() &#123; console.log(3) return 3&#125;)func() currying一个柯里化的函数首先会接受一些参数，接受了这些参数之后，该参数并不会立即求值，而是继续返回另一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值 12345678910111213141516171819var cost = ( var args = [] return function()&#123; if (arguments.length === 0)&#123; var money = 0 for(var i = 0; i &lt; args.length; i++) &#123; money += args[i] &#125; return money &#125; else &#123; [].push.apply(args, arguments) &#125; &#125;)()cost(100) // 未真正求值cost(200) // 未真正求值cost(300) // 未真正求值console.log(cost()) 1234567891011121314151617181920212223242526272829var currying = function(fn) &#123; var args = [] return function() &#123; if(arguments.length === 0)&#123; return fn.apply(this, args) &#125; else &#123; [].push.apply(args, arguments) console.log('arguments', arguments, arguments.callee ) return arguments.callee &#125; &#125;&#125;var cost = (function()&#123; var money = 0 return function()&#123; for (var i = 0; i &lt; arguments.length; i++) &#123; money += arguments[i] &#125; return money &#125;&#125;)()var cost = currying(cost)cost(100) // 未真正求值cost(200) // 未真正求值cost(300) // 未真正求值alert(cost()) // 求值并输出： 600 1234567891011121314Function.prototype.uncurrying = function() &#123; var self = this console.log(this) return function() &#123; var obj = Array.prototype.shift.call(arguments) console.log(arguments) return self.apply(obj, arguments) &#125;&#125;var push = Array.prototype.push.uncurrying()(function()&#123; push(arguments, 4) console.log(arguments)&#125;)(1,2,3) 123456Function.prototype.uncurrying = function() &#123; var self = this return function() &#123; return Function.prototype.call.apply(self, arguments) &#125;&#125; 1234567891011121314151617181920Function.prototype.uncurrying = function() &#123; var self = this return function() &#123; var obj = Array.prototype.shift.call(arguments) return self.apply(obj, arguments) &#125;&#125;var Arg = &#123;&#125;for (var i = 0, fn, arr = ['push', 'shift', 'forEach']; fn = arr[i++];) &#123; console.log(fn) Arg[fn] = Array.prototype[fn].uncurrying()&#125;var obj = &#123; 'length': 3, '0': 1, '1': 2, '2': 3&#125;Arg.push(obj, 4) // 向对象中添加一个元素console.log(obj.length) // 4 函数节流有些情况下，函数的触发不是由用户直接控制的，这样当函数被非常频繁的调用时，会造成大的性能问题。 场景 window.onresize()：给window对象绑定了resize事件，当浏览器窗口大小被拖动而改变的时候，这个事件触发的频率非常之高。如果我们在window.onresize事件函数里有一些跟DOM节点相关的操作，而跟DOM节点相关的操作往往是非常消耗性能的，这时候浏览器可能就会吃不消而造成卡顿现象。 mousemove()：同样，给一个div节点绑定了拖拽事件(主要是mousemove),div节点被拖动的时候，也会频繁地触发该拖拽事件函数 上传进度：微云的上传功能使用了一个浏览器插件。该插件在真正开始上传文件之前，会对文件进行扫描并随时通知JS函数，以便在页面中显示当前的扫描进度。但该插件通知的频率非常之高，约10s一次 原理当函数被触发的频率太高时，需要按时间段来忽略掉一些事件请求，借助setTimeout来完成 将即将被执行的函数用setTimeout延迟一段时间执行。如果该次延迟执行还没有完成，则忽略接下来调用该函数的请求 一定要等当前执行的事件执行完了，才会让新的事件进来，否则全部作废 12345678910111213141516171819202122232425var throttle = function(fn, interval) &#123; var _self = fn, // 保存需要被延迟执行的函数引用 timer, // 定时器 firstTime = true; // 是否是第一次调用 return function() &#123; var args = arguments, _me = this; if (firstTime) &#123; // 如果是第一次调用，不需要延迟执行 _self.apply(_me, args) return firstTime = false &#125; if (timer) &#123; // 如果定时器还在，说明前一次延迟执行还没有完成 return false &#125; timer = setTimeout(function() &#123; // 延迟一段时间执行 clearTimeout(timer) timer = null _self.apply(_me, args) &#125;, interval || 500) &#125;&#125;window.onresize = throttle(function() &#123; console.log(1)&#125;, 500) 函数防抖12 场景 搜索引擎搜索：希望用户在输入完最后一个字才调用查询接口，适用延迟执行的防抖函数， 分时函数在短时间内大量触发请求会严重影响页面性能，解决方案之一是让这些请求分批进行，比如把1秒钟创建1000个节点，改为每隔200毫秒创建8个节点 1234567891011121314151617181920212223// 创建节点时需要用到的数据// 封装了创建节点逻辑的函数// 每一批创建的节点数量var timeChunk = function(ary, fn, count) &#123; var obj, t var len = ary.length var start = function () &#123; for (var i = 0; i &lt; Math.min(count || 1, ary.length); i++) &#123; var obj = ary.shift() fn(obj) &#125; &#125; return function() &#123; t = setInterval(function() &#123; if (ary.length === 0) &#123; // 如果全部节点都已经被创建好 return clearInterval(t) &#125; start() &#125;, 200) // 分批执行的时间间隔，也可以用参数的形式传入 &#125;&#125; 资源7分钟理解JS的节流、防抖及使用场景","tags":[]},{"title":"消息机制","date":"2018-12-23T00:52:20.000Z","path":"2018/12/23/消息机制/","text":"消息机制是软件工程中一个普遍运用的工程思想。 “设计模式”中的观察者模式 Windows 操作系统底层 Spring 框架中的 ApplicationListener 模块 Objective-C 语言中的函数调用都是通过消息机制驱动的。 使用消息机制最大的好处在于可以做到业务模块间安全解耦，模块间通过发送消息的方式进行协作。 非消息机制案例我们先举一个后端开发中的例子，下图是一个简单的预定系统的建模图，并没有使用消息机制： 在没有消息机制的情况下，用户模块需要知道订单模块的存在，并向其进行接口调用，同理订单模块需要向支付模块进行接口调用。这种设计下模块间是耦合的。 消息机制案例 上图中，无论是客户下订单、支付还是预定都是通过消息的方式传递的，每个模块都是向一个消息处理器起发消息，同时也监听消息处理器发送回来的消息。在这种模式下，模块完全不知道其它模块的存在，彻底做到了解耦。 消息机制在前端中的应用在前端业务开发中，我们经常也会用到 EventEmitter 库来进行消息传递。比如页面上有两块区域，一块用 React 框架渲染，一块用 D3 渲染的，当两块区域需要数据同步时，就可以使用消息机制进行通讯，保证页面数据整体一致。 如果你的业务中有不同生命周期的组件，建议采用消息机制进行管理，不仅消除了耦合，逻辑关系部分的代码也集中到了一个文件中，内聚性得到了提升。 使用消息机制的一个附属产物就是中间件，我们可以为消息定制各种中间件，在中间中完成一些通用逻辑，让业务代码更精炼。 说到前端框架中消息机制的运用，当然首推 Redux 框架，在 Redux 框架中，任何数据交互都需要先转化为一个 action，由 action 去触发 reducer 和相关的 middleware 处理 action，改变数据，最终同步到页面 UI 上，如下图所示：","tags":[]},{"title":"设计模式及设计原则","date":"2018-12-23T00:47:22.000Z","path":"2018/12/23/设计模式及设计原则/","text":"面向对象 三要素 继承：子类继承父类 封装：数据的权限和保密 多态：同一接口不同实现 123456789101112131415161718192021222324252627282930313233// 父类class People &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; eat() &#123; alert(`$&#123;this.name&#125; eat something`) &#125; speak() &#123; alert(`$&#123;this.name&#125;: age $&#123;this.age&#125;`) &#125;&#125;// 子类继承父类class Student extends People &#123; constructor(name, age, number)&#123; super(name, age) this.number = number &#125; study() &#123; alert(`$&#123;this.name&#125; study`) &#125;&#125;// 实例let xiaoming = new Student('xiaoming', 10, 'A1')xiaoming.study()xiaoming.eat()let wangxin = new Student('wangxin', 10, 'A2')wangxin.study()wangxin.speak() 继承* People是父类，公共的，不仅仅服务于Student * 继承可将公共方法抽离出来，提高复用，减少冗余 封装(ES6尚不支持，TS支持) 定义属性关键字： * public: 完全开放；前面如果不写关键字，那么默认是public * protected: 对子类开放 * private: 对自己开放 [TypeScript](http://www.typescriptlang.org/play/index.html) 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 父类class People &#123; name age protected weight // 对子类开放 constructor(name, age) &#123; this.name = name this.age = age this.weight = 120 &#125; eat() &#123; alert(`$&#123;this.name&#125; eat something`) &#125; speak() &#123; alert(`$&#123;this.name&#125;: age $&#123;this.age&#125;`) &#125;&#125;// 子类继承父类class Student extends People &#123; number private girlFriend constructor(name, age, number)&#123; super(name, age) this.number = number this.girlfriend = 'lu' &#125; study() &#123; alert(`$&#123;this.name&#125; study`) &#125; getWeight() &#123; alert(`weight: $&#123;this.weight&#125;`) &#125;&#125;// 实例let xiaoming = new Student('xiaoming', 10, 'A1')xiaoming.study()xiaoming.eat()xiaoming.getWeight()xiaoming.girlFriend // 编译时会报错，直接会编译不通过！！！let wangxin = new Student('wangxin', 10, 'A2')wangxin.study()wangxin.speak() * 减少耦合，不该外露的不外露 * 利于数据、接口的权限管理 * ES6 不支持，一般认为以\\_开头的属性是 private 多态* 同一个接口，不同表现 * JS应用极少 * 需要结合java等语言的接口、重写、重载等功能 12345678910111213141516171819202122232425262728293031// 父类class People &#123; constructor(name, age) &#123; this.name = name this.age = age this.weight = 120 &#125; saySomething() &#123; &#125;&#125;class A extends People &#123; constructor(name) &#123; super(name) &#125; saySomething() &#123; alert(`I am A : $&#123;this.name&#125;`) &#125;&#125;class B extends People &#123; constructor(name) &#123; super(name) &#125; saySomething() &#123; alert(`I am B : $&#123;this.name&#125;`) &#125;&#125;let a = new A('a')a.saySomething()let b = new B('b')b.saySomething() * 保持子类的开放性和灵活性 * 面向接口编程 * JS引用极少，了解即可 jQuery 应用举例* jQuery是一个class * \\$(&apos;p&apos;)是jQuery的一个实例 1234567891011121314151617181920212223242526272829303132333435class jQuery &#123; constructor(selector) &#123; let slice = Array.prototype.slice let dom = slice.call(document.querySelectorAll(selector)) let len = len ? dom.length : 0 for (let i = 0; i &lt; len; i++) &#123; this[i] = dom[i] &#125; this.length = len this.selector = selector || '' &#125; append(node) &#123; // ... &#125; addClass(name) &#123; // ... &#125; html(data) &#123; // ... &#125; // ...&#125;window.$ = function(selector) &#123; // 工厂模式 return new jQuery(selector)&#125;// 测试代码var $p = $('p')console.log($p)console.log($p.addClass) 为何使用面向对象？* 程序执行：顺序、判断、循环 ———— 结构化 * 面向对象 ———— 数据结构化 * 对于计算机，结构化的才是最简单的 * 编程：简单 &amp; 抽象 UML 类图* Unified Modeling Language : 统一建模语言 * UML包含很多种图，本章相关的是类图 * 关系 * 泛化：继承;空箭头 * 关联：引用: People 引用 House；实心箭头 * 演示，代码和类图的结合 * MS Office Visio * [ProcessOn](https://www.processon.com/) 123456789101112131415161718192021222324252627282930313233343536373839// 父类class People &#123; constructor(name, house) &#123; this.name = name this.house = house &#125; saySomething() &#123; &#125;&#125;class A extends People &#123; constructor(name, house) &#123; super(name, house) &#125; saySomething() &#123; alert(`I am A : $&#123;this.name&#125;`) &#125;&#125;class B extends People &#123; constructor(name, house) &#123; super(name, house) &#125; saySomething() &#123; alert(`I am B : $&#123;this.name&#125;`) &#125;&#125;class House &#123; constructor(city) &#123; this.city = city &#125; showCity() &#123; alert(`house in : $&#123;this.name&#125;`) &#125;&#125;let ahouse = new House('beijing')let a = new A('a', ahouse)a.saySomething()let b = new B('b')b.saySomething() 类图 * 类名 * 所有的属性：public 属性名A：类型 * 所有的方法：public 方法名A(参数1，参数2)：返回值类型 * &apos;+&apos;: public * &apos;#&apos;: protected * &apos;-&apos;: private 设计原则 何为设计？ 即按照哪一种思路或者标准来实现功能 功能相同，可以有不同设计方案来实现 伴随着需求增加，设计的作用才能体现出来 《LINUX/UNIX设计哲学》 小即是美 让每个程序只做好一件事 快速建立原型 舍弃高效率而取可移植性(效率会因为硬件的升级而被抹平) 采用纯文本来存储数据 充分利用软件的杠杆效应(软件复用) 使用shell脚本来提高杠杆效应和可移植性 避免强制性的用户界面 让每个程序都成为过滤器 小准则： 允许用户定制环境 尽量使操作系统内核小而轻量化 使用小写字母并尽量简写 沉默是金 各部分之和大于整体 寻求90%的解决方案 1ls | grep *.json | grep 'package' 5大设计原则* Single: 单一职责原则 * 一个程序只做好一件事 * 如果功能过于复杂 * Open: 开放封闭原则 * 对扩展开放，对修改封闭 * 增加需求时，拓展新代码，而非修改已有代码 * 这是软件设计的终极目标 * L: 李氏置换原则 * 子类能覆盖父类 * 父类能出现的地方子类就能出现 * JS中使用较少(弱类型 &amp; 继承使用较少) * Interface: 接口独立原则 * 保持接口的单一独立，避免出现“胖接口” * JS中没有接口(TS例外)，使用较少 * 类似于单一职责原则，这里更关注接口 * Dependence: 依赖倒置原则 * 面向接口编程，依赖于抽象而不依赖于具体 * 使用方只关注接口而不关注具体类的实现 * JS中使用较少(没有接口 &amp; 弱类型) 123456789101112131415161718192021222324function loadImg(src) &#123; return new Promise((resolve, reject) =&gt; &#123; let img = document.createElement('img') img.onload = () =&gt; &#123; resolve(img) &#125; img.onerror = () =&gt; &#123; reject('图片加载失败') &#125; img.src = src &#125;)&#125;let src = './img.png'let result = loadImg(src)result.then((img) =&gt; &#123; alert(`width: $&#123;img.width&#125;`) return img &#125;).then((img) =&gt; &#123; alert(`height: $&#123;img.height&#125;`) &#125;).catch((err) =&gt; &#123; console.log(err)&#125;) 从设计到模式* 设计：指导思想 * 模式：结合日常开发总结出固定的模板 23种设计模式 * 创建型 * 组合型 * 行为型 面试题&gt; 打车时，可以打专车或者快车； &gt; 任何车都有车牌号和名称； &gt; 不同车价格不同，快车1元/km，专车2元/km； &gt; 行程开始时，显示车辆信息； &gt; 行程结束时，显示打车金额(假定行程就5km)。 12345678910111213141516171819202122232425262728293031323334class Car &#123; constructor(number, name) &#123; this.number = number this.name = name &#125;&#125;class KuaiChe extends Car &#123; constructor(number, name) &#123; super(number, name) this.price = 1 &#125;&#125;class ZhuanChe extends Car &#123; constructor(number, name) &#123; super(number, name) this.price = 2 &#125;&#125;class Trip &#123; constructor(car) &#123; this.car = car &#125; start() &#123; console.log(`行程开始 名称：$&#123;this.car.name&#125; 车牌号：$&#123;this.car.number&#125;`) &#125; end() &#123; console.log(`行程结束 价格：$&#123;this.car.price&#125; * 5`) &#125;&#125;let car = new KuaiChe(100, '桑塔纳')let trip = new Trip(car)trip.start()trip.end() &gt; 某停车场，分3层，每层100车位； &gt; 每个车位都能监控到车辆的驶入和离开； &gt; 车辆进入前，显示每层的空余车位数量； &gt; 车辆进入时，摄像头可识别车牌号和时间； &gt; 车辆出来时，出口显示器显示车牌号和停车时长。 &gt; 设计模式 优先级：创建型 | 结构型 | 行为型 结合核心技术 结合框架应用 综合示例 设计方案 代码演示 设计模式对应（7种）","tags":[]},{"title":"穿搭篇","date":"2018-12-22T10:10:59.000Z","path":"2018/12/22/穿搭篇/","text":"血管颜色手腕内侧血管颜色偏蓝紫：冷色调 冷色调：带红感的肤色 穿金戴银冷色调：银色 白色上身冷色调：纯白色比乳白色更好 衣服颜色搭配属于冷基调的人适合：以蓝色为基调的颜色，红色是偏紫的红，如玫红色；不适合橙，黄。适合偏蓝的黄如柠檬黄；绿偏蓝的绿。蓝色和紫色非常适合冷皮的妹子。（灰色非常适合皮肤白皙的妹子穿！） 色彩分配原则 整体性：全身整体围绕一个主色调展开，用同色系不同明度饱和度的颜色搭出层次感 配饰类：饰品，鞋等颜色上相互呼应 细节：靠近面部位置的配饰如围巾耳环帽子，避免冷色。 上冷 + 下暖 口红偏紫红色口红比橘色口红更适合 冷色调冷色调包括大热的冰淇淋色、婴儿蓝、樱花粉，偏紫的红等等。","tags":[]},{"title":"代码观","date":"2018-12-22T09:58:39.000Z","path":"2018/12/22/代码观/","text":"代码要清晰地表达意图 代码是给人读的，不要耍小聪明。 用代码沟通 注释的艺术。 动态地进行取舍 记住，没有最佳解决方案。各种目标不可能面面俱到，关注对用户重要的需求。 增量式编程 写一点代码就构建、测试、重构、休息。让代码干净利落。 尽量简单 宁简勿繁。如果没有充足的理由，就不要使用什么模式、原则和特别的技术。 编写内聚的代码 类和组件应该足够小，任务单一。 告知，不要询问 多用消息传递，少用函数调用。 根据契约进行替换 委托往往优于继承 记录问题解决日志 不要在同一地方摔倒两次。错误是最宝贵的财富。 警告就是错误 忽视编译器的警告可能铸成大错。 对问题各个击破 分而治之是计算机科学中最重要的思想之一。但是，要从设计和原型阶段就考虑各部分应该能够很好地分离。 报告所有的异常 提供有用的错误信息 稍微多花一点心思，出错的时候，将给你带来极大便利 准备好后再共享代码 不要提交无法编译或者没有通过单元测试的代码！ 做代码复查 复查对提高代码质量、减少错误极为重要。 及时通报进展与问题 主动通报，不要让别人来问你","tags":[]},{"title":"Awesome Frontend","date":"2018-12-22T09:21:05.000Z","path":"2018/12/22/Awesome Frontend/","text":"https://www.yuque.com/kobg2k/ipgh9u","tags":[]},{"title":"自动化部署","date":"2018-12-22T09:20:04.000Z","path":"2018/12/22/自动化部署/","text":"自动化部署三剑客Jenkins + Ansible + Gitlab 持续交付现场交付 =&gt; shell命令行 =&gt; 持续交付 版本控制系统：GitLab + GitHub 持续集成工具：Jenkins 部署工具(远程服务器端交付推送): Ansible + Saltstack + Chef GitLabGitLab 与 GitHub 的不同 GitHub：分布式在线代码托管仓库 个人版本可在线免费使用 企业版本收费且需要服务器安装 GitLab：分布式在线代码仓库托管软件 社区免费版本需要服务器安装 企业收费版本需要服务器安装 GitLab的优势和应用场景 开源免费，适合中小型公司将代码放置在该系统中 差异化的版本管理，离线同步以及强大分支管理功能 便捷的GUI操作界面以及强大账户权限管理功能 集成度很高，能够集成绝大多数的开发工具 支持内置HA，保证在高并发下仍旧实现高可用性 GitLab主要服务构成 Nginx静态Web服务器 GitLab-workhorse轻量级的反向代理服务器 Gitlab-shell用于处理Git命令和修改authorized keys列表 Logrotate日志文件管理工具 Postgresql数据库 Redis缓存服务器 Gitlab安装配置管理 利用VirtualBox创建测试服务器 安装Gitlab前系统预配置准备工作 关闭firewalld防火墙：保证本地PC可以访问虚拟机中的所有资源 # systemctl stop firewalld : 关闭当前正在运行的防火墙服务 # systemctl disable firewalld : 禁用防火墙开机启动 关闭SELINUX（强制访问控制安全策略）并重启系统：保证该策略不会影响Gitlab的正常运行 # vi /etc/sysconfig/selinux: 修改SELINUX=disabled # reboot: 重启系统，完成SELINUX的禁用操作 getenforce: 查看SELINUX是否已经被禁用 安装Omnibus Gitlab-ce package # yum -y install curl policycoreutils openssh-server openssh-clients postfix: 安装Gitlab组件 # curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash: 配置YUM仓库 sudo yum install postfix sudo systemctl enable postfix sudo systemctl start postfix: 启动postfix邮件服务 安装Gitlab-ce社区版本：# yum install -y gitlab-ce Omnibus Gitlab 等相关配置初始化并完成安装 证书创建与配置加载 创建本地私有密钥 mkdir -p /etc/gitlab/ssl openssl genrsa -out &quot;/etc/gitlab/ssl/gitlab.example.com.key&quot; 2048 openssl req -new -key &quot;/etc/gitlab/ssl/gitlab.example.com.key&quot; -out &quot;/etc/gitlab/ssl/gitlab.example.com.csr&quot; openssl x509 -req -days 365 -in &quot;/etc/gitlab/ssl/gitlab.example.com.csr&quot; -signkey &quot;/etc/gitlab/ssl/gitlab.example.com.key&quot; -out &quot;/etc/gitlab/ssl/gitlab.example.com.crt&quot; openssl dhparam -out /etc/gitlab/ssl/dhparams.pem 2048 更改证书权限：chmod 600 * Nginx SSL 代理服务配置 vi /etc/gitlab/gitlab.rb 修改 external_url &#39;https://gitlab.example.com&#39; 修改 nginx[&#39;/redirect_http_to_https&#39;] = true 修改 nginx[&#39;ssl_certificate&#39;] = &#39;/etc/gitlab/ssl/gitlab.example.com.crt&#39; 修改 nginx[&#39;ssl_certificate_key&#39;] = &#39;/etc/gitlab/ssl/gitlab.example.com.key&#39; 修改 nginx[&#39;ssl_dhparam&#39;] = &#39;/etc/gitlab/ssl/dhparams.pem&#39; vi /var/opt/gitlab/nginx/conf/gitlab-http.conf 找到 server_name gitlab.example.com,并在下面添加rewrite ^(.*)$ https://$host$1 permanent gitlab-ctl restart 编辑windows下的host文件，手动添加一条DNS记录10.110.16.20 gitlab.example.com 初始化Gitlab相关服务并完成安装 # gitlab-ctl reconfigure 资源Installation methods for GitLab","tags":[]},{"title":"React Router 4.0","date":"2018-12-22T09:16:12.000Z","path":"2018/12/22/React Router 4.0/","text":"路由使用场景 如果是功能复杂的网站，建议后端路由，不建议大型网站用前端路由，太重（通常来说就是整个网站，也可以是功能单一的大型网站，比如携程这样的） 功能单一的网站，比如webapp那种，建议前端路由（通常说的单页应用SPA） 页面有很多组件复用的情况，建议前端路由（如果页面功能复杂，参考第一条） 无所谓前端还是后端路由的网站，比如后台管理系统，那就前端路由吧，毕竟无论是Vue还是React,都有好几个搭配的UI库，前端路由会比较顺心 功能太简单的网站，简单到就几个静态页面，前端路由、后端路由均可，甚至不需要路由 前端路由不能做SEO 事情没有绝对性，任何前端路由的网站肯定能用后端路由实现，反之亦然 可以把项目按不同的需求拆分开，有些部分后台路由，部分前端路由也可。 Router原理 历史：入栈 | 出栈，记录跳转关系还能原路跳转回去的机制 跳转：可以传递参数，负责不同页面的跳转动作 事件：打开一个新页面或者退回到上一个页面时触发的逻辑 原生路由方法 window.location window.location.pathname window.location.search 页面路由window.location.href = ‘/test’ // 页面路由history.back() // 出栈 hash路由window.location.hash = ‘#test’// hash值变化时执行的回调函数window.onhashchange = () =&gt; (console.log(‘current router’, window.location.hash)) H5路由history.pushState(name, title, toPath) // 入栈history.replaceState(name, title, toPath) // 不会更改历史记录，替换当前状态值// 出栈时执行的回调函数window.onpopstate = (e) =&gt; (console.log(‘h5 router change’, e.state)) 常见Router 页面Router: 页面刷新 Hash Router: 页面不刷新，但是会改变url H5 Router: 既能操作Hash又能操作路径，兼容性差。和hash类似。页面不刷新，但是会改变url 相互独立的包yarn add react-router-dom@v4.2.2 react-router React Router 核心 react-router-dom 用于 DOM 绑定的 React Router react-router-native 用于 React Native 的 React Router react-router-redux React Router 和 Redux 的集成 react-router-config 静态路由配置的小助手 &lt;BrowserRouter&gt;用H5的方式来实现的 basename: string 作用：为所有位置添加一个基准UR 场景：需要把页面部署到服务器的二级目录12&lt;BrowserRouter basename=\"/minooo\" /&gt;&lt;Link to=\"/react\" /&gt; // 最终渲染为 &lt;a href=\"/minooo/react\"&gt; getUserConfirmation: func 作用：导航到此页面前执行的函数，默认使用 window.confirm 场景：当需要用户进入页面前执行什么操作时可用123456const getConfirmation = (message, callback) =&gt; &#123;const allowTransition = window.confirm(message)callback(allowTransition)&#125;&lt;BrowserRouter getUserConfirmation=&#123;getConfirmation('Are you sure?', yourCallBack)&#125; /&gt; forceRefresh: bool 作用：当浏览器不支持 HTML5 的 history API 时强制刷新页面12const supportsHistory = 'pushState' in window.history&lt;BrowserRouter forceRefresh=&#123;!supportsHistory&#125; /&gt; keyLength: number 作用：设置它里面路由的 location.key 的长度。默认是6。（key的作用：点击同一个链接时，每次该路由下的 location.key都会改变，可以通过 key 的变化来刷新页面。） 场景：按需设置 &lt;BrowserRouter keyLength={12} /&gt; children: node 作用：渲染唯一子元素 场景：作为一个 React组件，天生自带 children 属性 &lt;Route&gt;路由规则 自带三个 render method 和三个 props(match | location | history) 。 render method每种 render method 都有不同的应用场景，同一个 应该只使用一种 render method ，大部分情况下你将使用 component &lt;Route component&gt; 只有当访问地址和路由匹配时，一个 React component 才会被渲染，此时此组件接受 route props (match, location, history)。 当使用 component 时，router 将使用 React.createElement 根据给定的 component 创建一个新的 React 元素。这意味着如果你使用内联函数（inline function）传值给 component将会产生不必要的重复装载。对于内联渲染（inline rendering）, 建议使用 render prop。 1234&lt;Route path=\"/user/:username\" component=&#123;User&#125; /&gt;const User = (&#123; match &#125;) =&gt; &#123;return &lt;h1&gt;Hello &#123;match.params.username&#125;!&lt;/h1&gt;&#125; &lt;Route render&gt; 此方法适用于内联渲染，而且不会产生上文说的重复装载问题。 也可用于子路由 render方法会传入route的信息 12345678910111213// 内联渲染&lt;Route path=\"/home\" render=&#123;() =&gt; &lt;h1&gt;Home&lt;/h1&#125; /&gt;// 包装 组合const FadingRoute = (&#123; component: Component, ...rest &#125;) =&gt; (&lt;Route &#123;...rest&#125; render=&#123;props =&gt; ( &lt;FadeIn&gt; &lt;Component &#123;...props&#125; /&gt; &lt;/FadeIn&gt;)&#125; /&gt;)&lt;FadingRoute path=\"/cool\" component=&#123;Something&#125; /&gt; &lt;Route children&gt; 子路由：有时候只想知道访问地址是否匹配，然后改变下别的东西，而不是对应的整个页面 1234567891011&lt;ul&gt; &lt;ListIemLink to='somewhere' /&gt; &lt;ListIemLink to='somewhere-ele' /&gt;&lt;/ul&gt;const ListIemLink = (&#123;to, ...rest&#125;) =&gt; ( &lt;Route path=&#123;to&#125; children=&#123;(&#123;match&#125; =&gt; ( &lt;li className=&#123;match ? 'active' : ' '&#125;&gt; &lt;Link to=&#123;to&#125; &#123;...rest&#125; /&gt; &lt;/li&gt; ))&#125;&gt;&lt;/Route&gt;) path: string 任何可以被解析的有效URL路径 如果不给path，那么路由将总是匹配 exact: bool 精确匹配 path 为 ‘/one’ 的路由将不能匹配 ‘/one/two’，反之，亦然。所以在配子路由时千万注意不要配这个参数 strict: bool 对路径末尾斜杠的匹配。如果为 true。path 为 ‘/one/‘ 将不能匹配 ‘/one’ 但可以匹配 ‘/one/two’。 如果要确保路由没有末尾斜杠，那么 strict 和 exact 都必须同时为 true 为应用提供声明式，无障碍导航 to: string 作用：跳转到指定路径 场景：如果只是单纯的跳转就直接用字符串形式的路径。 to: object 作用：携带参数跳转到指定路径 场景：比如你点击的这个链接将要跳转的页面需要展示此链接对应的内容，又比如这是个支付跳转，需要把商品的价格等信息传递过去。 123456&lt;Link to=&#123;&#123; pathname: &apos;/course&apos;, search: &apos;?sort=name&apos;, state: &#123; price: 18 &#125;&#125;&#125; /&gt;&lt;Link to=&quot;/courses&quot; /&gt; replace: bool 为 true 时，点击链接后将使用新地址替换掉上一次访问的地址，什么意思呢，比如：你依次访问 ‘/one’ ‘/two’ ‘/three’ ’/four’ 这四个地址，如果回退，将依次回退至 ‘/three’ ‘/two’ ‘/one’ ，这符合我们的预期，假如我们把链接 ‘/three’ 中的 replace 设为 true 时。依次点击 one two three four 然后再回退会发生什么呢？会依次退至 ‘/three’ ‘/one’！ 场景：在用 路由 做选项卡时候会用到 &lt;NavLink&gt;为了实现页面导航的“激活状态”，是&lt;Link&gt;的特别版本 activeClassName: string 导航选中激活时候应用的样式名，默认样式名为 active 1234&lt;NavLink to=\"/about\" activeClassName=\"selected\"&gt;MyBlog&lt;/NavLink&gt; activeStyle: object 如果不想使用样式名就直接写style exact: bool 若为 true，只有当访问地址严格匹配时激活样式才会应用 strict: bool 若为 true，只有当访问地址后缀斜杠严格匹配（有或无）时激活样式才会应用 isActive: func 决定导航是否激活，或者在导航激活时候做点别的事情。不管怎样，它不能决定对应页面是否可以渲染。 &lt;Switch&gt;路由选项，解决路由多次匹配的问题只渲染出第一个与当前访问地址匹配的 &lt;Route&gt; 或 &lt;Redirect&gt;场景：对于转场动画非常适用，因为被渲染的路由和前一个被渲染的路由处于同一个节点位置！12345678910111213&lt;Fade&gt; &lt;Switch&gt; &#123;/* 用了Switch 这里每次只匹配一个路由，所有只有一个节点。 */&#125; &lt;Route/&gt; &lt;Route/&gt; &lt;/Switch&gt;&lt;/Fade&gt;&lt;Fade&gt; &lt;Route/&gt; &lt;Route/&gt; &#123;/* 不用 Switch 这里可能就会匹配多个路由了，即便匹配不到，也会返回一个null，使动画计算增加了一些麻烦。 */&#125;&lt;/Fade&gt; children: node &lt;Switch&gt; 下的子节点只能是 &lt;Route&gt; 或 &lt;Redirect&gt; 元素。只有与当前访问地址匹配的第一个子节点才会被渲染。&lt;Route&gt; 元素用它们的 path 属性匹配，&lt;Redirect&gt; 元素使用它们的 from 属性匹配。如果没有对应的 path 或 from，那么它们将匹配任何当前访问地址。 &lt;Redirect&gt;渲染时将导航到一个新地址，这个新地址覆盖在访问历史信息里面的本该访问的那个地址 to: string 重定向的 URL 字符串 to: object 重定向的 location 对象 push: bool 若为真，重定向操作将会把新地址加入到访问历史记录里面，并且无法回退到前面的页面。 from: string 需要匹配的将要被重定向路径 &lt;Prompt&gt;当用户离开当前页面前做出一些提示。 message: string 当用户离开当前页面时，设置的提示信息。 &lt;Prompt message=&quot;确定要离开？&quot; /&gt; message: func 当用户离开当前页面时，设置的回掉函数 &lt;Prompt message={location =&gt; (你确定要跳转到 \\${location.pathname}页面吗?)} /&gt; when: bool 通过设置一定条件决定是否启用Prompt history实现了对会话（session）历史的管理 “browser history” - history 在 DOM 上的实现，用于支持 HTML5 history API 的浏览器 “hash history” - history 在 DOM 上的实现，用于旧版浏览器。 “memory history” - history 在内存上的实现，用于测试或非 DOM 环境（例如 React Native） history的属性和方法 length: number 浏览历史堆栈中的条目数 action: string 路由跳转到当前页面执行的动作，分为 PUSH, REPLACE, POP location: object 当前访问地址信息组成的对象 pathname: string URL路径 search: string URL中的查询字符串 hash: string URL的 hash 片段 state: string 例如执行 push(path, state) 操作时，location 的 state 将被提供到堆栈信息里，state 只有在 browser 和 memory history 有效。 push(path, [state]) 在历史堆栈信息里加入一个新条目 replace(path, [state]) 在历史堆栈信息里替换掉当前的条目 go(n) 将 history 堆栈中的指针向前移动 n goBack() 等同于 go(-1) goForward 等同于 go(1) block(prompt) 阻止跳转 history 对象是可变的，因为建议从 的 prop 里来获取 location，而不是从 history.location 直接获取。这样可以保证 React 在生命周期中的钩子函数正常执行 location 当前的位置，将要去的位置，或是之前所在的位置 location 对象不会发生改变，因此可以在生命周期的回调函数中使用 location 对象来查看当前页面的访问地址是否发生改变。 场景：在获取远程数据以及使用动画时非常有用 123456789&#123; key: 'sdfad1' pathname: '/about', search: '?name=minooo' hash: '#sdfas', state: &#123; price: 123 &#125;&#125; 获取location对象 在 Route component 中，以 this.props.location 获取 在 Route render 中，以 ({location}) =&gt; () 方式获取 在 Route children 中，以 ({location}) =&gt; () 方式获取 在 withRouter 中，以 this.props.location 的方式获取 match 包含了 如何与 URL 匹配的信息 params: object 路径参数，通过解析 URL 中的动态部分获得键值对 isExact: bool 为 true 时，整个 URL 都需要匹配 path: string 用来匹配的路径模式，用于创建嵌套的 url: string URL 匹配的部分，用于嵌套的 当一个 Route 没有 path 时，它会匹配一切路径。 获取 match 对象 在 Route component 中，以 this.props.match获取 在 Route render 中，以 ({match}) =&gt; () 方式获取 在 Route children 中，以 ({match}) =&gt; () 方式获取 在 withRouter 中，以 this.props.match的方式获取 matchPath 的返回值 取路由中传入的参数值，即：传入的参数;带参数的路由一般放到最后，以避免冲突 this.props.match.param.id this.props.match.path code-splittingCode Spliting 是一个非常酷的特性，它能让我们用户无需完整下载整个 app 即可使用。你可以将他认为是增量加载我们的应用。尽管有一些其他工具也能实现相关特性，但在这个教程里我们使用 Webpack 和 bundle loader 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// Bundle.jsximport React from 'react';import PropTypes from 'prop-types';class Bundle extends React.Component &#123; state = &#123; // short for \"module\" but that's a keyword in js, so \"mod\" mod: null &#125; componentWillMount() &#123; // 加载初始状态 this.load(this.props); &#125; componentWillReceiveProps(nextProps) &#123; if (nextProps.load !== this.props.load) &#123; this.load(nextProps); &#125; &#125; load(props) &#123; // 重置状态 this.setState(&#123; mod: null &#125;); // 传入组件的组件 props.load((mod) =&gt; &#123; this.setState(&#123; // handle both es imports and cjs mod: mod.default ? mod.default : mod &#125;); &#125;); &#125; render() &#123; // if state mode not undefined,The container will render children return this.state.mod ? this.props.children(this.state.mod) : null; &#125;&#125;Bundle.propTypes = &#123; load: PropTypes.func, children: PropTypes.func&#125;;export default Bundle; 配置路由1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// RouteConfigExample.jsximport React from 'react'import &#123; BrowserRouter as Router, Route, Link&#125; from 'react-router-dom'// Some folks find value in a centralized route config.// A route config is just data. React is great at mapping// data into components, and &lt;Route&gt; is a component./// /////////////////////////////////////////////////////////// first our route componentsconst Main = () =&gt; &lt;h2&gt;Main&lt;/h2&gt;const Sandwiches = () =&gt; &lt;h2&gt;Sandwiches&lt;/h2&gt;const Tacos = (&#123; routes &#125;) =&gt; ( &lt;div&gt; &lt;h2&gt;Tacos&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to='/tacos/bus'&gt;Bus&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/tacos/cart'&gt;Cart&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &#123;routes.map((route, i) =&gt; ( &lt;RouteWithSubRoutes key=&#123;i&#125; &#123;...route&#125; /&gt; ))&#125; &lt;/div&gt;)const Bus = () =&gt; &lt;h3&gt;Bus&lt;/h3&gt;const Cart = () =&gt; &lt;h3&gt;Cart&lt;/h3&gt;/// /////////////////////////////////////////////////////////// then our route configconst routes = [ &#123; path: '/sandwiches', component: Sandwiches &#125;, &#123; path: '/tacos', component: Tacos, routes: [ &#123; path: '/tacos/bus', component: Bus &#125;, &#123; path: '/tacos/cart', component: Cart &#125; ] &#125;]// wrap &lt;Route&gt; and use this everywhere instead, then when// sub routes are added to any route it'll workconst RouteWithSubRoutes = (route) =&gt; ( &lt;Route path=&#123;route.path&#125; render=&#123;props =&gt; ( // pass the sub-routes down to keep nesting &lt;route.component &#123;...props&#125; routes=&#123;route.routes&#125; /&gt; )&#125; /&gt;)const RouteConfigExample = () =&gt; ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to='/tacos'&gt;Tacos&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/sandwiches'&gt;Sandwiches&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &#123;routes.map((route, i) =&gt; ( &lt;RouteWithSubRoutes key=&#123;i&#125; &#123;...route&#125; /&gt; ))&#125; &lt;/div&gt; &lt;/Router&gt;)export default RouteConfigExample 资源关于 React Router 4 的一切 React Router 中文文档 浅谈前后端路由与前后端渲染 hash VS browser Warning: Hash history cannot PUSH the same path; a new entry will not be added to the history stack 坑 react-router browserHistory刷新页面404问题解决 通过router 的 history.push() 方法延迟跳转后还是会跳转 在当前目录下的文件路径不再使用./, 而是直接用/ 的优先级要比 高，所以不要在同一个 中同时使用这两个属性。 Link 和 BrowserRouter 是同一个history，然而createBrowserHistory 的 history只能改变url，并没有触发页面刷新 错误的地方就在类似这样的代码 写法1 export default connect(mapStateToProp, mapDispatchToProp)(withRouter(AppContainer)); 应该写成 写法2 export default withRouter(connect(mapStateToProp, mapDispatchToProp)(AppContainer));原因connect内是进行shallow comparison浅比较的。它重写了组件的shouldComponentUpdate方法 写法1中，connect重写了withRouter的shouldComponentUpdate方法，导致其不能够响应location的变化（仅仅响应mapStateToProps里面的变化） 写法2中，将withRouter提到外层，withRouter的shouldComponentUpdate不会被重写，就会响应location的变化","tags":[]},{"title":"正确的提问(issue)","date":"2018-12-22T07:28:59.000Z","path":"2018/12/22/正确的提问(issue)/","text":"不要问已经回答过的问题尽职调查，试着找找是不是已经有人问过你的问题。如果你问了一个很容易找到答案的问题，你的问题很快会作为重复的问题关闭。 不要让人替你写代码如果你只是问”我怎么做某件事？”你的问题很快就会被关掉。希望你能在提issue之前自己先努力尝试着解决它。在你的问题里描述你尝试过的办法，以及为什么不行。 一次问一个问题一次问5件事情的问题：“我怎么做这件事，然后是那件，然后另一件事情，以及什么是做这个的最好办法？”，这很难回答，\b并且会让人望而却步。 为你的问题做\b一个最精简的例子当人们看到有3页代码（或者更多！)的问题时，总是会\b跳过去，把5000行的代码文件直接贴到issue里不利于得到答案(但总有人这么干)。这是一种经常得不到回报的懒惰行为。这不仅让你不太可能得到有用的答案，并且也正是消除无关因素的过程会引导你自己解决问题(这样你\b甚至不用在issue上问这个问题了)。制作最精简的例子对你的调试技能有好处，对你认真思考问题的能力也有所帮助。 如果在别给出答案之前你自己解决了问题，那就自己回答那个问题你遇到的问题很可能别人也会遇到，如果你已经解决了，本着助人为乐的精神，把你的答案放上去。","tags":[]},{"title":"GTD 时间管理方法论","date":"2018-12-22T07:28:08.000Z","path":"2018/12/22/GTD 时间管理方法论/","text":"收件箱（INBOX）这里的收件箱并不等于邮箱，照片，想看的网页，想看的书电影电视剧，邮件，临时的想法，想到要做的事情等等都可以放到这里来，这是GTD的第一步，收集（CAPTURE） 甄别(CLARIFYING)这步是要做出判断，收件箱里的东西是否是一个action 如果是，则进一步判断是单个动作还是多个动作，如果是单个动作，则要判断能否在两分钟内完成，如果能就马上去完成它。 如果不是ACTION，那么这个东西有几个去处， 一是垃圾桶，顾名思义， 二是当前没啥事能做，但在某个指定时间需要提醒自己， 三是参考材料 整理（ORGANISING）在上一步我们说到要判断是否是多个动作。现在我们来说说怎么分类处理多个动作。 首先需要多个动作才能完成的短期成果我们称之为项目。项目是可以衡量的短期成果，学好GTD不叫项目，学会如何给任务设置上下文（更好的翻译是情境）这是项目。 出于分类的方便，多个动作可以进一步分为： 日程表动作，即那些必须在特定时间或日期完成的动作，它们需要标注在日程表上提醒自己； 等待动作，这是指只有当你的同伴或队友完成了某个或多个动作并发给/告知你成果，你才能开始的动作，他们要放在等待列表里； 尽快开始动作，简称ASAP动作。对于ASAP动作的管理，除了使用项目的观念，还要引入情境，能量，时间和优先级这四个概念。 情境：完成动作必须用到的工具或必须处于的场地，比如你必须到实验室才能做实验，则实验室便是一个情境。 能量，包括生理状态和心理状态，比如阅读文件需要聚精会神，那么就是高能量。 时间，这里指的是要花费的时间多少，比如这个动作要1小时左右完成，则1小时便是时间标签。 优先级：优先级指的是在当前的情境，能量，时间条件下哪个动作能带给你最大的收益，那么就是高优先级。 事实上，随着GTD的发展，情境之外的三个条件已经被很多人设置为了情境使用。SOMEDAY动作，想做，但可能做也可能不做的事情，比如想读一本书但不确定到底要不要读。 回顾，回顾这里不妨使用GTD的六层视野模型| 六层：原则，这里是核心的价值观，比如这个项目为什么要存在 五层：愿景，这里是期望的长期成果，比如让公司上市 四层，目标，两年以内的中长期成果，比如完成收购某某集团 三层：关注的领域，这里是要维持你自己是身心健康或公司的日常运作需要不断进行的动作，最简单的例子比如买菜，健身等等 二层，项目，由多个具体可执行动作组成的短期成果 一层，接下来要做的动作，即项目下的可执行动作 需要注意的是GTD要求每周至少一次回顾自己的项目/任务列表，维护自己的系统 omnifocus 相对于其他GTD软件 可以设置顺序执行的项目类型, 比如 你有一个项目,是做饭,然后下面有2个动作,买菜,然后炒菜,炒菜要等买菜完成以后才能出现.通过设置一些顺序执行项目的分解,可以把一大部分不可用的任务给过滤掉! 设置推迟时间 ( 指定任务的出现时间 )没有一个gtd任务有,比如,我每天晚上要冥想,我就设置每天9点以后才出现这个任务.通过这样的设置,又可以过滤掉一堆任务! 项目文件夹分类,无限层级分类.这个用过的人才知道好 注释可以添加富文本,可以添加附件.这个相当强大,doit就没这功能,我有的时候,甚至会新建一个任务,然后把聊天截图的截图直接黏贴进去~. 配合mac的脚本软件,可以发送周报,日报,以及工作计划等到印象笔记 还有更强的脚本,可以把一本书,输入页,开始和结束时间,自动拆分成每天需要阅读多少页~ 手机上配合workflow可以快速添加任务! ( 从剪切板添加任务,从通知中心添加任务等 ) 为任务设置预估时间,配合脚本还可以统计总时间.配合透视,还可以把小于5分钟的任务筛选出来,然后一起处理 注意项目与行动一个项目 5 月 1 号开始，9月 30 号结束。那么这个项目肯定是由许许多多的小行动组成的。假设这个项目是抄写150条知乎问题；5月1号开始，9月30号结束。那么它也能分解成：每天抄写一条知乎问题。 行动与提醒OmniFoucs：不需要提醒的，项目一般在项目下都可以看见，每天有空做事的时候从中挑一件合适的事情做就OK了 calendar events：有明确时间要求的，比如15:00开会，这种行动应该记在日历中，不是OF中。","tags":[]},{"title":"埋点方案","date":"2018-12-22T07:26:51.000Z","path":"2018/12/22/埋点方案/","text":"tags: [组件]categories: 业务场景解决方案 埋点方式 数据监测：数据采集 | 数据传输 | 数据存储 | 数据分析挖掘 | 数据可视化 数据采集也叫埋点(加码|打点) 埋点核心参数：埋点 | 埋点参数 | 来源页面 | 来源页面参数 | 当前页面 | 当前页面参数 手工埋点 在需要监测的页面引入基础js文件，然后根据业务需求添加监测代码 手工埋点的数据监测产品：Google Analytics | Omniture | Webtrends | Coremetrics | Flurry | 百度统计 | CNZZ | 腾讯云分析 | 友盟 灵活：可以设置自定义事件属性、发送数据内容、发送时间等，可以采集自己最为关心和需要的数据 对于大型、复杂的网站，跨部门沟通成本较高 可视化埋点 通过点击交互替代手写代码 原理：在需要监测的页面引入基础JS文件，使用者进入可视化模式下，选择并配置监测内容(html元素)的信息被记录，并存放在相应位置。当真实世界的用户触发到该监测内容时，基础JS会自动加载之前配置过的信息，记录并发送该数据 产品：Mixpanel 的 Codeless 模式 | 神策分析 无埋点(全埋点) 也是通过可视化的形式添加要监测的内容 可视化埋点是需要先通过配置才能实现内容监测，而无埋点默认先尽可能多的收集能监测的内容，然后再通过配置确定哪些内容需要展示和分析 可以对想要监测的数据进行回溯，不必担心因为漏掉埋点而导致数据丢失 但由于有大量数据需要预先传输，数据时效性和网络传输对无埋点技术要求较高 产品：Heap | GrowingIO 前端埋点操作由于访问印记实现埋点是跨域的请求，\b所以前端这里用jsonp实现跨域请求。 下载并引入第三方库 jsonp npm install jsonp –save import originJsonp from ‘jsonp’ jsonp的实现原理就是动态创建script标签，并且将我们需要请求的路径通过该标签的src来实现，并且将我们要传入的参数拼接在路径后面。 jsonp请求的封装 url：需要请求的接口地址 option(Object)：jsonp的请求配置，如：timeout设置超时时间、param(String)回调函数名称 fn：回调函数，用来接受返回的错误或者成功的结果 封装调用印记方法 提供三种方法实现印记系统的登录、定时激活session、调用印记接口记录日志 将三种方法放在jsonpCMT对象中 writeLogLogin 登录印记系统 writeLogActive 激活session writeLogToDSInfo 调用印记接口记录日志 上述三种方法只需要传入一个参数params(Object)即可。该参数就是需要\b记录的状态。 实现埋点 在需要埋点的模块中导入模块 import jsonpCMT from ‘文件路径’ 在前端\b应用登录成功以后调用jsonpCMT.writeLogLogin方法，该方法成功以后则成功登录印记系统 在登录印记系统成功以后调用jsonpCMT.writeLogActive实现定时\b激活session 在需要实现埋点的地方调用jsonpCMT.writeLogToDSInfo实现日志记录","tags":[]},{"title":"随记","date":"2018-12-22T07:24:47.000Z","path":"2018/12/22/随记/","text":"随心随想随笔 PWA: 渐进式：能确保每个用户都能打开网页 响应式：PC，手机，平板，不管哪种格式，网页格式都能完美适配 离线应用：支持用户在没网的条件下也能打开网页，这里就需要 Service Worker 的帮助 APP 化：能够像 APP 一样和用户进行交互常 更新：一旦 Web 网页有什么改动，都能立即在用户端体现出来 安全：安全第一，给自己的网站加上一把绿锁–HTTPS 可搜索：能够被引擎搜索到推送：做到在不打开网页的前提下，推送新的消息 可安装：能够将Web像APP一样添加到桌面可跳转：只要通过一个连接就可以跳转到你的 Web 页面 Web要做的是把组件化、离线缓存、本地API、通知接口、自适应设备做好 service worker强大的网络请求拦截可以帮助用户更好的原生APP体验。PWA存在的问题主要是浏览器的兼容问题 service worker，pouchdb对离线体验的加持，以上几个库都没polymer做得好。 乔布斯：Design is not just what it looks like and feels like. Design is how it works 《死亡诗社》：我步入丛林，因为我希望活得深刻，吸取生命中所有的精华，把非生命的一切都击溃，以免当我生命终结时，发现自己从没有活过。 你要拼尽全力在年轻的时候给自己足够多的机会，创造更多的可能。 你要改变心态，要增长才干，积累阅历，这样你才有得选。 村上春树：你要做一个不动声色的大人了，不准情绪化，不准偷偷想念，不准回头看，去过自己另外的生活，你要听话，不是所有的鱼都会生活在同一片海里。 “If you cannot measure it, you cannot improve it” ———— William Thomson You need to be right before being good try…catch…finally: 在保持代码运行的同时，处理给定代码块中可能发生的部分或所有错误的方法。如果出现了未处理的错误，JS将提供常规错误消息。 try块包含可能引发错误的代码 catch块包含处理部分或所有错误的代码 如果try块中发生错误，则程序控件将传递exception的值给catch块 如果未发生错误，则绝不执行catch块中的代码 可以通过使用throw语句重新引发错误来将错误传递到下一级别 在执行try块中的所有语句并在catch块中完成错误处理后，无论是否已处理错误，都将执行finally块中的语句。 finally块中的代码保证能运行，除非发生未处理的错误（例如，catch块内发生的运行时错误） 只有理解细节，才有可能在特定场景里进行优化和创造 每次选择\b的时候，听内心的声音，选择似乎难一点的那条路，就是在践行理想： 自己的工作做到最高标准，不断精进； 不斤斤计较自己的得失，先人后己； 看到不公平的情况，发声； 看到需要帮助的“无关人等”\b，伸手； 对认为正确的事情，坚持； 少抱怨，多行动； 对支持创新的事，敢于冒险； 看到需要支持的人，挺身而出； 出了问题，敢于担当； React是用来替换jQuery的，那么Redux就是以替换Backbone|Ember等MVC框架为目的的。 如果你愿意限制做事方式的灵活度，你几乎总会发现可以做的更好 政治学说：谁垄断了信息的阐释权，谁就掌握了权利 经济学说：你能让信息有公信力，你就控制了一笔看不见的财富 如果说信息\b就是财富，那么得到的方法有两种： 一种是利用信息不对称赚取利益，就像利用各种面试技巧，取得面试官的信任； 一种是让自己的能力“公有化”，利用信息透明化，来降低交易成本。 面试要考虑两个问题： \b你是否能满足这个职位现在和以后的要求？——你有什么能力？ 这个人在团队中会产生什么样的作用？他是否符合公司文化的要求？——你是什么样的人？你有着怎样的故事？关键在于，如何讲这个故事。 ”弱点——挑战——解决“的情\b节建构模式 能力一般，但工作有韧劲儿，性格单纯，所以\b有些事情干得反而比聪明人更好 我喜欢观察事物，改变对事情的看法，从而解决问题。人物形象：我是一个有想法有创意的人 对于认准的事情，我非常坚持，不达目的，绝不放弃。人物形象：我是一个有毅力的人，可以打硬仗。 我的关注点常常不在具体问题，而是喜欢梳理业务逻辑，从制度层面优化办事效率。人物形象：我是一个理性、系统性很强的人。 屡战屡败是一个事实，屡败屡战就是一个故事 你并没有浪费掉一个好机会，你只是主动放弃掉一些不适合你的机会而已 只有不断放大自己的性格，你才会令人印象深刻 骤然临之而不惊，无故加之而不怒 每临大事有静气，不信今时无古贤 始终要做到精神镇静，头脑冷静，心态平静，要力戒浮躁、急躁、焦躁，培育静气、大气，始终做到不为诱惑所动、猝变所惊、名利所累、俗事所扰，讲政治、顾大局、守纪律，以无私无欲、至大至刚，涵养浩然大气，把静气当成一种境界去追求，一种情操去修炼，一种品质去磨砺，静气才会形而上为道，形而下为行，内化于心，外化于事，成为我们立身做人，为官做事的强大人格力量。 精明的最高境界是厚道，修养的最高境界是善良 https://cloud.tencent.com/developer/labs/lab/10004/console 若没有人愿意与你颠沛流离，则以梦为马，随处而栖 营销的基础是洞察受众的社会心态 数组的some和filter方法的区别 some方法返回的是boolean值，可用于检察数组中是否有某对象 filter方法返回的是一个新数组，可用于过滤数组中的对象 初级 | 小农经济 | 几乎不需要成本，不需要思考，靠人力获取价值，出现问题连基本的定位都很难，\b找到问题还是要靠大量的人力去解决重复性的劳动 \b中级 | 蒸汽时代（借助平台） | 工程化时代，借助工具快速定位，| 为了效率 高级 | 资本运作（人工智能|平台） | 资本带动资本，前期投资大，后期牵一发而动全身 | 思维方式的颠覆，具有积累效应（随着项目实践越来越多反哺从而变得越来越智能） 从依靠别人慢慢成长为成为别人的依靠 Array.prototype.filter ( callbackfn(元素的值，元素的索引，遍历的对象) ) 以企业的研究、生产、销售（“研产销”）三大功能计，原来三者之间市场交易成本太高，所以，必须把它们一体化到一家公司屋檐之下，才能顺畅运转，生产出有竞争力的产品。价值观、预设和行为习惯都不同的三大功能，一方面要充分尊重它们的差异化（differentiation），另外一方面又要实现一体化（integration），这也是管理学著名的所谓应变理论（contingency theory）的核心。现在，市场上的交易费用降低了，行业的产业组织模式发生变化了，原来必须放在一个屋檐之下的功能可以到市场上去购买了，“研产销”模式之外，还有可能出现的形式是：“研销＋产”（如电子代工业）、“研＋产销”（如新药研发）、“研产＋销”（如汽车分销业），当然，还有“研＋产＋销”（如芯片业） 渠道（客户）为王还是内容（产品）为王，从来都取决于二者的相对谈判力。小岛上十个男生，一个女生，女生为王；十个女生，一个男生，男生为王。没有谁是天生的真命天子。 互联网对产业的影响，我们主要看两个维度，一个是行业市场化的程度，一个是行业信息化的程度 行业信息化的程度，指这个行业的人流、物流、生意流多大程度上是跟着信息流走的，如果很大程度上是跟着信息流走的，互联网在这个行业就有戏；如果不跟着走，就不要去搞什么互联网，“互联网+”或者“+互联网”，都不会有太大意义。只要一个行业的信息化程度高，互联网化的潜力大，这个行业里一般就会出现专做信息的平台。 偷是这个世界上唯一的罪，偷懒也是偷 有两件事情不做好容易走弯路，一是官方文档没有看透，基础不扎实；二是该遵循的规范没有遵循 不能简单地做单目标局部短期优化，必须多目标长期地把这种商业生态需求同算法融合在一起。 互联网商业: 流量集中化:线上最重要的特点是用户和流量集中化，不再有地理位置限制，可以显著提升商业效率。这里对技术有非常强的依赖和挑战，要求我们能快速把好的商家和商品筛选出来给用户，把不好的淘汰掉，甚至要针对不同类型的用户和场景，更多体现某一类商品或商家的特点。一旦我们做不好，负向结果也会迅速扩大，会把不好的或者不适合的商品迅速推送给某个场景下某个用户群体，这样对生态对用户的损害也是非常显著的 产品化: 大数据赋能:之所以技术能够提升商业效率，核心也在于线上环境有丰富的大数据，例如用户、商品、商家、交易、评价等数据，而这些大量的数据是结构化和打通的，在这个基础上技术才能有发挥的空间，才能去提升商业效率 如果提前了解了你们要面对的人生，不知你们是否还会有勇气前来。看见的和听到的，经常会令你们沮丧。世俗是这样的强大，强大到生不出改变他们的念头来。可是如果有机会提前了解了你们的人生，知道青春也不过只有这些日子，不知你们是否还会在意那些世俗希望你们在意的事情。比如占有多少才更荣耀，拥有什么才能被爱。等你们长大你们会因绿芽冒出土地而喜悦，会对初升的朝阳欢呼跳跃，也会给别人善意和温暖。但是却会在赞美别的生命的同时，常常，甚至永远地忘了自己的珍贵。“愿你在被打击时，记起你的珍贵，抵抗恶意；愿你在迷茫时，坚信你的珍贵。爱你所爱，行你所行，听从你心，无问西东。 做出正交的设计，“正交”讲的是线性无关，非常重要，就像一个点(x,y)，在x轴的变化不会影响y，y轴的变化不会影响x，这就是正交。“正交”威力巨大，(x,y)可以表达二维平面的所有的点，如果增加一个z轴，不但能表达三维空间中所有的点，并且每个轴都可以独立变化。设计模式一直强调的『发现变化并且封装变化』其实就是这个意思。 前端技术：优先解决基础技术设施的问题 业务：对外 开发效率 VS 研发效率 性能 &amp;&amp; 用户体验 技术生态 团队驱动：结果可衡量：为团队争取时间 Move Fast and Break Things Huge Impact with Small Teams Be Bold and Innovative 代码对于一个软件工程师就是尊严。 当你遇到困惑不知道该怎么办，永远记住:Read-Search-Ask。 Read the error search google ask for help 个人学习求新，企业架构求稳。无非喜好与场景而已。 其实没有刺不穿的盾，只是攻击的成本和攻击成功后获得的利益成不成正比。 你需要的伴侣，最好是那能够和你并肩立在船头，浅斟低唱两岸风光，同时更能在惊涛骇浪中紧紧握住你的手不放的人。——龙应台 恩宜自淡而浓，先浓后淡者人忘其惠；威宜自严而宽，先宽后严者人怨其酷 阳光下像个天真烂漫的孩子，风雨里做个相互扶持的大人 何谓平庸？平庸是一种被动而又功利的谋生态度。平庸者什么也不缺少，只是无感于外部世界的精彩，人类历史的厚重，终极道义的神圣，生命涵意的丰富。 只有书籍，能把辽阔的空间和漫长的时间浇灌给你，能把一切高贵生命早已飘散的信号传递给你，能把无数的智能和美好对比着愚昧和丑陋一起呈现给你。 这个世界上多的是短平快、付出马上就有回报的立竿见影的事，也多的是需要长期投入、靠矢志不渝的坚持才有大成的事。只不过，对前一种人们常常趋之若鹜，对后一种人们却避之唯恐不及。 当爱支配一切时，权利就不存在了，当权力主宰一切时，爱就消失了 力微休负重，言轻莫劝人 逝者不可追，来者犹可待 拿破仑曾说：“能控制好自己情绪的人，比拿下一座城池的将军更伟大。” 衡量一个人的成功标志，不是看他登到顶峰的高度，而是看他跌到低谷的反弹力。 金钱教育，本质上就是教会孩子如何正确对待“获得”和“拥有”。“君子爱财取之有道” 自信的孩子，眉间有笑，心中有光，做事有决断，大多具有领导才能，内心果敢而笃定，未来会有无限可能。 这个世界上所有的爱都以聚合为最终目的，只有一种爱是以分离为目的，那就是父母对孩子的爱。 浅层学习满足输入，深度学习注重输出。 正确思考的核心是让自己的主观认知尽量与客观世界保持一致 自卑不是来自你的缺点，而来自你没有足以对抗的优点。 自己的目的是什么？ 对方的目的是什么？ 如何做才能达成我们双方共同的目的？ 对方为什么会产生这样的情绪？ 如何才能让对方感觉是处于安全的对话环境中？ 如何控制自己的情绪，客观的评价对方的观点和行为？ 《菜根谭》：冷眼观人，冷耳听语，冷情当感，冷心思理。 所谓学习，就是把原本不相关的东西联系在一起的过程 我们经常说某个人口才好，能把一个复杂的概念讲明白，那一定是因为这个人用了一个你熟悉的概念作为起点，帮助你连接到这个新概念上，这样你就能一下子听明白了。 人是在已有认知上，建立新的连接，来理解新事物的。 整理背景知识的：MECE法则。 提升沟通效果的：SCQA结构化表达。 用于策略选择的：SWOT分析。 正向演绎推理的：三段论。 用于创新思考的：加减乘除排列组合。 对创业者来说，合伙人的背景非常重要，尽量不要找一起长大的，一个学校读书的，这样你会干的事情他也会干","tags":[]},{"title":"编写一个 Loader","date":"2018-12-22T07:19:22.000Z","path":"2018/12/22/编写一个 Loader/","text":"tags: [组件]categories: 前端工程化 loaderloader是导出为一个函数的 node 模块，该函数在 loader 转换资源时调用，给定的函数将调用loader API，并通过this上下文访问本质：接收字符串(或者buffer)，再返回处理完的字符串(或者buffer)的过程 设置匹配单个 loaderwebpack.config.js123456789&#123; test: /\\.js$/ use: [ &#123; loader: path.resolve('path/to/loader.js'), // 通过rule对象指向本地文件 options: &#123;/* ... */&#125; &#125; ]&#125; 匹配多个 loaderswebpack.config.js123456resolveLoader: &#123; modules: [ 'node_modules', path.resolve(__dirname, 'loaders') // 如果你的项目中有一个 /loaders 本地目录 ]&#125; 为 loader 创建了独立的库和包使用 npm link，来将其关联到你要测试的项目Npm link 专门用于开发和调试本地Npm模块，能做到在不发布模块的情况下，把本地的一个正在开发的模块的源码链接到项目的 node_modules 目录下，让项目可以直接使用本地的 Npm 模块。由于是通过软链接的方式实现的，编辑了本地的 Npm 模块代码，在项目中也能使用到编辑后的代码。 完成 Npm link 的步骤如下： 确保正在开发的本地 Npm 模块（也就是正在开发的 Loader）的 package.json 已经正确配置好； 在本地 Npm 模块根目录下执行 npm link，把本地模块注册到全局； 在项目根目录下执行 npm link loader-name，把第2步注册到全局的本地 Npm 模块链接到项目的 node_moduels 下，其中的 loader-name 是指在第1步中的 package.json 文件中配置的模块名称。 链接好 Loader 到项目后你就可以像使用一个真正的 Npm 模块一样使用本地的 Loader 了 复杂用法链式调用多个loader时，以相反顺序调用，从右往左或从上到下 最后的loader最早调用，将会传入原始资源内容 第一个loader最后调用，期望值是传出JS和SourceMap(可选) 中间的loader执行时，会传入前一个loader传出的结果 用法准则 简单：loaders 应该只做单一任务。这不仅使每个 loader 易维护，也可以在更多场景链式调用。 链式：loader 可以被链式调用意味着不一定要输出 JavaScript。只要下一个 loader 可以处理这个输出，这个 loader 就可以返回任意类型的模块。 模块化：保证输出模块化。loader 生成的模块与普通模块遵循相同的设计原则。 无状态：确保 loader 在不同模块转换之间不保存状态。每次运行都应该独立于其他编译模块以及相同模块之前的编译结果。 loader工具库： loader-utils schema-utils loader.js 12345678910111213141516import &#123; getOptions &#125; from 'loader-utils';import validateOptions from 'schema-utils';const schema = &#123; type: 'object', properties: &#123; test: &#123; type: 'string' &#125; &#125;&#125;export default function(source) &#123; const options = getOptions(this); validateOptions(schema, options, 'Example Loader'); // 对资源应用一些转换…… return `export default $&#123; JSON.stringify(source) &#125;`;&#125;; * loader 依赖: 必须使用 addDependency 方法显式声明 12345678910import path from 'path';export default function(source) &#123; var callback = this.async(); var headerPath = path.resolve('header.js'); this.addDependency(headerPath); fs.readFile(headerPath, 'utf-8', function(err, header) &#123; if(err) return callback(err); callback(null, header + \"\\n\" + source); &#125;);&#125;; 模块依赖 通过把它们转化成 require 语句。 使用 this.resolve 函数解析路径 通用代码 在 loader 中创建一个运行时文件，并生成 require 语句以引用该共享模块 绝对路径 loader-utils 中的 stringifyRequest 方法，可以将绝对路径转化为相对路径。 同等依赖 package.json中指定peerDependency的值 处理二进制数据在默认的情况下，Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串。但有些场景下 Loader 不是处理文本文件，而是处理二进制文件，例如 file-loader，就需要 Webpack 给 Loader 传入二进制格式的数据。 12345678910module.exports = function(source) &#123; // 在 exports.raw === true 时，Webpack 传给 Loader 的 source 是 Buffer 类型的 source instanceof Buffer === true; // Loader 返回的类型也可以是 Buffer 类型的 // 在 exports.raw !== true 时，Loader 也可以返回 Buffer 类型的结果 return source;&#125;;// 通过 exports.raw 属性告诉 Webpack 该 Loader 是否需要二进制数据// 最关键的代码是最后一行,没有该行 Loader 只能拿到字符串。 module.exports.raw = true; 缓存加速在有些情况下，有些转换操作需要大量计算非常耗时，如果每次构建都重新执行重复的转换操作，构建将会变得非常缓慢。为此，Webpack 会默认缓存所有 Loader 的处理结果，也就是说在需要被处理的文件或者其依赖的文件没有发生变化时，是不会重新调用对应的 Loader 去执行转换操作的。 如果你想让 Webpack 不缓存该 Loader 的处理结果，可以这样： 12345module.exports = function(source) &#123; // 关闭该 Loader 的缓存功能 this.cacheable(false); return source;&#125;; this.callbackthis.callback 是 Webpack 给 Loader 注入的 API，以方便 Loader 和 Webpack 之间通信。this.callback 的详细使用方法如下：1234567891011this.callback( // 当无法转换原内容时，给 Webpack 返回一个 Error err: Error | null, // 原内容转换后的内容 content: string | Buffer, // 用于把转换后的内容得出原内容的 Source Map，方便调试 sourceMap?: SourceMap, // 如果本次转换为原内容生成了 AST 语法树，可以把这个 AST 返回， // 以方便之后需要 AST 的 Loader 复用该 AST，以避免重复生成 AST，提升性能 abstractSyntaxTree?: AST); 其他Loader API this.context：当前处理文件的所在目录，假如当前 Loader 处理的文件是 /src/main.js，则 this.context 就等于 /src。 this.resource：当前处理文件的完整请求路径，包括 querystring，例如 /src/main.js?name=1。 this.resourcePath：当前处理文件的路径，例如 /src/main.js。 this.resourceQuery：当前处理文件的 querystring。 this.target：等于 Webpack 配置中的 Target this.loadModule：但 Loader 在处理一个文件时，如果依赖其它文件的处理结果才能得出当前文件的结果时， 就可以通过 this.loadModule(request: string, callback: function(err, source, sourceMap, module)) 去获得 request 对应文件的处理结果。 this.resolve：像 require 语句一样获得指定文件的完整路径，使用方法为 resolve(context: string, request: string, callback: function(err, result: string))。 this.addDependency：给当前处理文件添加其依赖的文件，以便再其依赖的文件发生变化时，会重新调用 Loader 处理该文件。使用方法为 addDependency(file: string)。 this.addContextDependency：和 addDependency 类似，但 addContextDependency 是把整个目录加入到当前正在处理文件的依赖中。使用方法为 addContextDependency(directory: string)。 this.clearDependencies：清除当前正在处理文件的所有依赖，使用方法为 clearDependencies()。 this.emitFile：输出一个文件，使用方法为 emitFile(name: string, content: Buffer|string, sourceMap: {…})。 资源npm link","tags":[]},{"title":"浏览器兼容性","date":"2018-12-22T07:14:00.000Z","path":"2018/12/22/浏览器兼容性/","text":"tags: [组件]categories: 业务场景解决方案 IE9 不支持flex布局 css行数过多会不加载，需要用CSSSplitWebpackPlugin分割 1234new CSSSplitWebpackPlugin(&#123; size: 4000, filename:utils.assetsPath('css/[name]-[part].[ext]'), &#125;), 不支持websocket vue框架: 刷新多次才显示界面 滚动条 | 下拉框箭头 | 展开箭头 | 排序箭头 消息x号不居中 列表获得焦点样式,没有边框线 IE JS兼容性 事件绑定方法为attachEvent而不是通用的addEventListener 事件捕获方式由内而外而不是由外而内，一般\b\b将IE的标准定为标准 事件获取目标元素event.srcElement而不是event.target ajax是activeXObject innerHtmlIE中不能操作tr的innerHtml 获取DOM节点 IE: parentElement | parentElement.children other: parentNode | parentNode.childNodes 在HTML中禁止IE缓存IE浏览器提供的ajax对象在发送get请求时，会查看请求地址是否访问过，如果访问过，则显示第一次访问的结果（也就是说，会将第一次访问的结果缓存下来） 在Head里添加禁止使用缓存的代码 123&lt;meta http-equiv=\"Pragma\" content=\"no-cache\"&gt;&lt;meta http-equiv=\"Cache-control\" content=\"no-cache\"&gt;&lt;meta http-equiv=\"Cache\" content=\"no-cache\"&gt; 将所有的ajax调用都改为post方法 在请求地址后面添加随机数或者时间戳, 比如xhr.open(‘get’,’luck.do?’+Math.random(),true,true)); 兼容性测试工具 browserling 在HTML中禁止IE缓存 overflow 兼容性问题chrome: 容器可滚动，padding-bottom 也算在滚动尺寸之内IE和 Firefox 会忽略 padding-bottom同时会导致 scrollHeight 值不一样解决方案：如果需要留有间隙，则使用透明边框 WebP图片兼容性处理https://github.com/RicardoCao-Biker/RICO-BLOG/issues/9","tags":[]},{"title":"跨域问题解决方案","date":"2018-12-22T07:07:34.000Z","path":"2018/12/22/跨域问题解决方案/","text":"tags: [组件]categories: 业务场景解决方案 什么是跨域由于浏览器的同源策略，导致只要协议、域名、端口有任何一个不同，都被当作是不同的域，从而导致了跨域访问的需求 服务器端不存在跨域 不能通过ajax的方法去请求不同源中的文档 不同域的框架之间是不能进行JS交互操作的，不同的框架之间是可以获取window对象的，但是无法获取响应的属性和方法 如果是协议和端口造成的跨域问题“前台”是无能为力的 在跨域问题上，域仅仅是通过“URL首部”来识别，而不会去尝试判断相同的IP地址对应着两个域或两个域是否在同一个IP上 URL首部：window.location.protocol + window.location.host 针对接口的请求 针对Dom的查询 跨域的方法双向通信：即两个iframe,页面与iframe或是页面与页面之间单向跨域：一般用来获取数据 iframe + document.domain将两个页面的 document.domain 都设成相同的域名(只能设置成自身或更高一级的父域，且主域必须相同) ifame + location.hash父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URLhash一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。 H5的postMessageIE8+ 发送信息的postMessage事件: otherWindow.postMessage(message, targetOrigin) otherWindow: 目标窗口，也就是给哪个window发消息，是window.frames属性的成员或者window.open创建的窗口 message：要发送的消息，String | Object targetOrigin: 限定消息接收范围，不限制请使用“*” 监听接收信息的message事件 既可以处理Get请求也可以处理POST请求 JSONP通过script标签引入的JS是不受同源策略的限制的，可以通过script标签引入一个文件，此文件必须返回一个JS函数的调用(要和后端约定好)只能实现GET请求jquery的getJSON()会自动判断是否跨域，不跨域就调用普通的ajax()；跨域则会以异步加载JS文件的形式来调用JSONP的回调函数 JSONP优点： 不像XHR对象实现Ajax请求那样受到同源策略的限制 兼容性更好，不需要XHR或者ActiveX的支持 在请求完毕后可以通过调用callback的方式回传结果 JSONP缺点： 只支持GET而不支持POST等其它类型的HTTP请求 只支持跨域HTTP请求的情况，不能解决不同域的两个页面之间如何进行JS调用的问题 CORSIE10+ CORS： 使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。 实现CORS通信的关键是服务器，只要服务器实现了CORS接口，就可以跨源通信。 服务器端对于CORS的支持，主要通过设置Access-Control-Allow-Origin来进行。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头部信息，有时还会多出一次附加请求，但用户不会有感觉。 CORS与JSONP相比，无疑更为先进、方便和可靠： JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求 使用CORS，开发者可以使用普通的XHR发起请求和获得数据，比起JSONP有更好的错误处理 JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS window.name其他 中间件跨域 服务器代理跨域 Flash URLLoader跨域 动态创建script标签 websocket协议支持跨域 遇到的跨域问题单点登陆嵌入子系统页面通过 iframe + document.domain 的方式解决 icon-font 放到GitHub上导致跨域问题通过将icon-font 的 url 改成 base64 的形式直接嵌入到页面中 这样会产生跨域问题12345678910@font-face &#123; font-family: 'idoll-icon-online'; src: url('@&#123;icon-url&#125;/idoll-icon-online.eot?67rfls'); src: url('@&#123;icon-url&#125;/idoll-icon-online.eot?67rfls#iefix') format('embedded-opentype'), url('@&#123;icon-url&#125;/idoll-icon-online.ttf?67rfls') format('truetype'), url('@&#123;icon-url&#125;/idoll-icon-online.woff?67rfls') format('woff'), url('@&#123;icon-url&#125;/idoll-icon-online.svg?67rfls#idoll-icon-online') format('svg'); font-weight: normal; font-style: normal;&#125; 添加了base64的方式便不会跨域了1234567@font-face &#123;font-family: \"idoll-icon-pro2\"; src: url('@&#123;icon-url&#125;/idoll-icon-pro2.eot?t=1544695441349'); /* IE9*/ src: url('@&#123;icon-url&#125;/idoll-icon-pro2.eot?t=1544695441349#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAAnUAAsAAAAAD6AAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADMAAABCsP6z7U9TLzIAAAE8AAAARAAAAFY870h2Y21hcAAAAYAAAACNAAACCoOE66ZnbHlmAAACEAAABWMAAAg0ycE3gmhlYWQAAAd0AAAALwAAADYTj+MfaGhlYQAAB6QAAAAcAAAAJAfeA45obXR4AAAHwAAAAA8AAAA0NAAAAGxvY2EAAAfQAAAAHAAAABwMfA5MbWF4cAAAB+wAAAAfAAAAIAEcAGluYW1lAAAIDAAAAUUAAAJtPlT+fXBvc3QAAAlUAAAAfwAAAMqOQWaEeJxjYGRgYOBikGPQYWB0cfMJYeBgYGGAAJAMY05meiJQDMoDyrGAaQ4gZoOIAgCKIwNPAHicY2BkYWCcwMDKwMHUyXSGgYGhH0IzvmYwYuRgYGBiYGVmwAoC0lxTGByeVT5rYW7438AQw9zA0AAUZgTJAQDw3gzgeJztkckRAjEQA9usWa4NhQAIiBcZLPcVCNFNGovGepAErmpVjTz2QwLmQCe2okI5UMizl1ua37FufmXXdmr68Z4m6ZiquTZdMdN21Z89C71asmHQRc//DE0/vylG09I8GiVInIyyJM4mG4qLyazjarK9uBllTtyN0iceJtuLp1EjxMuoG7VoGL6PiyuHAAAAeJytVc1vE0cUn/fW9mY3eJ3dtb3xZ+y1vSZANyRer5VAyfIRUCitgFYt4EpNK0BUJCr0lnDAwKGoJ6QoUiVoi1Rx4Q9AvRQMUg699FiJ9FCK1AMVlVBvVPW4b+wQQY9t5d15nvcx83ufy0KMddtSWwrYIMuyCtvNGGgg58HaBQ0XTA1sF71dOJHHeATsSDw54XsOsceQFGRStfyk3LNo7BIPsrudcLhzt7ce8q9+cfXs5OTZPuH3dcuyLasWTZqImFFC6T1pKIdk2QTIm2lHDRlS8MKY1s6O+oaxIPCbMLct/hHOIODx28cgqmgaepu3z2/bYmPIswZGmfSST3G2/VWP5IlkPGI7nk8+yBGnSkzfkYlMC60RSPqNZOQVJ+72QR8crKTNPIApy+ESpHdnQkqGnDCTUVV/BfStdYxbLS+E9pZt89s3e6hp6iY4dvs4oZ7BSA8jY1KLSIHV2SRhtCM5KNY9R9ASQdEJcZHQ6S5US8SXJ/zXoZYo1msJkYTXoUgU9KKONzWjy4ys0cqUAcoZXKctQ9OMVqfVIhEwg7tI1xlaoaAZtJJCp71uEBAlbpvYrVZfTCtn0OItAbOH9XN8wpIszUoCqwyR+AjkoTbRIERF8L0qOFIVLLCdMWhYGmAzqvKdqvplbn8lGoX7/A4cVFX+h7rjMQz9wj9Ou8ZnJx6bLj4Raml1JZdFCOANNaWCrHa+X4PYQ/6VaVxsrhlmD0P3uXQTVylek+wEY5RKCg74lE4ZNMyjyKDYxWjnkPSFLJLHjb+O5XgNsvNctCMxEHUwTdtecZPYXi1XQqMOyEraVPjzXAEz9QOHZ3NcTZlKx5k7M+c7WAZTFeKnQ+DU9Bcb5+QPqgqOYZpl13ONZWGxnJl5a8bP5TJ8TU3vqcyd+aAKEcVMqfzP/Ozh/X4GCzmumGmFO6OhysXqSYdOM9Mq/12vOTAEcaW3KWNRTStQNdyaWzZNY1mwlzPZbGPmzZksX1NEekK9HLXxZq/mHTbxj6p3wRMxiFTGqZxIMJ4Y78vGw8QgSjtKGvNnAWb9/popl/1yGW5NP11ZeTrdX3mwtDo1tbrUW5Ft6Pqz90Bo++Xg0g3EG5fg8nXE65d/hsVTpxcBFk+fWhQQwz2cAbYpozJLsBTLEdJioijTC0W9tFH2pXBNL5n0wkVAzu8hlTIy3gqoYkGUeMAfBUEroLOCQsDnRLH26xlaQZcB64qroD8L4Bu6i0HdpTaTx+MalsQoq43TRSSM5+NA8+VQLJGIURfThTHTjB2iqZPIJ8J/fbcR3wKuMIWZLMNG6LSqY8fAavieXKUIU+37XliOJKexKpzBn/ZR2qzzlrL3RDga5r+eh0yYH8+iMnBBOlfAoNPGA/tUNfmppab2N0OwrrLpxwuyAlk493WBrsR+Xqn897L3+zlN0BtPWhSnRK1eEuPZb9BvBzj1fh7jcm3CEgrk51YgJWJ7DmGskv8SYRZTfBp0MUbquiUm+hg4iAvXpHfmsTSSCipBoTDlDg9b1bo6+NogLhw5soCDo9FNtYo1POxOFQrB22eF5nRZurYQVZuiJG2aMxXRDU1VYsTG6NJ7Y4dHUsUIBmQTTFnOAOTto/OI80ftPA5ULGK6wwFqS+/2FMPSwjX+rdIU7VfiD8Uggi2O6JCm0o9Ft/v/xiKS0CmLYpaJiNCXjaKje/8+Fp9oht0PQaoflIrxn2JhaHzNVuPiMHFmXK3AqGb0Z3L3kfShVKKZnGI2RUNMYNkpFV/+dOyEilUyi3oxQZyaNKfwZ1E9FOYvD/4uu3Kl3WmD6Ks2PIuqMDQoCWknWG+ndnjgzhXO8MEDYjD2N29KiC4AeJxjYGRgYADiKYu+r4vnt/nKwM3CAAI3LPwnIuj/B1gYmB2AXA4GJpAoAEB+CnwAeJxjYGRgYG7438AQw8IAAkCSkQEV8AIARxMCdnicY2FgYGAhEQMABeQANQAAAAAAAGoAvAESAVQB5AI4AnAClALQA1YD3AQaeJxjYGRgYOBliGVgZQABJiDmAkIGhv9gPgMAEzEBhgB4nGWPTU7DMBCFX/oHpBKqqGCH5AViASj9EatuWFRq911036ZOmyqJI8et1ANwHo7ACTgC3IA78EgnmzaWx9+8eWNPANzgBx6O3y33kT1cMjtyDRe4F65TfxBukF+Em2jjVbhF/U3YxzOmwm10YXmD17hi9oR3YQ8dfAjXcI1P4Tr1L+EG+Vu4iTv8CrfQ8erCPuZeV7iNRy/2x1YvnF6p5UHFockikzm/gple75KFrdLqnGtbxCZTg6BfSVOdaVvdU+zXQ+ciFVmTqgmrOkmMyq3Z6tAFG+fyUa8XiR6EJuVYY/62xgKOcQWFJQ6MMUIYZIjK6Og7VWb0r7FDwl57Vj3N53RbFNT/c4UBAvTPXFO6stJ5Ok+BPV8bUnV0K27LnpQ0kV7NSRKyQl7WtlRC6gE2ZVeOEXpc0Yk/KGdI/wAJWm7IAAAAeJxtjM0KwjAQhHfqT9vYKj5IDj5SSLYSWJIQKuLbyyY3cS473ww7NFCXof9aMeCAI044Y8SEGQYXLFhxpXup2ca0Zetj9cI2336SRdk74RRcnRsIuzp1F8uohj9s9AYW3vuLZBdiej5aXzi1/lU0bn3I76TQhrYoTPQFVnUylgA=') format('woff'), url('@&#123;icon-url&#125;/idoll-icon-pro2.ttf?t=1544695441349') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url('@&#123;icon-url&#125;/idoll-icon-pro2.svg?t=1544695441349#iconfont') format('svg'); /* iOS 4.1- */&#125; 资源前端跨域知识总结最直白的跨域访问原理浏览器的同源策略不要再问我跨域的问题了","tags":[]},{"title":"ES6|ES7|ES8","date":"2018-12-22T07:03:14.000Z","path":"2018/12/22/ES6|ES7|ES8/","text":"tags: [组件]categories: 底层原理及基础 ES6常用新特性let &amp;&amp; constlet 命令也用于变量声明，但是作用域为局部const用于声明一个常量，设定后值不会再改变 箭头函数箭头函数是 ES6 中新的函数定义形式，function name(arg1, arg2) {…}可以使用(arg1, arg2) =&gt; {…}来定义。示例如下：12345678910111213// JS 普通函数var arr = [1, 2, 3]arr.map(function (item) &#123; console.log(index) return item + 1&#125;)// ES6 箭头函数const arr = [1, 2, 3]arr.map((item, index) =&gt; &#123; console.log(index) return item + 1&#125;) 箭头函数存在的意义，第一写起来更加简洁，第二可以解决 ES6 之前函数执行中this是全局变量的问题（没有独立的作用域），看如下代码123456789101112131415function fn() &#123; console.log('real', this) // &#123;a: 100&#125; ，该作用域下的 this 的真实的值 var arr = [1, 2, 3] // 普通 JS arr.map(function (item) &#123; console.log('js', this) // window 。普通函数，这里打印出来的是全局变量，令人费解 return item + 1 &#125;) // 箭头函数 arr.map(item =&gt; &#123; console.log('es6', this) // &#123;a: 100&#125; 。箭头函数，这里打印的就是父作用域的 this return item + 1 &#125;)&#125;fn.call(&#123;a: 100&#125;) 解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）12345let [a, b, c] = [1, 2, 3];//等同于let a = 1;let b = 2;let c = 3; 对象的解构赋值：获取对象的多个属性并且使用一条语句将它们赋给多个变量 var { StyleSheet, Text, View } = React; 等同于 var StyleSheet = React.StyleSheet; var Text = React.Text; var View = React.Text; 123456789101112## 模块化 import导入模块、export导出模块如果只是输出一个唯一的对象，使用export default即可，代码如下 ```js// 创建 util1.js 文件，内容如export default &#123; a: 100&#125;// 创建 index.js 文件，内容如import obj from &apos;./util1.js&apos;console.log(obj) 如果想要输出许多个对象，就不能用default了，且import时候要加{...}，代码如下 123456789101112// 创建 util2.js 文件，内容如export function fn1() &#123; alert('fn1')&#125;export function fn2() &#123; alert('fn2')&#125;// 创建 index.js 文件，内容如import &#123; fn1, fn2 &#125; from './util2.js'fn1()fn2() 类class class 其实一直是 JS 的关键字（保留字），但是一直没有正式使用，直到 ES6 。 ES6 的 class 就是取代之前构造函数初始化对象的形式，从语法上更加符合面向对象的写法。例如： JS 构造函数的写法 1234567891011121314151617181920212223242526 function MathHandle(x, y) &#123; this.x = x; this.y = y; &#125; MathHandle.prototype.add = function () &#123; return this.x + this.y; &#125;; var m = new MathHandle(1, 2); console.log(m.add())用 ES6 class 的写法```jsclass MathHandle &#123;constructor(x, y) &#123; this.x = x; this.y = y;&#125;add() &#123; return this.x + this.y;&#125;&#125;const m = new MathHandle(1, 2);console.log(m.add()) 注意以下几点，全都是关于 class 语法的：1231、class 是一种新的语法形式，是class Name &#123;...&#125;这种形式，和函数的写法完全不一样2、两者对比，构造函数函数体的内容要放在 class 中的constructor函数中，constructor即构造器，初始化实例时默认执行3、class 中函数的写法是add() &#123;...&#125;这种形式，并没有function关键字 使用 class 来实现继承就更加简单了，至少比构造函数实现继承简单很多。看下面例子JS 构造函数实现继承123456789101112131415// 动物function Animal() &#123; this.eat = function () &#123; console.log('animal eat') &#125;&#125;// 狗function Dog() &#123; this.bark = function () &#123; console.log('dog bark') &#125;&#125;Dog.prototype = new Animal()// 哈士奇var hashiqi = new Dog() ES6 class 实现继承123456789101112131415161718192021class Animal &#123; constructor(name) &#123; this.name = name &#125; eat() &#123; console.log(`$&#123;this.name&#125; eat`) &#125;&#125;class Dog extends Animal &#123; constructor(name) &#123; super(name) this.name = name &#125; say() &#123; console.log(`$&#123;this.name&#125; say`) &#125;&#125;const dog = new Dog('哈士奇')dog.say()dog.eat() 注意以下两点：121、使用extends即可实现继承，更加符合经典面向对象语言的写法，如 Java2、子类的constructor一定要执行super()，以调用父类的constructor Set 和 Map 题目：ES6 中新增的数据类型有哪些？ Set 和 Map 都是 ES6 中新增的数据结构，是对当前 JS 数组和对象这两种重要数据结构的扩展。由于是新增的数据结构，目前尚未被大规模使用，但是作为前端程序员，提前了解是必须做到的。先总结一下两者最关键的地方：1、Set 类似于数组，但数组可以允许元素重复，Set 不允许元素重复2、Map 类似于对象，但普通对象的 key 必须是字符串或者数字，而 Map 的 key 可以是任何数据类型 SetSet 实例不允许元素有重复，可以通过以下示例证明。可以通过一个数组初始化一个 Set 实例，或者通过add添加元素，元素不能重复，重复的会被忽略。 1234567891011// 例1const set = new Set([1, 2, 3, 4, 4]);console.log(set) // Set(4) &#123;1, 2, 3, 4&#125;// 例2const set = new Set();[2, 3, 5, 4, 5, 8, 8].forEach(item =&gt; set.add(item));for (let item of set) &#123;console.log(item);&#125;// 2 3 5 4 8 Set 实例的属性和方法有123451、size：获取元素数量。2、add(value)：添加元素，返回 Set 实例本身。3、delete(value)：删除元素，返回一个布尔值，表示删除是否成功。4、has(value)：返回一个布尔值，表示该值是否是 Set 实例的元素。5、clear()：清除所有元素，没有返回值。 1234567891011121314const s = new Set();s.add(1).add(2).add(2); // 添加元素s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // falses.clear();console.log(s); // Set(0) &#123;&#125; Set 实例的遍历，可使用如下方法12341、keys()：返回键名的遍历器。2、values()：返回键值的遍历器。不过由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys()和values()返回结果一致。3、entries()：返回键值对的遍历器。4、forEach()：使用回调函数遍历每个成员 123456789101112131415161718192021222324252627let set = new Set(['aaa', 'bbb', 'ccc']);for (let item of set.keys()) &#123;console.log(item);&#125;// aaa// bbb// cccfor (let item of set.values()) &#123;console.log(item);&#125;// aaa// bbb// cccfor (let item of set.entries()) &#123;console.log(item);&#125;// [\"aaa\", \"aaa\"]// [\"bbb\", \"bbb\"]// [\"ccc\", \"ccc\"]set.forEach((value, key) =&gt; console.log(key + ' : ' + value))// aaa : aaa// bbb : bbb// ccc : ccc MapMap 的用法和普通对象基本一致，先看一下它能用非字符串或者数字作为 key 的特性。 const map = new Map(); const obj = {p: ‘Hello World’}; map.set(obj, ‘OK’) map.get(obj) // “OK” map.has(obj) // true map.delete(obj) // true map.has(obj) // false 1234567891011121314151617181920212223242526需要使用new Map()初始化一个实例，下面代码中set get has delete顾名即可思义（下文也会演示）。其中，map.set(obj, &apos;OK&apos;)就是用对象作为的 key （不光可以是对象，任何数据类型都可以），并且后面通过map.get(obj)正确获取了Map 实例的属性和方法如下： 1、size：获取成员的数量 2、set：设置成员 key 和 value 3、get：获取成员属性值 4、has：判断成员是否存在 5、delete：删除成员 6、clear：清空所有 ```js const map = new Map();map.set(&apos;aaa&apos;, 100);map.set(&apos;bbb&apos;, 200);map.size // 2map.get(&apos;aaa&apos;) // 100map.has(&apos;aaa&apos;) // truemap.delete(&apos;aaa&apos;)map.has(&apos;aaa&apos;) // falsemap.clear() Map 实例的遍历方法有： 1、keys()：返回键名的遍历器。 2、values()：返回键值的遍历器。 3、entries()：返回所有成员的遍历器。 4、forEach()：遍历 Map 的所有成员 12345678910111213141516171819202122232425262728const map = new Map();map.set('aaa', 100);map.set('bbb', 200);for (let key of map.keys()) &#123;console.log(key);&#125;// \"aaa\"// \"bbb\"for (let value of map.values()) &#123;console.log(value);&#125;// 100// 200for (let item of map.entries()) &#123;console.log(item[0], item[1]);&#125;// aaa 100// bbb 200// 或者for (let [key, value] of map.entries()) &#123;console.log(key, value);&#125;// aaa 100// bbb 200 Promise Promise是 CommonJS 提出来的这一种规范，有多个版本，在 ES6 当中已经纳入规范，原生支持 Promise 对象，非 ES6 环境可以用类似 Bluebird、Q 这类库来支持。 Promise 可以将回调变成链式调用写法，流程更加清晰，代码更加优雅。 简单归纳下 Promise：三个状态、两个过程、一个方法，快速记忆方法：3-2-1 三个状态：pending、fulfilled、rejected 两个过程： 1、pending→fulfilled（resolve） 2、pending→rejected（reject） 当然还有其他概念，如catch、 Promise.all/race，这里就不展开了 123456789101112131415161718192021222324252627282930313233343536 new Promise((resolve,reject)=&gt;&#123; $.ajax(&#123; url : \"xxxxx\", type : \"post\" success(res)&#123; resolve(res) &#125;, error(err)&#123; reject（err） &#125; &#125;); &#125;).then(()=&gt;&#123; &#125;,()=&gt;&#123; &#125;) ES6常用新特性## &lt;a name=\"778mgs\"&gt;&lt;/a&gt;let &amp;&amp; const let 命令也用于变量声明，但是作用域为局部const用于声明一个常量，设定后值不会再改变## &lt;a name=\"96mmga\"&gt;&lt;/a&gt;箭头函数箭头函数是 ES6 中新的函数定义形式，function name(arg1, arg2) &#123;...&#125;可以使用(arg1, arg2) =&gt; &#123;...&#125;来定义。示例如下：```js// JS 普通函数var arr = [1, 2, 3]arr.map(function (item) &#123; console.log(index) return item + 1&#125;)// ES6 箭头函数const arr = [1, 2, 3]arr.map((item, index) =&gt; &#123; console.log(index) return item + 1&#125;) 箭头函数存在的意义，第一写起来更加简洁，第二可以解决 ES6 之前函数执行中this是全局变量的问题（没有独立的作用域），看如下代码123456789101112131415function fn() &#123; console.log('real', this) // &#123;a: 100&#125; ，该作用域下的 this 的真实的值 var arr = [1, 2, 3] // 普通 JS arr.map(function (item) &#123; console.log('js', this) // window 。普通函数，这里打印出来的是全局变量，令人费解 return item + 1 &#125;) // 箭头函数 arr.map(item =&gt; &#123; console.log('es6', this) // &#123;a: 100&#125; 。箭头函数，这里打印的就是父作用域的 this return item + 1 &#125;)&#125;fn.call(&#123;a: 100&#125;) 解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）12345let [a, b, c] = [1, 2, 3];//等同于let a = 1;let b = 2;let c = 3; 对象的解构赋值：获取对象的多个属性并且使用一条语句将它们赋给多个变量 var { StyleSheet, Text, View } = React; 等同于 var StyleSheet = React.StyleSheet; var Text = React.Text; var View = React.Text; 123456789101112## 模块化 import导入模块、export导出模块如果只是输出一个唯一的对象，使用export default即可，代码如下 ```js// 创建 util1.js 文件，内容如export default &#123; a: 100&#125;// 创建 index.js 文件，内容如import obj from &apos;./util1.js&apos;console.log(obj) 如果想要输出许多个对象，就不能用default了，且import时候要加{...}，代码如下 123456789101112// 创建 util2.js 文件，内容如export function fn1() &#123; alert('fn1')&#125;export function fn2() &#123; alert('fn2')&#125;// 创建 index.js 文件，内容如import &#123; fn1, fn2 &#125; from './util2.js'fn1()fn2() 类class class 其实一直是 JS 的关键字（保留字），但是一直没有正式使用，直到 ES6 。 ES6 的 class 就是取代之前构造函数初始化对象的形式，从语法上更加符合面向对象的写法。例如： JS 构造函数的写法 1234567891011121314151617181920212223242526 function MathHandle(x, y) &#123; this.x = x; this.y = y; &#125; MathHandle.prototype.add = function () &#123; return this.x + this.y; &#125;; var m = new MathHandle(1, 2); console.log(m.add())用 ES6 class 的写法```jsclass MathHandle &#123;constructor(x, y) &#123; this.x = x; this.y = y;&#125;add() &#123; return this.x + this.y;&#125;&#125;const m = new MathHandle(1, 2);console.log(m.add()) 注意以下几点，全都是关于 class 语法的：1231、class 是一种新的语法形式，是class Name &#123;...&#125;这种形式，和函数的写法完全不一样2、两者对比，构造函数函数体的内容要放在 class 中的constructor函数中，constructor即构造器，初始化实例时默认执行3、class 中函数的写法是add() &#123;...&#125;这种形式，并没有function关键字 使用 class 来实现继承就更加简单了，至少比构造函数实现继承简单很多。看下面例子JS 构造函数实现继承123456789101112131415// 动物function Animal() &#123; this.eat = function () &#123; console.log('animal eat') &#125;&#125;// 狗function Dog() &#123; this.bark = function () &#123; console.log('dog bark') &#125;&#125;Dog.prototype = new Animal()// 哈士奇var hashiqi = new Dog() ES6 class 实现继承123456789101112131415161718192021class Animal &#123; constructor(name) &#123; this.name = name &#125; eat() &#123; console.log(`$&#123;this.name&#125; eat`) &#125;&#125;class Dog extends Animal &#123; constructor(name) &#123; super(name) this.name = name &#125; say() &#123; console.log(`$&#123;this.name&#125; say`) &#125;&#125;const dog = new Dog('哈士奇')dog.say()dog.eat() 注意以下两点：121、使用extends即可实现继承，更加符合经典面向对象语言的写法，如 Java2、子类的constructor一定要执行super()，以调用父类的constructor Set 和 Map 题目：ES6 中新增的数据类型有哪些？ Set 和 Map 都是 ES6 中新增的数据结构，是对当前 JS 数组和对象这两种重要数据结构的扩展。由于是新增的数据结构，目前尚未被大规模使用，但是作为前端程序员，提前了解是必须做到的。先总结一下两者最关键的地方：1、Set 类似于数组，但数组可以允许元素重复，Set 不允许元素重复2、Map 类似于对象，但普通对象的 key 必须是字符串或者数字，而 Map 的 key 可以是任何数据类型 SetSet 实例不允许元素有重复，可以通过以下示例证明。可以通过一个数组初始化一个 Set 实例，或者通过add添加元素，元素不能重复，重复的会被忽略。 1234567891011// 例1const set = new Set([1, 2, 3, 4, 4]);console.log(set) // Set(4) &#123;1, 2, 3, 4&#125;// 例2const set = new Set();[2, 3, 5, 4, 5, 8, 8].forEach(item =&gt; set.add(item));for (let item of set) &#123;console.log(item);&#125;// 2 3 5 4 8 Set 实例的属性和方法有123451、size：获取元素数量。2、add(value)：添加元素，返回 Set 实例本身。3、delete(value)：删除元素，返回一个布尔值，表示删除是否成功。4、has(value)：返回一个布尔值，表示该值是否是 Set 实例的元素。5、clear()：清除所有元素，没有返回值。 1234567891011121314const s = new Set();s.add(1).add(2).add(2); // 添加元素s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // falses.clear();console.log(s); // Set(0) &#123;&#125; Set 实例的遍历，可使用如下方法12341、keys()：返回键名的遍历器。2、values()：返回键值的遍历器。不过由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys()和values()返回结果一致。3、entries()：返回键值对的遍历器。4、forEach()：使用回调函数遍历每个成员 123456789101112131415161718192021222324252627let set = new Set(['aaa', 'bbb', 'ccc']);for (let item of set.keys()) &#123;console.log(item);&#125;// aaa// bbb// cccfor (let item of set.values()) &#123;console.log(item);&#125;// aaa// bbb// cccfor (let item of set.entries()) &#123;console.log(item);&#125;// [\"aaa\", \"aaa\"]// [\"bbb\", \"bbb\"]// [\"ccc\", \"ccc\"]set.forEach((value, key) =&gt; console.log(key + ' : ' + value))// aaa : aaa// bbb : bbb// ccc : ccc MapMap 的用法和普通对象基本一致，先看一下它能用非字符串或者数字作为 key 的特性。 const map = new Map(); const obj = {p: ‘Hello World’}; map.set(obj, ‘OK’) map.get(obj) // “OK” map.has(obj) // true map.delete(obj) // true map.has(obj) // false 1234567891011121314151617181920212223242526需要使用new Map()初始化一个实例，下面代码中set get has delete顾名即可思义（下文也会演示）。其中，map.set(obj, &apos;OK&apos;)就是用对象作为的 key （不光可以是对象，任何数据类型都可以），并且后面通过map.get(obj)正确获取了Map 实例的属性和方法如下： 1、size：获取成员的数量 2、set：设置成员 key 和 value 3、get：获取成员属性值 4、has：判断成员是否存在 5、delete：删除成员 6、clear：清空所有 ```js const map = new Map();map.set(&apos;aaa&apos;, 100);map.set(&apos;bbb&apos;, 200);map.size // 2map.get(&apos;aaa&apos;) // 100map.has(&apos;aaa&apos;) // truemap.delete(&apos;aaa&apos;)map.has(&apos;aaa&apos;) // falsemap.clear() Map 实例的遍历方法有： 1、keys()：返回键名的遍历器。 2、values()：返回键值的遍历器。 3、entries()：返回所有成员的遍历器。 4、forEach()：遍历 Map 的所有成员 12345678910111213141516171819202122232425262728const map = new Map();map.set('aaa', 100);map.set('bbb', 200);for (let key of map.keys()) &#123;console.log(key);&#125;// \"aaa\"// \"bbb\"for (let value of map.values()) &#123;console.log(value);&#125;// 100// 200for (let item of map.entries()) &#123;console.log(item[0], item[1]);&#125;// aaa 100// bbb 200// 或者for (let [key, value] of map.entries()) &#123;console.log(key, value);&#125;// aaa 100// bbb 200 Promise Promise是 CommonJS 提出来的这一种规范，有多个版本，在 ES6 当中已经纳入规范，原生支持 Promise 对象，非 ES6 环境可以用类似 Bluebird、Q 这类库来支持。 Promise 可以将回调变成链式调用写法，流程更加清晰，代码更加优雅。 简单归纳下 Promise：三个状态、两个过程、一个方法，快速记忆方法：3-2-1 三个状态：pending、fulfilled、rejected 两个过程： 1、pending→fulfilled（resolve） 2、pending→rejected（reject） 当然还有其他概念，如catch、 Promise.all/race，这里就不展开了 1234567891011121314151617181920212223242526272829303132 new Promise((resolve,reject)=&gt;&#123; $.ajax(&#123; url : \"xxxxx\", type : \"post\" success(res)&#123; resolve(res) &#125;, error(err)&#123; reject（err） &#125; &#125;); &#125;).then(()=&gt;&#123; &#125;,()=&gt;&#123; &#125;)# &lt;a name=\"hh0lph\"&gt;&lt;/a&gt;ES7新特性`1.Array.prototype.includes``2.Exponentiation Operator(求幂运算)`## &lt;a name=\"g0nhws\"&gt;&lt;/a&gt;Array.prototype.includesArray.prototype.includes用法都容易和简单。它是一个替代indexOf，开发人员用来检查数组中是否存在值，indexOf是一种尴尬的使用，因为它返回一个元素在数组中的位置或者-1当这样的元素不能被找到的情况下。所以它返回一个数字，而不是一个布尔值。开发人员需要实施额外的检查。在ES6，要检查是否存在值你需要做一些如下图所示小技巧，因为他们没有匹配到值，Array.prototype.indexOf返回-1变成了true（转换成true），但是当匹配的元素为0位置时候，该数组包含元素，却变成了false。```jslet arr = [‘react‘, ‘angular‘, ‘vue‘]// WRONGif (arr.indexOf(‘react‘)) &#123; // 0 -&gt; evaluates to false, definitely as we expectedconsole.log(‘Can use React‘) // this line would never be executed&#125;// Correctif (arr.indexOf(‘react‘) !== -1) &#123;console.log(‘Can use React‘)&#125; 或者使用一点点hack 位运算符 ~ 使代码更加紧凑一些，因为~（位异或）对任何数字相当于-(a + 1): 123456let arr = [‘react‘, ‘angular‘, ‘vue‘]// Correctif (~arr.indexOf(‘react‘)) &#123;console.log(‘Can use React‘)&#125; 在ES7中使用includes代码如下: let arr = [‘react‘, ‘angular‘, ‘vue‘] // Correct if (arr.includes(‘react‘)) { console.log(‘Can use React‘) } 123456789101112131415161718192021 还能在字符串中使用includes: ```js let str = ‘React Quickly‘ // Correct if (str.toLowerCase().includes(‘react‘)) &#123; // true console.log(‘Found &quot;react&quot;‘) &#125;除了增强了可读性语义化，实际上给开发者返回布尔值，而不是匹配的位置。includes也可以在NaN(非数字)使用。最后 ，includes第二可选参数fromIndex，这对于优化是有好处的，因为它允许从特定位置开始寻找匹配。更多例子： console.log([1, 2, 3].includes(2)) // === true) console.log([1, 2, 3].includes(4)) // === false) console.log([1, 2, NaN].includes(NaN)) // === true) console.log([1, 2, -0].includes(+0)) // === true) console.log([1, 2, +0].includes(-0)) // === true) console.log([‘a‘, ‘b‘, ‘c‘].includes(‘a‘)) // === true) console.log([‘a‘, ‘b‘, ‘c‘].includes(‘a‘, 1)) // === false) 总而言之，includes在一个数组或者列表中检查是否存在一个值，给任何开发人员带来简单性。 Exponentiation Operator(求幂运算) 求幂运算大多数是做一些数学计算，对于3D，VR，SVG还有数据可视化非常有用。在ES6或者早些版本，不得不创建一个循环，创建一个递归函数或者使用Math.pow,如果忘记了什么是指数,当你有相同数字（基数）自相相乘多次（指数）。例如，7的3次方是777 所以在ES6/2015ES，你能使用Math.pow创建一个短的递归箭头函数： 1234567891011 calculateExponent = (base, exponent) =&gt; base*((--exponent&gt;1)?calculateExponent(base, exponent):base) console.log(calculateExponent(7,12) === Math.pow(7,12)) // true console.log(calculateExponent(2,7) === Math.pow(2,7)) // true现在在ES7 /ES2016，以数学向导的开发者可以使用更短的语法:```jslet a = 7 ** 12let b = 2 ** 7console.log(a === Math.pow(7,12)) // trueconsole.log(b === Math.pow(2,7)) // true 开发者还可以操作结果:123456let a = 7a **= 12let b = 2b **= 7console.log(a === Math.pow(7,12)) // trueconsole.log(b === Math.pow(2,7)) // true ES8新特性123451、Object.values/Object.entries2、String padding(字符串填充)3、Object.getOwnPropertyDescriptors4、函数参数列表和调用中的尾逗号（Trailing commas）5、异步函数（Async Functions） Object.values/Object.entriesObject.values和 Object.entries是在ES2017规格中，它和Object.keys类似，返回数组类型，其序号和Object.keys序号对应。类似python中的dict.iteritems()。 Object.values,Object.entries和Object.keys各自项返回是数组，相对应包括key,value或者可枚举特定对象property/attribute1234let obj = &#123;a: 1, b: 2, c: 3&#125;Object.keys(obj).forEach((key, index)=&gt;&#123;console.log(key, obj[key])&#125;) 而使用ES6/ES2015 中for/of稍微好点：1234let obj = &#123;a: 1, b: 2, c: 3&#125;for (let key of Object.keys(obj)) &#123;console.log(key, obj[key])&#125; Object.values返回对象自身可以迭代属性值（values）为数组类型。我们最好使用Array.prototype.forEach迭代它，结合ES6的箭头函数隐形返回值：12let obj = &#123;a: 1, b: 2, c: 3&#125;Object.values(obj).forEach(value=&gt;console.log(value)) // 1, 2, 3 String padding(字符串填充)String.prototype.padStart 和 String.prototype.padEnd在javascript字符操作是一个不错的体验，帮助避免依赖而外的库padStart()在开始部位填充，返回一个给出长度的字符串，填充物给定字符串，把字符串填充到期望的长度。从字符串的左边开始（至少大部分西方语言），一个经典例子是使用空格创建列： 12console.log(‘react‘.padStart(10).length) // \" react\" is 10console.log(‘backbone‘.padStart(10).length) // \" backbone\" is 10 Object.getOwnPropertyDescriptorsObject.getOwnPropertyDescriptors允许创建真实的对象浅副本并创建子类,它通过给开发者描述符来做到这一点.在Object.create(prototype, object)放入描述符后，返回一个真正的浅拷贝1234Object.create(Object.getPrototypeOf(obj),Object.getOwnPropertyDescriptors(obj)) 或者你可以合并两个对象target和source如下： 1234Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)) 两种描述符号类型：121.数据描述符（Data descriptor）2.存取器描述符（Accessor descriptor） 存取描述符有必须属性：get 或者set或者get和set两个就是如你所想的getter和setter函数，然后存取描述符还有可选属性configurable和enumerable12345678let azatsBooks = &#123; books: ['React Quickly'],get latest () &#123; let numberOfBooks = this.books.length if (numberOfBooks == 0) return undefined return this.books[numberOfBooks - 1]&#125;&#125; 函数参数列表和调用中的尾逗号尾逗号在函数定义中只是一个纯粹语法变化，在ES5中，将会非法语法，在函数参数后面应该是没有逗号的：12345678var f = function(a,b,c,d) &#123; // NO COMMA!// ...console.log(d)&#125;f(1,2,3,'this') 在ES8中，这种尾逗号是没有问题的：123456789var f = function(a,b,c,d,) &#123; // COMMA? OK!// ...console.log(d)&#125;f(1,2,3,'this') 异步函数异步函数（或者async/await）特性操作是Promise最重要的功能，开发者定义一个asyc函数里面不包含或者包含await 基于Promise异步操作在ES6中我们可以使用Promise，Axios库向GraphQL服务器发送一个请求：123456axios.get(`/q?query=$&#123;query&#125;`).then(response =&gt; response.data).then(data =&gt; &#123; this.props.processfetchedData(data) // Defined somewhere else&#125;).catch(error =&gt; console.log(error)) 任何一个Promise库都能兼容新的异步函数，我们可以使用同步try/catch做错误处理 123456789async fetchData(url) =&gt; &#123;try &#123; const response = await axios.get(`/q?query=$&#123;query&#125;`) const data = response.data this.props.processfetchedData(data)&#125; catch (error) &#123; console.log(error)&#125;&#125; 异步函数返回一个Promise，所以我们像下面可以继续执行流程:123456789101112async fetchData(query) =&gt; &#123;try &#123; const response = await axios.get(`/q?query=$&#123;query&#125;`) const data = response.data return data&#125; catch (error) &#123; console.log(error)&#125;&#125;fetchData(query).then(data =&gt; &#123;this.props.processfetchedData(data)&#125;) 你可以看到这段代码在(Babel REPL)生效。请注意，这个例子中，Axios库被代替的，是通过模拟来做相同功能，而HTTP请求通过setTimout代替：123456789101112131415161718192021let axios = &#123; // mocksget: function(x) &#123;return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123;data: x&#125;) &#125;, 2000)&#125;)&#125;&#125;let query = 'mangos'async function fetchData(query) &#123;try &#123; const response = await axios.get(`/q?query=$&#123;query&#125;`) const data = response.data return data&#125; catch (error) &#123; console.log(error)&#125;&#125;fetchData(query).then(data =&gt; &#123;console.log(data) // Got data 2s later... Can use data!&#125;) async/await,我们的代码执行异步看起来像执行同步一样","tags":[]},{"title":"JS 导出EXCEL文件","date":"2018-12-22T07:02:14.000Z","path":"2018/12/22/JS 导出EXCEL文件/","text":"tags: [组件]categories: 业务场景解决方案 需求：datatable表格，每一行带有checkbox，勾选checkbox导出当前行所有数据，全选则导出所有选中行的数据即实现导出列表选中行数据的功能 1&lt;a class=\"download\" download=\"用户列表\"&gt;导出&lt;/a&gt; 12345678910111213141516171819202122232425262728293031323334353637383940function exportFile() &#123; var dataArr = [];//定义数组用来保存所勾选的列表当前行数据 // 定义表头 var str = `&lt;tr&gt; &lt;th&gt;样本名称&lt;/th&gt; &lt;th&gt;问卷编码&lt;/th&gt; &lt;th&gt;提交时间&lt;/th&gt; &lt;/tr&gt;` // 遍历列表中所购选中的行 $('table').find('tr.hover-bg').each(function() &#123; var Data = new Object(); Data.AreaName = $(this).find('td:eq(1)').html(); Data.DataID= $(this).find('td:eq(2)').html(); Data.EntryTime= $(this).find('td:eq(3)').html(); dataArr.push(Data); &#125;) if($('table').find('tr').hasClass('hover-bg')) &#123; //循环遍历，每行加入tr标签，每个单元格加td标签 for (let i = 0; i &lt; dataArr.length; i++) &#123; str += '&lt;tr&gt;'; for (let item in dataArr[i]) &#123; //增加\\t为了不让表格显示科学计数法或者其他格式 str += `&lt;td&gt;$&#123; dataArr[i][item] + '\\t'&#125;&lt;/td&gt;`; &#125; str += '&lt;/tr&gt;'; &#125; var template = `&lt;html xmlns:o=\"urn:schemas-microsoft-com:office:office\" xmlns:x=\"urn:schemas-microsoft-com:office:excel\" xmlns=\"http://www.w3.org/TR/REC-html40\"&gt; &lt;head&gt;&lt;!--[if gte mso 9]&gt;&lt;xml&gt;&lt;x:ExcelWorkbook&gt;&lt;x:ExcelWorksheets&gt;&lt;x:ExcelWorksheet&gt; &lt;x:Name&gt;'录入列表.xls'&lt;/x:Name&gt; &lt;x:WorksheetOptions&gt;&lt;x:DisplayGridlines/&gt;&lt;/x:WorksheetOptions&gt;&lt;/x:ExcelWorksheet&gt; &lt;/x:ExcelWorksheets&gt;&lt;/x:ExcelWorkbook&gt;&lt;/xml&gt;&lt;![endif]--&gt; &lt;/head&gt;&lt;body&gt;&lt;table&gt;$&#123;str&#125;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;`; // 实例化一个 Blob 对象，其构造函数的第一个参数是包含文件内容的数组，第二个参数是包含文件类型属性的对象 var blob = new Blob([template], &#123;type: \"application/vnd.ms-excel\"&#125;); $('.download').attr('href', URL.createObjectURL(blob)); &#125;&#125; SheetJS 同时适用于Browser/Nodejs环境的电子表格编辑库，主要功能包括： 读取并解析Excel文件 编辑表格内容 将数据以Excel文件形式导出","tags":[]},{"title":"JS 引擎工作原理","date":"2018-12-22T07:00:43.000Z","path":"2018/12/22/JS 引擎工作原理/","text":"JS 引擎 宿主环境：是由外壳程序生成的，比如浏览器就是一个外壳环境（但是浏览器并不是唯一，很多服务器、桌面应用系统都能也能够提供 JavaScript 引擎运行的环境）。 执行期环境：则由嵌入到外壳程序中的 JavaScript 引擎（比如 V8 引擎，不同浏览器可能所用引擎不一样）生成，初始化： 一套与宿主环境相关联系的规则 JS 引擎内核(基本语法规则、逻辑、命令和算法) 一组 内置对象 和 API 其他约定不同的 JS 引擎定义初始化环境是不同的，从而形成了浏览器兼容性问题 编译原理 分词/词法分析（Tokenizing/Lexing）分词：将一句话，按照词语的最小单位进行分割词法单元(token)：将一串串代码拆解成有意义的代码块例如：var a = 2 分解成 var a = 2 ；空格是否作为词法单位，取决于空格在这门语言中是否具有意义 解析/语法分析(Parsing)将“词法单元流”转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，即抽象语法树(AST, Abstract Syntax Tree) 词法分析和语法分析不是完全独立的，而是交错进行的，也就是说，词法分析器不会在读取所有的词法记号后再使用语法分析器来处理。在通常情况下，每取得一个词法记号，就将其送入语法分析器进行分析。 语法分析的过程就是把词法分析所产生的记号生成语法树，通俗地说，就是把从程序中收集的信息存储到数据结构中。注意，在编译中用到的数据结构有两种：符号表和语法树。 符号表：就是在程序中用来存储所有符号的一个表，包括所有的字符串变量、直接量字符串，以及函数和类。 语法树：就是程序结构的一个树形表示，用来生成中间代码。下面是一个简单的条件结构和输出信息代码段，被语法分析器转换为语法树之后，如： 1234567if (typeof a == \"undefined\") &#123; a = 0;&#125; else &#123; a = a;&#125;alert(a); 如果 JavaScript 解释器在构造语法树的时候发现无法构造，就会报语法错误，并结束整个代码块的解析。对于传统强类型语言来说，在通过语法分析构造出语法树后，翻译出来的句子可能还会有模糊不清的地方，需要进一步的语义检查。 语义检查的主要部分是类型检查。例如，函数的实参和形参类型是否匹配。但是，对于弱类型语言来说，就没有这一步。 经过编译阶段的准备， JavaScript 代码在内存中已经被构建为语法树，然后 JavaScript 引擎就会根据这个语法树结构边解释边执行。 代码生成将 AST 转换成可执行代码的过程被称为代码生成。这个过程与语言、目标平台相关。 了解完编译原理后，其实 JavaScript 引擎要复杂的许多，因为大部分情况，JavaScript 的编译过程不是发生在构建之前，而是发生在代码执行前的几微妙，甚至时间更短。为了保证性能最佳，JavaScipt 使用了各种办法。 V8 引擎 当 V8 编译 JavaScript 代码时，解析器(parser)将生成一个抽象语法树(上一小节已介绍过)。语法树是 JavaScript 代码的句法结构的树形表示形式。解释器 Ignition 根据语法树生成字节码。TurboFan 是 V8 的优化编译器，TurboFan 将字节码(Bytecode)生成优化的机器代码(Machine Code)。 两个编译器full-codegen - 一个简单而快速的编译器，可以生成简单且相对较慢的机器代码。Crankshaft - 一种更复杂的（即时）优化编译器，可生成高度优化的代码。 多线程 主线程：获取代码，编译代码然后执行它 优化线程：与主线程并行，用于优化代码的生成 Profiler 线程:它将告诉运行时我们花费大量时间的方法，以便 Crankshaft 可以优化它们 其他一些线程来处理垃圾收集器扫描 字节码 字节码是机器代码的抽象。如果字节码采用和物理 CPU 相同的计算模型进行设计，则将字节码编译为机器代码更容易。这就是为什么解释器（interpreter）常常是寄存器或堆栈。 Ignition 是具有累加器的寄存器。 头文件 bytecodes.h（https://github.com/v8/v8/blob/master/src/interpreter/bytecodes.h） 定义了 V8 字节码的完整列表。 在早期的 V8 引擎里，在多数浏览器都是基于字节码的，V8 引擎偏偏跳过这一步，直接将 jS 编译成机器码，之所以这么做，就是节省了时间提高效率，但是后来发现，太占用内存了。最终又退回字节码了，之所以这么做的动机是什么呢？ 减轻机器码占用的内存空间，即牺牲时间换空间。（主要动机） 提高代码的启动速度 对 v8 的代码进行重构。 降低 v8 的代码复杂度。 V8 引擎为什么那么快内联（Inlining）内联特性是一切优化的基础，对于良好的性能至关重要，所谓的内联就是如果某一个函数内部调用其它的函数，编译器直接会将函数中的执行内容，替换函数方法。 12345678910111213141516function add(a, b) &#123; return a + b;&#125;function calculateTwoPlusFive() &#123; var sum; for (var i = 0; i &lt;= 1000000000; i++) &#123; sum = add(2 + 5); &#125;&#125;var start = new Date();calculateTwoPlusFive();var end = new Date();var timeTaken = end.valueOf() - start.valueOf();console.log(\"Took \" + timeTaken + \"ms\"); 由于内联属性特性，在编译前，代码将会被优化成12345678910111213141516function add(a, b) &#123; return a + b;&#125;function calculateTwoPlusFive() &#123; var sum; for (var i = 0; i &lt;= 1000000000; i++) &#123; sum = 2 + 5; &#125;&#125;var start = new Date();calculateTwoPlusFive();var end = new Date();var timeTaken = end.valueOf() - start.valueOf();console.log(\"Took \" + timeTaken + \"ms\"); 隐藏类（Hidden class）例如 C++/Java 这种静态类型语言的每一个变量，都有一个唯一确定的类型。因为有类型信息，一个对象包含哪些成员和这些成员在对象中的偏移量等信息，编译阶段就可确定，执行时 CPU 只需要用对象首地址 —— 在 C++中是 this 指针，加上成员在对象内部的偏移量即可访问内部成员。这些访问指令在编译阶段就生成了。 但对于 JavaScript 这种动态语言，变量在运行时可以随时由不同类型的对象赋值，并且对象本身可以随时添加删除成员。访问对象属性需要的信息完全由运行时决定。为了实现按照索引的方式访问成员，V8“悄悄地”给运行中的对象分了类，在这个过程中产生了一种 V8 内部的数据结构，即隐藏类。隐藏类本身是一个对象 内联缓存（Inline caching） 正常访问对象属性的过程：首先获取隐藏类的地址，然后根据属性名查找偏移值，然后计算该属性的地址。虽然相比以往在整个执行环境中查找减小了很大的工作量，但依然比较耗时。能不能将之前查询的结果缓存起来，供再次访问呢？ 内嵌缓存：将初次查找的隐藏类和偏移值保存起来，当下次查找的时候，先比较当前对象是否是之前的隐藏类，如果是的话，直接使用之前的缓存结果，减少再次查找表的时间。当然，如果一个对象有多个属性，那么缓存失误的概率就会提高，因为某个属性的类型变化之后，对象的隐藏类也会变化，就与之前的缓存不一致，需要重新使用以前的方式查找哈希表 内存管理内存的管理主要由分配和回收两个部分构成： Zone: 管理小块内存。先自己申请一块内存，然后管理和分配一些小内存，当一块小内存被分配后，不能被 Zone 回收，只能一次性回收 Zone 分配的所有小内存。当一个过程需要很多内存，Zone 将需要分配大量的内存，却又不能及时回收，会导致内存不足的情况 堆： 管理 JS 使用的数据、生成的代码、哈希表等。为方便实现垃圾回收，堆被分为三个部分 年轻分代：为新创建的对象分配内存空间，经常需要进行垃圾回收。为方便年轻分代中的内容回收，可再将年轻分代分为两半，一半用来分配，另一半在回收时负责将之前还需要保留的对象复制过来 年老分代：根据需要将年老的对象、指针、代码等数据保存起来，较少地进行垃圾回收 大对象：为那些需要使用较多内存对象分配内存，当然同样可能包含数据和代码等分配的内存，一个页面只分配一个对象 垃圾回收V8 使用了分代和大数据的内存分配，在回收内存时使用精简整理的算法标记未引用的对象，然后消除没有标记的对象， 整理和压缩那些还未保存的对象，即可完成垃圾回收 为了控制GC 成本并使执行更加稳定，V8 使用增量标记，而不是遍历整个堆，它试图标记每个可能的对象，只遍历一部分堆，然后恢复正常的代码执行。下一次 GC 将继续从之前的遍历停止的位置开始。这允许在正常执行期间非常短的暂停。 如前所述，扫描阶段由单独的线程处理。 优化回退V8 为了进一步提升 JS 代码的执行效率，编译器直接生成更高效的机器码。程序在运行时，V8 会采集 JS 代码运行数据。当 V8 发现某函数执行频繁(内联函数机制)，就将其标记为热点函数。针对热点函数，V8 的策略较为乐观，倾向于认为此函数比较稳定，类型已经确定，于是编译器，生成更高效的机器码。后面的运行中，万一遇到类型变化，V8 采取将 JS 函数回退到优化前的编译成机器字节码。 123456789101112131415161718// 片段 1var person = &#123; add: function(a, b) &#123; return a + b; &#125;&#125;;obj.name = \"li\";// 片段 2var person = &#123; add: function(a, b) &#123; return a + b; &#125;, name: \"li\"&#125;; 以上代码实现的功能相同，都是定义了一个对象，这个对象具有一个属性 name 和一个方法 add()。但使用片段 2 的方式效率更高。片段 1 给对象 obj 添加了一个属性 name，这会造成隐藏类的派生。给对象动态地添加和删除属性都会派生新的隐藏类。假如对象的 add 函数已经被优化，生成了更高效的代码，则因为添加或删除属性，这个改变后的对象无法使用优化后的代码。 从例子中我们可以看出：函数内部的参数类型越确定，V8 越能够生成优化后的代码。 写更优化的代码 对象属性的顺序：始终以相同的顺序实例化对象属性，以便可以共享隐藏类和随后优化的代码 动态属性：在实例化后向对象添加属性将强制隐藏类更改，并任何为先前隐藏类优化的方法变慢，所以，使用在构造函数中分配对象的所有属性来代替 方法：重复执行相同方法的代码将比只执行一次的代码(由于内联缓存)运行的快 数组：避免键不是增量数字的稀疏数组，稀疏数组是一个哈希表，这种阵列中的元素访问消耗较高，另外，尽量避免预分配大型数组，最好按需分配，自动增加。最后，不要删除数组中的元素，它使键稀疏。","tags":[]},{"title":"浏览器渲染原理","date":"2018-12-22T07:00:25.000Z","path":"2018/12/22/浏览器渲染原理/","text":"处理 HTML 并构建 DOM 树 处理 CSS 构建 CSSOM 树 将 DOM 与 CSSOM 合并成一个渲染树 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上 参考资源How Browsers Work","tags":[]},{"title":"React Hooks","date":"2018-12-22T06:58:52.000Z","path":"2018/12/22/React Hooks/","text":"前期准备要把 react 和 react-dom 更新到 16.7.0-alpha 及以上，如果配置了 ESLint，记得添加对应的 Plugin。（安装插件能够帮助你不弄错每个盒子和状态的对应关系，书写的时候 Hooks 需要 use 开头且放在顶层作用域，即不可以包裹 if/switch/when/try 等） React Hooks 的本质 Hooks 本质是把面向生命周期编程变成了面向业务逻辑编程； Hooks 使用上是一个逻辑状态盒子，输入输出表示的是一种联系； Hooks 是 React 的未来，但还是无法完全替代原始的 Class。 面向生命周期编程 =》面向业务逻辑编程 == ===》 业务逻辑复用这里说的业务逻辑复用主要是需要跨生命周期的业务逻辑。单单按照组件堆积的形式组织代码虽然也可以达到各种复用的目的，但是会导致组件非常复杂，数据流也会很乱。组件堆积适合 UI 布局，但是不适合逻辑组织。为了解决这些问题，在 React 发展过程中，产生了很多解决方案， Mixins坏处远远大于带来的好处，因为现在已经不再支持，不多说，可以看看这篇文章：Mixins Considered Harmful。 Class Inheritance官方 很不推荐此做法 High-Order Components (HOC)React 高阶组件 在封装业务组件上简直是屡试不爽，它的实现是把自己作为一个函数，接受一个组件，再返回一个组件，这样它可以统一处理掉一些业务逻辑并达到复用目的。 比较常见的一个就是 react-redux 里的 connect 函数： 但是在调试的时候可以看到会产生“组件嵌套地狱” Render PropsRender Props 其实很常见，比如 React Context API： 1234567891011class App extends React.Component &#123; render() &#123; return ( &lt;ThemeProvider&gt; &lt;ThemeContext.Consumer&gt; &#123;val =&gt; &lt;div&gt;&#123;val&#125;&lt;/div&gt;&#125; &lt;/ThemeContext.Consumer&gt; &lt;/ThemeProvider&gt; ) &#125;&#125; 它的实现思路很简单，把原来该放「组件」的地方，换成了回调，这样当前组件里就可以拿到子组件的状态并使用。 但是，同样这会产生 Wrapper Hell 问题： 状态盒子Hooks 只能在其它 Hooks 的函数或者 React Function 组件里。 React 社区一直推崇函数式、纯函数等思想，引入 Hooks 概念后的 Functional Component 变的不再纯了，useXxx 与其说是一条执行语句，不如说是一个声明。声明这里放了一个「状态盒子」，盒子有输入和输出，剩下的内部实现就一无所知，重要的是，盒子是有记忆的，下次执行到此位置时，它有之前上下文信息。 类比「代码」和「程序」的区别，前者是死的，后者是活的。表达式 c = a + b 表示把 a 和 b 累加后的值赋值给 c，但是如果写成 c := a + b 就表示 c 的值由 a 和 b 相加得到。看起来表述差不多，但实际上，后者隐藏着一个时间的维度，它表示的是一种联系，而不单单是个运算。这在 RxJS 等库中被大量使用。 这种声明目前是通过很弱的 use 前缀标识的（但是设计上会简洁很多），为了不弄错每个盒子和状态的对应关系，书写的时候 Hooks 需要 use 开头且放在顶层作用域，即不可以包裹 if/switch/when/try 等。如果你按文章开头引入了那个 ESLint Plugin 就不用担心会弄错了。 FragmentWrapper Hell，我个人觉得使用 Fragment 也可以基本解决。 案例讲解功能需求根据 input 的输入值更改网页的 title 信息 Class Component123456789101112131415161718192021import React from 'react'class ChangeTile extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; title = '' &#125; &#125; handleChage(title) &#123; this.setState(&#123; title &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;input value=&#123;this.state.title&#125; onChange=&#123;this.handleChage(title)&#125; /&gt; &lt;/div&gt; ) &#125;&#125; Hooks 写法12 后记HOC 和 Render Props 还是有存在的必要，一方面是支持 React Class，另一方面，它们不光适用于纯逻辑封装，很多时候也适合逻辑 + 组件的封装场景，虽然此时使用 Hooks 也可以，但是会显得啰嗦点。 参考资源官网文档 Making Sense of React Hookshttps://www.yuque.com/es2049/blog","tags":[]},{"title":"搭建一个脚手架","date":"2018-12-22T06:35:16.000Z","path":"2018/12/22/搭建一个脚手架/","text":"tags: [组件]categories: 前端工程化 脚手架功能需求 代码检测 文档工具 规范的项目组织结构 ES 规范与浏览器兼容性不一致 CSS 弱编程能力 资源定位 图片压缩|base64 内嵌| CSS Sprites 模块依赖分析和压缩打包 自动化工具，提高效率 数据 mock 服务层封装 路由配置 react-devtool 配置 数据状态管理配置选型（redux|mobix) 性能提升？(immutable) 推荐工具lerna管理前端 multiple packages 项目的工具 官网 lerna 入门指南 monorepo 新浪潮 | introduce lerna 文档工具 storybook：通过 JS(JSX) 文件写 examples React Styleguidist：通过 Markdown 文件写 examples docz: markdown 与 react 的结合，十分方便的工具 docsite: 快速搭建静态站点，对国际化支持很好 docsify官方网站 ydoc ydoc-plugin-vue-styleguide Vue Styleguidist noox: The best template engine for JavaScript, base on React Jsx VuePress官方文档 MkDocs 中文文档 推荐 npm 包 new-component：自动初始化React组件所需的初始化代码 环境准备Node | npm | git Yeoman安装1234npm install -g yo # 安装 Yeomanyo --versionnpm install -g generator-fountain-webapp # 安装 Yeoman 生成器，目前可用的生成器超过了 3500 个yo # 选择 Install a generator 来搜索发布的生成器 使用生成器搭建我们的app12mkdir mytodo &amp;&amp; cd mytodoyo # 选中 Fountain Webapp，按回车 enter 运行生成器 FountainJS 生成器提供一些选项来匹配你的喜好: 框架（React，Angular2，Angular1） 模块管理工具（Webpack，SystemJS，none with bower） JavaScript预处理器（babel，TypeScript，none） css 预处理器（Sass，Less，none） 三个模板app（a landing page，hello world，TodoMVC） 生成器生成的目录结构 src： web应用的父目录 conf：配置文件及第三方工具的父目录（Bowersync，Webpack，Gulp，karma） Bowersync: 会监测你的文件的变化然后自动加载(通过配置 gulpfile.js 中的 gulp tasks 以及 gulp_tasks/browsersync.js 中的 Browsersync 实现) gulp_tasks 和 gulpfile.js：构建任务 .babelrc，package.json，node_modules：配置以及所需依赖包 .gitattributes 和 .gitignore：git的配置","tags":[]},{"title":"坑及报错","date":"2018-12-22T06:28:36.000Z","path":"2018/12/22/坑及报错/","text":"storybook 3 + babel 7 导致出错storybook 3 默认使用的是 babel 6如果你出现了这个问题，你可以求助于 babel-core@7.0.0-bridge.0，这个库可以做桥接工作 Can’t resolve xxxx这个问题往往是模块解析问题，但是可能原因不少，你可以考虑的几个点有： babel 的模块配置 webpack 配置（比如 resolve.modules 这些配置） tsconfig.json（如果你用了 ts 的话也请看一下 ts 的模块配置） 内置模块重复安装，模块版本不一致，将pkg中的依赖模块删除，然后删除整个node_modules重新安装 路径问题 @myc/components Not Found如果你用 yarn 直接在 storybook 目录下企图安装新依赖会失败因为这个包是我们本地正在开发的，不在 npm 上，你应该使用 lerna 的 bootstrap 命令来安装依赖（lerna 实际上是以链接的形式安装的） Failed propType: Invalid prop AAA of type BBB supplied to CCC, expected DDD. Check the render method of EEE.请确保你传递给组件的参数类型正确。 Unknown option: xxx/package.json.presets这里有一篇来自 Stack Overflow 的回答可以参考。 Invariant Violation: findComponentRoot(…): Unable to find element.你或许引入了 React 两次。如果你使用 webpack，请将 React &amp; ReactDOM 设置为 external。如果你使用其他工具（browserify 等），请阅读它们的文档并将 React &amp; ReactDOM 设置为 external。 Warning: defaultValue is invalid for getFieldDecorator will set value, please use option.initialValue instead.解决方案：外加加一个divantd中setFieldsValue和defaultVal react-styleguidist 版本 与 eslint 同时升级以后导致文档demo import 新特性无法使用 降级后得到解决 gulp less() 转换报错添加 javascriptEnabled: true 属性 less 变量会导致样式难以定位的问题最好有 source-map 文件 styleguid 打包后无报错，mac上没有问题，但是windows导致左侧锚点点击只能点击一次，无法点击第二次，包裹层被挤到z-index上层，导致无法继续点击链接跳转","tags":[]},{"title":"前后端分离","date":"2018-12-22T01:59:50.000Z","path":"2018/12/22/前后端分离/","text":"tags: [组件]categories: 前端工程化 前言前后端分离为什么出现？本质上是什么？前后端分离运动对 web 应用的架构带来了怎么样的变化？前后端分离怎么分离？为什么是 Node.js? 前后端分离的未来怎样？ 互联网分层架构，为啥要前后端分离？ Why传统的后段服务支撑不了现代化的前端开发。平时工作中用到的工具链、开发框架、规范协议、浏览器等在不断涌现，这些新的技术在给开发环境、开发流程提了更多新需求。Node.js 在这个背景下能够把这些工具串联起来。 How模板层的分工最早的 Java 开发阶段需要一个包含所有内容的 war 包，整个前端的编排，像 HTML 页面、CSS、JS 很多时候包含在 HTML 页面，也会出现脚本复用、样式复用抽离出来。所以前端开发当时是围绕著名的 velocity 模版。这一层最大的问题是，后端的同学看前端资源像看天书，前端同学看后端模版也像是看天书，融合效率非常低。 静态资源独立部署 Web 前端体验最大的改进就是副客户端，客户端资源非常庞大，代码不再是直接发布到线上，而是要编译，做预处理，可能还要做 CDN 的加速。整个应用被分割成两部分，后端服务发布之后，前端服务要独立更新，这样就给应用的更新带来了便利。这里存在一个问题是接口的协调，前端的需求变更，数据的要求也会变化，需要后端去协调资源的编排。另外一个问题是测试，前端持有脚本，样式资源，而模版却在应用层，应用层的开发、发布也是很复杂的。 独立应用层（BFF） Node.js 提供 mock 数据开始，前端代码的预编译，资源编排，这些动作都合并到一个应用里面，前端形成 UI 应用层。在这一层，前端具备了更灵活、强大的能力，在数据编排这一层，Node.js 可以做轻量的粘合，服务端的开发也在往微服务方向发展，提升了开发效率。 后端相关的接口回退到 API，或者云端。 BFF 层业务层的需求很多，在流程控制、数据转换、数据安全、分析展现等方面需要有大量的组件沉淀。最大的特点是有众多独立的功能模块。 在 server 层Babeljs 可以做代码转换的事情，Bigpipe 可以优化服务端的内存，可以缩减渲染时间，提升体验优化。在数据流里可以有很多的 filter，给数据链中插入 processor，来定义处理微小的数据。用户在原始的数据到完整的可视化展现不需要再搭建一个产品去支持，只需要搭几个 filter，配几个数据源，拖几个组件就可以完成。 定制应用框架通过“定制应用框架”解决前端的编译，工程管理，数据 mock 等问题 微应用分割把各自独立的模块应用切割成微应用，一个微应用解决一个问题，便于分工和隔离处理。 具体做法是微服务拆分，搭建微应用服务，承载大量的小服务，同时也会出现很多域名的问题，很多访问入口。这里做了一些小创新，在入口可以定义端口，sever name，访问 path，当把一个场景分成 10 个应用发布，发布之后再根据不同的路径拼接成一个应用，对体验没有影响。 除了路由自动化规划之后，对应用的发布做到上下平滑，不会影响流量。前端人员自己打包发布就可以了。 运维工程化当这些应用被分割的很细致之后，随之而来的是如何管理这些小应用。 比如有两台机器做互备，把所有小 App 都发布到上面之后，由一个个小颗粒组成一个大应用，看上去很像一个蜂巢，因此命名 honeycomb，这些蜂巢组成一个大蜂窝，完成一个主功能。在应用推进过程中，有些应用压力大，需要把应用集群隔离开，把有不同业务需求场景环境，例如开发环境、预发环境、线上环境隔离开来，不同环境配置的集群资源和机器数量都不一样。随着业务发展，隔离的事情会交给容器去执行。 密集计算问题密集计算分成两层，第一层绿色部分会接收用户请求，第二层浅蓝色会处理用户请求，写很多的 processor，提供大量的进程去提供密集计算。 主要问题在于 CPU 容量是恒定的，当有很多并发请求的时候，如何保证在服务层去很好的分配计算任务。拆成两层之后，保证用户请求不会被 block 掉。如果第一层大量的密集计算，会导致用户的请求或者连接的需求被挡住，接收不到响应，所以要往后堆，做成队列，可扩容的大集群。整个结果在 Java 里就可以理解为 Java 庞大线程的处理过程。 社区里在线程库里还有一些尝试，Napa.js 是微软开源的线程库，前端同构的需求可以探索使用 Napa.js 这个工具。","tags":[]},{"title":"前端业务代码工具库","date":"2018-12-22T01:47:14.000Z","path":"2018/12/22/前端业务代码工具库/","text":"outils[ [ 前端业务代码工具库 目的：高效率完成前端业务代码 业务开发过程中，会经常用到日期格式化、url参数转对象、浏览器类型判断、节流函数等常用函数，为避免不同项目多次复制粘贴的麻烦，这里统一封装，并发布到npm，以提高开发效率。如果你也有常用的代码，欢迎为本项目提交pr。 安装使用 直接下载min目录下的outils.min.js使用，支持UMD通用模块规范 使用npm安装 浏览器:1234&lt;script src=&quot;outils.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var OS = outils.getOS()&lt;/script&gt; npm:1$ npm install --save-dev outils webpack、RequireJS、SeaJS等 123// 完整引入const outils = require(&apos;outils&apos;)const OS = outils.getOS() 推荐使用方法 你真的不需要完整引入所有函数，所以只引入需要使用的方法即可。123// 只引入部分方法(&apos;outils/&lt;方法名&gt;&apos;)const getOS = require(&apos;outils/getOS&apos;)const OS = getOS() API文档ArrayarrayEqual 判断两个数组是否相等ClassaddClass 为元素添加classhasClass 判断元素是否有某个classremoveClass 为元素移除classCookiegetCookie 根据name读取CookieremoveCookie 根据name删除CookiesetCookie 添加CookieDevicegetExplore 获取浏览器类型和版本号getOS 获取操作系统类型DomgetScrollTop 获取滚动条距顶部的距离offset 获取一个元素的距离文档(document)的位置，类似jQ中的offset()scrollTo 在\\${duration}时间内，滚动条平滑滚动到\\${to}指定位置setScrollTop 设置滚动条距顶部的距离windowResize H5软键盘缩回、弹起回调Functiondebounce 函数防抖throttle 函数节流KeycodegetKeyName 根据keycode获得键名ObjectdeepClone 深拷贝，支持常见类型isEmptyObject 判断Object是否为空RandomrandomColor 随机生成颜色randomNum 生成指定范围随机数RegexpisEmail 判断是否为邮箱地址isIdCard 判断是否为身份证号isPhoneNum 判断是否为手机号isUrl 判断是否为URL地址StringdigitUppercase 现金额转大写SupportisSupportWebP 判断浏览器是否支持webP格式图片TimeformatPassTime 格式化\\${startTime}距现在的已过时间formatRemainTime 格式化现在距\\${endTime}的剩余时间UrlparseQueryString url参数转对象stringfyQueryString 对象序列化","tags":[]},{"title":"前端工程师必备技能图谱","date":"2018-12-21T12:47:27.000Z","path":"2018/12/21/前端工程师必备技能图谱/","text":"tags: [组件]categories: 底层原理及基础","tags":[]},{"title":"如何管理好10万行代码的前端单页面应用","date":"2018-12-21T12:41:56.000Z","path":"2018/12/21/如何管理好10万行代码的前端单页面应用/","text":"tags: [组件]categories: service ToB产品特点 业务复杂度高、业务理解门槛高； 前端代码量巨大 架构方案架构的目的是管理复杂度，将复杂问题分而治之、有效管理 通过路由切割“页面级”粒度的功能模块 同一“页面”内的模块再划分 纵向：通过业务功能（可根据视图模块判断）划分 横向：通过Model-View-Controller三种不同职能划分 合并同类项：细分粒度，将可复用模块或组件抽离到公共区域 数据模型： Domain Model 领域模型：详见ORM层 App State Modal 应用状态模型：详见应用状态模型 UI组件： Container Component： 详见容器型组件 Presentational Component：详见展示型组件 公共服务： 所有的HTTP请求放在一起统一管理 日志服务、本地存储服务、错误监控、Mock服务等统一存放在公共服务层； 跨模块通信 合并同类项 ORM层（Domain Model Layer）持久化到数据库或localStorage中，属于可跨模块复用的公共业务数据如：Users 用户信息 | Datasets 数据集信息 | Reports 报表信息 抽离该公共层的好处： 跨模块数据同步问题不复存在： 例如：之前Users对象在A和B两个业务模块中单独存储，A模块变更Users对象后，需将Users变更同步到B模块中，如不同步，A、B模块在界面上呈现的User信息不一致，下沉到领域模型层统一管理后，问题不复存在； 除领域模型复用外，还可复用领域模型相关的CRUD Reducer： 例如：之前Users对象对应的Create Read Update Delete方法可能在A和B两个业务模块各维护一套，下沉到领域模型层统一管理后，减少了代码重复问题； 自然承担了部分跨模块通信职责： 之前数据同步相关的跨模块通信代码没有了存在的必要性； 应用状态模型应用状态模型是与视图相关的状态数据：这些数据与具体的视图模块或业务功能强相关，建议存放在业务模块的Model中。如： 当前页面选中了列表的第n行 currentSelectedRow: someId 窗口是否处于打开状态 isModalShow: false 某种视图元素是否在拖拽中 isDragging: true 容器型组件容器型组件是与store直连的组件，为展示型组件或其它容器组件提供数据和行为，尽量避免在其中做一些界面渲染相关的事情。 展示型组件展示型组件独立于应用的其它部分内容，不关心数据的加载和变更，保持职责单一，仅做视图呈现和最基本交互行为，通过props接收数据和回调函数输出结果，保证接收的数据为组件数据依赖的最小集。 如果展示型组件粒度切分能很好的遵循高内聚低耦合和职责单一原则的话，可以沉淀出很多可复用的通用业务组件。 跨模块通信模块粒度逐渐细化，会带来更多的跨模块通信诉求，为避免模块间相互耦合、确保架构长期干净可维护，建议将跨模块通信的逻辑代码放在父模块中，或者在一个叫做Mediator层中单独维护 不允许在一个模块内部直接调用其他模块的Dispatch方法（写操作、变更其他模块的state） 不允许在一个模块内部直接读取其他模块的state方法（读操作） 数据流管理纯函数：入参相同的情况下，返回值恒等非纯函数：函数中如果包含 Math.random，new Date(), 异步请求等内容，且影响到最终结果的返回，即为非纯函数 监听Store变更刷新视图的功能是由react-redux完成的： &lt;Provider&gt; 组件通过context属性向后代&lt;connect&gt;组件提供（provide）store对象； &lt;connect&gt; 是一个高阶组件，作用是将store与view层组件连接起来（这里重复提一句，redux官方将&lt;connect&gt;直接连接的组件定义为container component），&lt;connect&gt;向开发者开放了几个回调函数钩子（mapStateToProps, mapDispatchToProps…）用于自定义注入 container component 的 props 的姿势； react-redux 监听 redux store 的变更，store 改变后通知每一个 connect 组件刷新自己和后代组件，为了减少不必要的刷新提升性能，connect 实现了 shouldComponentUpdate 方法，如果 props 不变的话，不刷新 connect 包裹的 container component；","tags":[{"name":"组件","slug":"components","permalink":"http://lulustyle.net/tags/components/"}]},{"title":"Webpack 中 publicPath 详解","date":"2018-12-21T12:39:18.000Z","path":"2018/12/21/Webpack 中 publicPath 详解/","text":"tags: [组件]categories: 前端工程化 outputoutput.path 默认值：process.cwd() 只是指示输出的目录，对应一个绝对路径 output: {path: path.resolve(__dirname, &#39;../dist&#39;),} output.publicPath 默认值：空字符串 帮助你为项目中的所有资源指定一个基础路径，它被称为公共路径(publicPath) 所有资源的基础路径: 项目中引用css，js，img等资源时候的一个基础路径,要配合具体资源中指定的路径使用 静态资源最终访问路径 =output.publicPath+ 资源loader或插件等配置路径 静态资源最终访问路径: 在使用html-webpack-plugin打包后得到的html中可以看到 相对路径: 相对于build之后的index.html(如果设置publicPath: &#39;./dist/&#39;，则打包后js的引用路径为./dist/build.js) 将publicPath设置成/,则打包后访问路径为localhost:8080/dist/main.js，本地无法访问 一般情况下publicPath应该以’/‘结尾，而其他loader或插件的配置不要以’/‘开头 1234567891011121314151617181920212223output.publicPath = '/dist/'// imageoptions: &#123; name: 'img/[name].[ext]?[hash]'&#125;// 最终图片的访问路径为output.publicPath + 'img/[name].[ext]?[hash]' = '/dist/img/[name].[ext]?[hash]'// js output.filenameoutput: &#123; filename: '[name].js'&#125;// 最终js的访问路径为output.publicPath + '[name].js' = '/dist/[name].js'// extract-text-webpack-plugin cssnew ExtractTextPlugin(&#123; filename: 'style.[chunkhash].css'&#125;)// 最终css的访问路径为output.publicPath + 'style.[chunkhash].css' = '/dist/style.[chunkhash].css' webpack-dev-server中的publicPath 在开发阶段，我们借用devServer启动一个开发服务器进行开发，这里也会配置一个publicPath webpack-dev-server中的publicPath路径下的打包文件可以在浏览器中访问。而静态资源仍然使用output.publicPath webpack-dev-server打包的内容是放在内存中的，这些打包后的资源对外的的根目录就是publicPath 通过访问 http://localhost:8080/webpack-dev-server可以得到devServer启动后的资源访问路径，点击静态资源可以看到静态资源的访问路径为 http://localhost:8080${publicPath}index.html 123456// 假设devServer的publicPath为const publicPath = &apos;/dist/&apos;// 则启动devServer后index.html的位置为const htmlPath = `$&#123;pablicPath&#125;index.html`// 包的位置cosnt mainJsPath = `$&#123;pablicPath&#125;main.js` 以上可以直接通过http://lcoalhost:8080/dist/main.js访问到 html-webpack-plugin中的会受到路径影响的属性template 作用：用于定义模版文件的路径 源码：this.options.template = this.getFullTemplatePath(this.options.template, compiler.context); 因此template只有定义在webpack的context下才会被识别，webpack context的默认值为process.cwd()，即运行 node 命令时所在的文件夹的绝对路径 filename 作用：输出的HTML文件名，默认为index.html，可以直接配置带有子目录 源码：this.options.filename = path.relative(compiler.options.output.path, filename); 所以filename的路径是相对于output.path的，而在webpack-dev-server中，则是相对于webpack-dev-server配置的publicPath。 如果webpack-dev-server的publicPath和output.publicPath不一致，在使用html-webpack-plugin可能会导致引用静态资源失败，因为在devServer中仍然以output.publicPath引用静态资源，和webpack-dev-server的提供的资源访问路径不一致，从而无法正常访问。 有一种情况除外，就是output.publicPath是相对路径，这时候可以访问本地资源 所以一般情况下都要保证devServer中的publicPath与output.publicPath保持一致。 路径斜杠配置中/代表url根路径：（例如http://localhost:8080/dist/js/test.js中的http://localhost:8080/） devServer devServer.contentBase 告诉服务器从哪里提供内容。只有在你想要提供静态文件时才需要。 devServer.publicPath 将用于确定应该从哪里提供 bundle，并且此选项优先。 node中的路径文件结构：123456app/ -lib/ -common.js -model -task.js -test.js task.js 123456var path = require('path');console.log(__dirname); // console.log(__filename);console.log(process.cwd());console.log(path.resolve('./')); 在 model 目录下运行 node task.js 得到的输出是： 1234/Users/guo/Sites/learn/app/model/Users/guo/Sites/learn/app/model/task.js/Users/guo/Sites/learn/app/model/Users/guo/Sites/learn/app/model 在 app 目录下运行 node model/task.js，得到的输出是： 1234/Users/guo/Sites/learn/app/model/Users/guo/Sites/learn/app/model/task.js/Users/guo/Sites/learn/app/Users/guo/Sites/learn/app 绝对路径 __dirname: 总是返回被执行的 js 所在文件夹的绝对路径 __filename: 总是返回被执行的 js 的绝对路径 process.cwd(): 总是返回运行 node 命令时所在的文件夹的绝对路径 相对路径 ./ : 在 require() 中使用是跟 __dirname 的效果相同，不会因为启动脚本的目录不一样而改变，在其他情况下跟 process.cwd() 效果相同，是相对于启动脚本所在目录的路径。 ../ require的路径必须是相对于当前执行文件的,只有在 require() 时才使用相对路径(./, ../) 的写法，其他地方一律使用绝对路径，如下： 1234// 当前目录下path.dirname(__filename) + '/test.js';// 相邻目录下path.resolve(__dirname, '../lib/common.js');","tags":[]},{"title":"自己写 cli 提高工作效率","date":"2018-12-21T07:06:44.000Z","path":"2018/12/21/自己写 cli 提高工作效率/","text":"tags: [组件]categories: 前端工程化 cli 工具需要满足的需求 获得用户的输入，并且根据相应的输入，可以定制编程相应执行逻辑 模板代码有两种实现思路，一是采用代码生成，二是分离静态资源模板 使用包管理工具 项目需求 自动创建组件需要的目录 自动添加模版代码 添加组件 js 和 css 代码 推荐包commandercommander.js commander是目前很成熟的Node命令行交互接口实现工具，使用该工具可以很便捷很快速地实现第一点需求 git-clonegit-clone是一个很轻量的Node编写的git clone封装，可以很便捷很快速地从github上克隆执行项目模板。也就是说，我们将项目模板静态存储在github上，每当执行cli命令时，将其下载，这样我们就很轻松地得到了项目代码模板。另外，当需要改变项目模板代码时，只需要修改github上的项目代码就可以，cli工具无需修改 shelljsshelljs同样是一个很轻量的Node编写的系统命令封装，可以很便捷很快速地在Node代码中使用系统命令。在本例中，因为从github上下载的项目代码会带有.git文件，需要使用rm命令将其删除 chalk用于高亮终端打印出来的信息 request发送http请求的工具 初始化项目1234mkdir rc-newcd rc-newnpm init -yyarn add react 创建模板文件React 新建组件的方式有三种： 类组件：class.jsx 函数组件: functional.jsx 纯组件: pure-class.jsx 12345mkdir src cd srcmkdir templatecd templatetouch class.jsx functional.jsx pure-class.jsx 1234567891011// class.jsximport React, &#123; Component &#125; from 'react';// COMPONENT_NAME 是占位符class COMPONENT_NAME extends Component &#123; render() &#123; return &lt;div /&gt;; &#125;&#125;export default COMPONENT_NAME; 12345678import React from 'react';const COMPONENT_NAME = () =&gt; &#123; return &lt;div /&gt;;&#125;;export default COMPONENT_NAME; 12345678910import React, &#123; PureComponent &#125; from 'react';class COMPONENT_NAME extends PureComponent &#123; render() &#123; return &lt;div /&gt;; &#125;&#125;export default COMPONENT_NAME; 命令行工具1、package.json 设置入口文件123\"bin\": &#123; \"rc-new\": \"./src/index.js\" &#125;, 2、在 bin/index.js 顶部声明此文件需要调用 Node.js 执行1#!usr/bin/env/ node 3、命令行交互模块 commander.js1yarn add chalk commander prettier 1const program = require('commander') 执行打开命令行工具，进入当前开发文件夹,输入命令bin/index.js，即可以输出“my first cli” 我们如何像发布后一样，直接输node-cli命令就可以调用我们的主文件呢？ 在开发目录执行sudo npm link将模块链接到全局，如想去掉 link，执行sudo npm unlink","tags":[]},{"title":"webpack To V4 from V3","date":"2018-12-19T10:11:47.000Z","path":"2018/12/19/webpack To V4 from V3/","text":"tags: [组件]categories: 前端工程化 Node.jsNode.js &gt;= V6 Cliwebpack-cli 需要单独安装 插件许多插件需要更新到最新的可兼容版本 mode新特性用来区分环境1234module.exports = &#123; // ... mode: 'production',&#125; 或者通过命令行Cli命令：--mode production/--mode development 已移除|分离的插件prod 模式移除的插件123456789module.exports = &#123; // ... plugins: [- new NoEmitOnErrorsPlugin(),- new ModuleConcatenationPlugin(),- new DefinePlugin(&#123; \"process.env.NODE_ENV\": JSON.stringify(\"production\") &#125;)- new UglifyJsPlugin() ],&#125; dev 模式移除的插件123456module.exports = &#123; // ... plugins: [- new NamedModulesPlugin() ],&#125; 已经分离的插件1234567module.exports = &#123; // ... plugins: [- new NoErrorsPlugin(),- new NewWatchingPlugin() ],&#125; 再见 CommonsChunkPluginwebpack 4 Code Splitting 的 splitChunks 配置探索提取公共代码 webpack4.0 不再使用CommonsChunkPlugin，取而代之的是内置的 optimization.splitChunks ，默认的配置或许可以完全满足你的需求 1、commonchunk配置项被彻底去掉，之前需要通过配置两次 new webpack.optimize.CommonsChunkPlugin 来分别获取 vendor 和 manifest 的通用chunk方式已经做了整合， 直接在optimization中配置 runtimeChunk 和 splitChunks 即可 ，提取功能也更为强大2、runtimeChunk 可以配置成 true，single 或者对象，用自动计算当前构建的一些基础chunk信息，类似之前版本中的 manifest 信息获取方式。3、webpack.optimize.UglifyJsPlugin 现在也不需要了，只需要使用 optimization.minimize 为 true 就行，production mode下面自动为 true，当然如果想使用第三方的压缩插件也可以在 optimization.minimizer 的数组列表中进行配置 1234567891011121314151617181920212223242526module.exports = &#123; //... optimization: &#123; splitChunks: &#123; chunks: 'async', minSize: 30000, maxSize: 0, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', name: true, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125; &#125; &#125;&#125;; 再见 extract-text-webpack-plugin提取 JS 中的 CSS 代码到单独的文件中 webpack4.0 不再使用 extract-text-webpack-plugin，取而代之的是mini-css-extract-plugin 123456789101112131415161718192021222324252627// webpack.dev.jsconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");const devMode = process.env.NODE_ENV !== 'production'module.exports = &#123; plugins: [ new MiniCssExtractPlugin(&#123; // Options similar to the same options in webpackOptions.output // both options are optional filename: devMode ? '[name].css' : '[name].[hash].css', chunkFilename: devMode ? '[id].css' : '[id].[hash].css', &#125;) ], module: &#123; rules: [ &#123; test: /\\.(le|c)ss$/, use: [ devMode ? 'style-loader' : MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'less-loader', ], &#125; ] &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041// webpack.prod.jsconst UglifyJsPlugin = require(\"uglifyjs-webpack-plugin\");const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");const OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\");module.exports = &#123; optimization: &#123; minimizer: [ // we specify a custom UglifyJsPlugin here to get source maps in production new UglifyJsPlugin(&#123; cache: true, parallel: true, // 多线程 sourceMap: true // set to true if you want JS source maps &#125;), new OptimizeCSSAssetsPlugin(&#123; assetNameRegExp: /.css$/g, cssProcessor: require('cssnano'), cssProcessorOptions: &#123; safe: true, discardComments: &#123; removeAll: true &#125; &#125;, canPrint: false &#125;) ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: \"[name].css\", chunkFilename: \"[id].css\" &#125;) ], module: &#123; rules: [ &#123; test: /\\.(sa|sc|c)ss$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'less-loader', ], &#125; ] &#125;&#125; import() and CommonJS当通过 import() 导入 non-esm.js 的结果时，现在你需要通过 default 属性来获取 module.exports 的值 123456# non-esm.jsmodule.exports = &#123; sayHello: () =&gt; &#123; console.log('hello world'); &#125;&#125;; 123456# example.jscfunction sayHello() &#123; import('./non-esm.js').then(module =&gt; &#123; module.default.sayHello(); &#125;);&#125; json and loaders当用自定义的loader来转换 .json 文件时，需要添加 module.rules.type1234567891011module.exports = &#123; // ... rules: [ &#123; test: /config\\.json$/, loader: 'special-loader',+ type: 'javascript/auto', options: &#123;...&#125; &#125; ]&#125;; 如果使用 json-loader ，可以移除 123456789module.exports = &#123; // ... rules: [ &#123;- test: /\\.json$/,- loader: 'json-loader' &#125; ]&#125;; module.loadersmodule.loaders 已移除，被 module.rules 取代 参考资源更多插件请见 https://webpack.js.org/plugins/ 其他升级 NoEmitOnErrorsPlugin- &gt; optimization.noEmitOnErrors（默认情况下处于生产模式） ModuleConcatenationPlugin- &gt; optimization.concatenateModules（默认情况下处于生产模式） NamedModulesPlugin- &gt; optimization.namedModules（在开发模式下默认开启） webpack命令优化 -&gt; 发布了独立的 webpack-cli 命令行工具包 webpack-dev-server -&gt; 建议升级到最新版本 html-webpack-plugin -&gt; 建议升级到最新版本 file-loader -&gt; 建议升级到最新版本 url-loader -&gt; 建议升级到最新版本 报错信息","tags":[]},{"title":"VScode 插件工具集，不求全但求好","date":"2018-12-18T07:36:06.000Z","path":"2018/12/18/VScode 插件工具集，不求全但求好/","text":"更多插件可以到官网自行探索 根据调查发现，VScode 和 sublime 是前端开发者比较喜欢的 IDE 。“工欲善其事，必先利其器”，我是一个爱折腾的工具控，刚开始用 VScode 的时候，装了一堆的插件，导致只要开启 VScode 再接上大屏，我的 Mac 就会强烈的反抗，风扇一直呼啸，😳😳….后来就开启卸载模式，开始一直卸，最终保留一些小而美，使用率高的插件，整理一份以便不备之需。 而对于一个团队而言，大家用同一套快捷键，同一个IDE，同一套插件，那么结对编程将会是一件特别幸福的事情。和帅哥哥一起编程还是可以学到很多东西的，嘻嘻～～ 一、代码快捷键在 VScode 的首页可以设置通用快捷键，因为平常用sublime比较多，所以干脆合并成一套。 二、代码提示Path Intellisense自动路径补全 Document thisjs 的注释模板 （注意：新版的 vscode 已经原生支持,在 function 上输入 /** tab ） 三、代码格式ESlint代码规范，对不符合要求的代码或者有语法错误的JS代码进行提示，可以自定制提示规则 HTMLHinthtml代码检测 beautify格式化代码的工具 四、代码可视化改善colorize可视化颜色哦，做组件涉及很多不同的主题，个人还是蛮稀饭的 RegExp Preview and Editor这个就厉害了.可以完美的展示你写的正则,图形化给你看你写正则的形成 Better Comments最好用的注释区域高亮,对于TODO这些支持也很好 BreadCrumb in StatusBar 华丽丽的分割线，以下插件根据框架语言选择，用什么装什么，不用就不要装了，浪费内存 五、React 插件ES7 React/Redux/GraphQL/React-Native snippets涵盖的代码片段贼丰富，React 相关代码提示有这个就够了 Useful React Snippets当然如果你只用React,那用这个代码提示吧，管够了 CSS Blocks支持 css 模块化的智能提示，跳转，墙裂推荐 styled-components-snippetsstyled-components 的代码片段 六、Vue 插件vetur语法高亮、智能感知、Emmet 等 VueHelpersnippet 代码片段 Vue VSCode Snippets很全面的vue代码片段 七、Nodeeggjs蛋框的相关帮助插件,代码片段,智能提示等 egg-jump-definition蛋框的函数跳转：Cmd+4 八、微信小程序mpvue snippetsmpvue的一些代码片段,以及部分原生小程序的代码提示 minapp用VS Code写小程序必备的插件,里面有众多实用的特性集成 九、Markdown 插件Markdown All in OneMarkdown 的提示插件用这一个足以，集成了语法快捷键、Math、预览等，很实用 markdownlint对 markdown 的语法格式规范进行代码提示 十、代码审查CodeMetrics可以计算TS/JS内代码的复杂度(比如函数这些),这些与代码质量和性能是挂钩的 Import Cost就是你import一个东西的时候,可以计算改引入模块的大小! Git Lens暂时没有发现比这个看git记录更为详细了 十一、其他下面的插件可有可无，如有相应功能的需求，却也是非常棒的插件 fileheader顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间 ctrl+alt+i Paste JSON as CodeJSON 格式转换成其他的语言格式 Node.js Modules Intellisense对于 node_module 的智能提示 npm-import-package-version显示导入的 npm 包的版本信息 File Tree View提供几个常见编程语言的函数或状态的树集合展示,可以快速点击跳转!! NPM-Scripts在侧边栏可视化执行 npm 命令(项目内的package.json), 小巧实用 :emojisense: 十二、代码片段两种方式定义代码片段 菜单栏-&gt;文件-&gt;首选项-&gt;用户代码片段 ctrl+shift + p =&gt; snippet toRem: 只是一个单纯的描述 prefix: 是触发snippet的简写 body: 是展开的代码片段 \\$1,\\$2：表示占位符，用于用户展开代码片段所需要替换的，也可以写成\\${1:label}键值对的方式 description: 用户你在输出snippet之前，方便自己识别的注释，而不用强行记忆那些简写的","tags":[]},{"title":"package.json 的解读","date":"2018-12-17T07:09:31.000Z","path":"2018/12/17/package.json 的解读/","text":"tags: [组件]categories: 前端工程化 官方字段json 和 JS 对象的区别package.json，顾名思义，它是一个json文件，而不能写入JS对象。所以我们首先要搞懂的是JSON和JS对象的区别： 区别 Json Javascript对象 含义 仅仅是一种数据格式 表示类的实例 传输 可以跨平台数据传输，速度快 不能传输 表现 1、键值对方式，键必须加双引号 2、值不能是\b方法函数，不能是undefined|NaN 1、键值对方式，键不加引号 2、值可以是函数、对象、字符串、数字、boolean等 相互转换 Json转化为JS对象： 1、JSON.parse(jsonstring); 2、json=eval(“(“+jsonstring+”)”) JS对象转换为JSON: JSON.stringify(json) 【注意】 在JSON中属性名一定要加上双引号 name 字段name字段的限制 name字段必须小于214字符（这个没什么好记的～） name字段不能包含有“.”符号和下划线（这个要记一下哦～） name字段不能包含有大写字母（这个要记一下哦～） name字段不能含有非URL安全的字符，因为它将当发布的时候，它将作为你的包的相关信息被写入URL中 那么，有哪些算是非URL安全的字符呢？咱们看表说话： version 字段npm对version定义的规则要求对于”version”:”x.y.z”1.修复bug,小改动，增加z2.增加了新特性，但仍能向后兼容，增加y3.有很大的改动，无法向后兼容,增加x 例如：我原本的项目是1.0.0版本的话若是1中情况，变为1.0.1若是2中情况，变为1.1.0若是3中情况，变为2.0.0 npm 有自己的检验version的模块——node-semvernpm有自己的一套检验version正确性的模块，它叫做 node-semver，是一开始就跟随着npm一起被打包安装的。当然了，你也可以通过自己安装去在自己的项目中使用它。使用的例子像这样：先npm install –save semver然后: 123const semver = require('semver')semver.valid('1.2.3') // '1.2.3'semver.valid('a.b.c') // null keywords 和 description 字段字段要求：description：字符串keywords：字符串数组 简单地说，这两个东东是npm搜索系统中的搜索条件，所以。如果你试图发布的是一个开源插件，那么这两个字段你应该重视 license 字段这是你指定的项目的许可证，它告诉他人他们是否有权利使用你的包，以及，在使用你的包的时候他们应该受到怎样的限制 字段要求：单个license：直接写入名称 1&#123; \"license\" : \"BSD-3-Clause\" &#125; 多个license：在一对圆括号内写入license名称，且在多个license内用AND等连接 1&#123; \"license\" : \"(ISC AND GPL-3.0)\" &#125; SPDX license表达式的语法规则 2.0版本 author 字段要求：一个字符串或是一个对象。如果是一个对象，该对象包含三个属性：name属性(必填)email属性（选填）URL属性（选填） 1234&#123; \"name\" : \"Barney Rubble\", \"email\" : \"b@rubble.com\", \"url\" : \"http://barnyrubble.tumblr.com/\"&#125; main 字段这个是你项目的入口文件。简而言之，当别人安装了你发布的模块时，require你的模块的时候取得的就是你main字段规定的入口文件的输出。 例如你写入了 { “main”:”XXX.js”}，而他人通过npm install ‘你的模块名称’ . 安装了你的模块后，他通过 var X = require(‘你的模块名称’)取得的就是你在XXX.js的输出 script 字段写进scripts的命令(command),可以通过npm run 或者npm 运行对应的shell指令，例如：{“scripts”: { “start”: “node main.js”} } 可以让你在终端输入npm start的时候，等同于运行了node main.js 什么时候要加“run”,什么时候可以不用加“run”呢？一个让我们可能有些困扰的问题是，通过script字段内的npm命令运行脚本时，有时候要加“run”，有时候又不要加&quot;run&quot;,即有时候是可以直接用npm &lt;command&gt;；而有时候又要用npm run &lt;command&gt; 才能运行脚本，这该如何区分呢？ 首先要提一下的是，run的原名是run-script，是一段脚本，而run是它的一个别名（alias） 1.当run[-script]被 test, start, restart, and stop这四个自带的命令所使用时，它可以被省略（或者说不需要加“run”就可以直接调用），所以我们平时最常输入的npm start实际上相当于npm run start，只不过是为了方便省略了run而已 原文：run[-script] is used by the test, start, restart, and stop commands, but can be called directly 2.当你在package.json的script字段中定义的是除了1中的4个命令外的命令的时候，你就不能省略“run”了例如你定义 123\"scripts\": &#123; \"build\": \"XXX.js\"&#125; 的时候，你运行XXX.js就只能通过npm run build去运行了 npm 为script字段中的脚本路径都加上了node_moudles/.bin前缀npm为script字段中的脚本路径都加上了node_moudles/.bin前缀，这意味着：你在试图运行本地安装的依赖在 node_modules/.bin 中的脚本的时候，可以省略node_modules/.bin这个前缀。例如：我刚npm install webpack了，而在我的项目下的node_modules目录的.bin子目录下：就多了一个叫做webpack的脚本 本来运行这个脚本的命令应该是：node_modules/.bin webpack但由于npm已经自动帮我们加了node_modules/.bin前缀了，所以我们可以直接写成： 1\"scripts\": &#123;\"start\": \"webpack\"&#125; 而不用写成： 1\"scripts\": &#123;\"start\": \"node_modules/.bin webpack\"&#125; 原文：npm run adds node_modules/.bin to the PATH provided to scripts. Any binaries provided by locally-installed dependencies can be used without the node_modules/.bin prefix npm start是有默认值的，默认为：node server.js better-npm-run 的安装与betterScript字段的使用这个是package.json文档介绍里所没有的，但这里我想特别讲一下： 先通过npm install better-npm-run安装好包，然后你就可以在你的package.json里面使用一个新的字段—— “betterScripts”字段 故名思意，它和”scripts”字段很像，那么两者间有什么联系呢？咱还是用代码说话吧，它可以把 123\"scripts\": &#123; \"test\": \"NODE_ENV=production karma start\"&#125; 变成： 1234567891011\"scripts\": &#123; \"test\": \"better-npm-run test\"&#125;,\"betterScripts\": &#123; \"test\": &#123; \"command\": \"karma start\", \"env\": &#123; \"NODE_ENV\": \"test\" &#125; &#125;&#125; 简单地说，就是当运行”scripts”字段中的命令的时候，它会进一步去运行 “betterScripts”中对应的命令，并通过”env”对象控制运行时的环境变量，如NODE_ENV。 好处是让你的代码的可读性更强一些 另外提一下NODE_ENV的作用：用来设置环境变量（默认值为development）。通过检查这个值可以分别对开发环境和生产环境下做不同的处理 例如在服务端代码中通过检查是否是开发环境（development）决定是否启动代码热重载功能 （热重载只是为了在开发环境【developmen】提高生产效率用，在生产环境【production】没用） 123456if (process.env.NODE_ENV === 'development') &#123;// 省略诸多内容app.use(require('webpack-hot-middleware')(compiler, &#123; path: '/__webpack_hmr'&#125;))&#125; dependencies 字段和 devDependencies 字段dependencies字段和devDependencies字段分别代表生产环境依赖和开发环境依赖 与两个字段相关的npm install的命令npm install 模块 –save 安装好后写入package.json的dependencies中（生产环境依赖）npm install 模块 –save-dev 安装好后写入package.json的devDepencies中（开发环境依赖） 怎么区分到底安装包的时候放在dependencies中还是devDepencies中呢？ 很简单1.一般你去github或者npm社区里面相关包的介绍后面都会带有–save 或者–save-dev 的参数的，这时候把命令直接复制过来运行就OK了，不用管那么多 2.如果没有1中的介绍，那么请思考，这个包到底是纯粹为了开发方便使用呢？还是要放到上线后APP的代码中呢？前者则为devDepencies，后者则为dependencies 【注意】：在团队协作中，一个常见的情景是他人从github上clone你的项目，然后通过npm install安装必要的依赖，（刚从github上clone下来是没有node_modules的，需要安装）那么根据什么信息安装依赖呢？就是你的package.json中的dependencies和devDepencies。所以，在本地安装的同时，将依赖包的信息（要求的名称和版本）写入package.json中是很重要的！ prepublishOnly 字段1\"prepublishOnly\": \"npm run build\" 这样每次执行npm publish前都会先执行npm run build peerDependencies 字段同版本依赖 非官方字段yarn 相关字段yarn : 类似 npm 的依赖管理工具，但 yarn 缓存了每个下载过的包，所以再次使用时无需重复下载，同时利用并行下载以最大化资源利用率，因此安装速度更快。 flat123&#123; \"flat\": true&#125; 如果你的包只允许给定依赖的一个版本，你想强制和命令行上 yarn install –flat 相同的行为，把这个值设为 true。 详细参考 yarn - flat.. resolutions12345678&#123; \"resolutions\": &#123; \"transitive-package-1\": \"0.0.29\", \"transitive-package-2\": \"file:./local-forks/transitive-package-2\", \"dependencies-package-1/transitive-package-3\": \"^2.1.1\" &#125; &#125; 允许你覆盖特定嵌套依赖项的版本。有关完整规范，请参见选择性版本解析 RFC。 详细参考 yarn - resolutions. unpkg 相关字段unpkg: 让 npm 上所有的文件都开启 cdn 服务。 unpkg 1234# jquery&#123;\"unpkg\": \"dist/jquery.js\"&#125; 正常情况下，访问 jquery 的发布文件通过 https://unpkg.com/jquery@3.3.1/dist/jquery.js，当你使用省略的 url https://unpkg.com/jquery 时，便会按照如下的方式获取文件： [latestVersion] 指最新版本号，pkg 指 package.json 定义了 unpkg 属性时 https://unpkg.com/jquery@[latestVersion]/[pkg.unpkg] 未定义 unpkg 属性时，将回退到 main 属性 https://unpkg.com/jquery@[latestVersion]/[pkg.main]详细参考 https://unpkg.com. TypeScript 相关字段TypeScript: JavaScript 的超集types, typings1234&#123; \"main\": \"./lib/main.js\", \"types\": \"./lib/main.d.ts\"&#125; 就像 main 字段一样，定义一个针对 TypeScript 的入口文件。 详细参考 TypeScript documentation. browserslist 相关字段browserslist: 设置项目的浏览器兼容情况。browserslist 123456&#123;\"browserslist\": [\"&gt; 1%\",\"last 2 versions\"]&#125; 支持的工具： AutoprefixerBabelpostcss-preset-enveslint-plugin-compatstylelint-no-unsupported-browser-featurespostcss-normalize详细参考 browserslist. 发行打包相关字段点击 Setting up multi-platform npm packages 查看相关介绍。 module1234&#123;\"main\": \"./lib/main.js\",\"module\": \"./lib/main.m.js\"&#125; 就像 main 字段一样，定义一个针对 es6 模块及语法的入口文件。构建工具在构建项目的时候，如果发现了这个字段，会首先使用这个字段指向的文件，如果未定义，则回退到 main 字段指向的文件。 支持的工具： rollupwebpack详细参考 rollup - pkg.module. browser1234&#123; &quot;main&quot;: &quot;./lib/main.js&quot;, &quot;browser&quot;: &quot;./lib/main.b.js&quot;&#125; 指定该模块供浏览器使用的入口文件。如果这个字段未定义，则回退到 main 字段指向的文件。 支持的工具： rollupwebpackbrowserify详细参考 babel-plugin-module-resolver. esnext12345&#123;&quot;main&quot;: &quot;main.js&quot;,&quot;esnext&quot;: &quot;main-esnext.js&quot;&#125; 1234567&#123; \"main\": \"main.js\", \"esnext\": &#123; \"main\": \"main-esnext.js\", \"browser\": \"browser-specific-main-esnext.js\" &#125;&#125; 使用 es 模块化规范，stage 4 特性的源代码。详细参考 Transpiling dependencies with Babel, Delivering untranspiled source code via npm. es20151234&#123; \"main\": \"main.js\", \"es2015\": \"main-es2015.js\"&#125; Angular 定义的未转码的 es6 源码。详细参考 https://docs.google.com/document/d/1CZC2rcpxffTDfRDs6p1cfbmKNLA6x5O-NtkJglDaBVs/edit#. esm详细参考 adjusted proposal: ES module “esm”: true package.json flag. react-native 相关字段react-native: 使用 react 组件技术写原生APP。 react-native1234&#123; \"main\": \"./lib/main.js\", \"react-native\": \"./lib/main.react-native.js\"&#125; 指定该模块供 react-native 使用的入口文件。如果这个字段未定义，则回退到 main 字段指向的文件。 源代码查看. webpack 相关字段sideEffects123&#123; \"sideEffects\": true|false&#125; 声明该模块是否包含 sideEffects（副作用），从而可以为 tree-shaking 提供更大的优化空间。详细参考 sideEffects example, proposal for marking functions as pure, eslint-plugin-tree-shaking. microbundle 相关字段microbundle: 基于 rollup 零配置快速打包工具。 source123&#123; \"source\"： \"src/index.js\"&#125; 源文件入口文件。 详细参考 Specifying builds in package.json. umd:main1234&#123; \"umd:main\"： \"dist/main.umd.js\"&#125; umd 模式 bundle 文件。详细参考 Specifying builds in package.json. parcel 相关字段parcel: 零配置打包工具。 source查看 parcel-bundler/parcel#1652. babel 相关字段babel: es6 -&gt; es5 转码器。 babel配置 babel。 eslint 相关字段eslint: js 代码检查与优化。 eslintConfig配置 eslint。 jest 相关字段jest: js 测试库。 jest12345&#123; \"jest\": &#123; \"verbose\": true &#125;&#125; 配置 jest。详细参考 jest docs. stylelint 相关字段stylelint: style 代码检查与优化。 stylelint配置 stylelint。 详细参考 New configuration loader. ava 相关字段ava: js 测试库。 ava12345&#123; \"ava\": &#123; \"require\": [ \"@std/esm\" ] &#125;&#125; 配置 ava。详细参考 ava configuration. nyc 相关字段nyc: istanbul.js 命令行。 nyc123456&#123; \"nyc\": &#123; \"extension\": [\".js\", \".mjs\"], \"require\": [\"@std/esm\"] &#125;&#125; 配置 nyc。详细参考 nyc docs. CommonJS 保留字段保留字段: build, default, email, external, files, imports, maintainer, paths, platform, require, summary, test, using, downloads, uid. 不可用字段: id, type, 以 _ 和 \\$ 开头的字段。 Standard JS 相关字段Standard JS: js 代码检查与优化。 standard123456789101112&#123; \"standard\": &#123; \"parser\": \"babel-eslint\", \"ignore\": [ \"**/out/\", \"/lib/select2/\", \"/lib/ckeditor/\", \"tmp.js\" ] &#125;&#125; 配置 standard.详细参考 https://standardjs.com/. 其他style声明当前模块包含 style 部分，并指定入口文件。 支持的工具： parcelifynpm-lessrework-npmnpm-css详细参考 Package.json “style” Attribute, istf-spec. less与 style 一样，但是是 less 文件。 支持的工具： npm-less 更多参考 package.json fields explained 参考资源package.json 非官方字段集合官方字段文档：https://docs.npmjs.com/files/package.json","tags":[]},{"title":"Dbox 内部开源组件背后的故事","date":"2018-12-13T07:22:56.000Z","path":"2018/12/13/Dbox 内部开源组件背后的故事/","text":"download: 前端技术选型会 - IF-RCM ☎.pdf 前言已有组件 OR 自造组件？？？基础和灵活 VS 定制化和效率 垂直行业领域专业性组件 强主题风格组件 强交互组件 甚至是同款组件，不同配置 123&gt; 组件 -&gt; 通用组件 -&gt; 通用组件库 &gt; |-&gt; 业务组件 -&gt; 业务组件库 -&gt; 行业柱(n) -&gt; 组件平台 -&gt; 物料市场&gt; 自造组件我们得到了什么 规范 =》 体系 产品功能迭代 技术变更(UI 设计层可以不变) 人事变动、人才流失 沟通(跨部门的共通语言) 客户需求多样性 效能 团队成长 走出去的可能 什么样的产品需要组件赋能 量极大功能复杂 产品项目变动频繁，并发很多 产品间往往有较高的关联性 产品间存在共性 使用者具备很强的专业性 开放的趋势 设计体系组件纬度 Atoms原子。 为网页构成的基本元素。例如按钮，也可以为抽象的概念，例如字体、色调等。 Molecules分子。 由原子构成的简单UI组件。例如，表单标签，搜索框和按钮共同打造了一个搜索表单分子。 Organisms组织。 由原子及分子组成的相对复杂的UI构成物。 Templates模版。 将以上元素进行排版，显示设计的底层内容结构。 Pages页面。 将实际内容（图片、文章等）套件在特定模板，页面是模板的具体实例 统一的视觉风格和交互规范X 组件在 A 业务场景是一个交互，在 B 业务场景是另一个 UI 风格，这样就无法对 X 进行抽象，极大的增加了组件的构建成本。所以，设计组件之初，首先需要抽象和约定一套统一的视觉风格和交互规范。 足够的可扩展性组件在落地到实际项目中时，有各种不同的需求，默认的定制化并不能适用于任何的场景，只有具备良好拓展性的组件才能应用到不同的业务线，以“不变应万变” 一定的可控性组件封装有一定的不确定性，更多时候是在做几个方面的权衡，并且在业务不断变化中，可能还会面临一些调整和重构。将不确定性控制在一定范围内。 组件适用性检验源于业务，归于业务。确保产出可以快速的在实际场景中得到验证，快速试错。 通过开源的方式获取更多的反馈 通过内部项目落地迭代组件API 产出物 产品和技术结合最为紧密的部分 最为稳定及复用程度最高的部分 一份文档多人使用 开发者说明 设计体系规范 代码片段、工具函数 培训文档 社区化：灵活的沟通机制 前端体系代码规范 开发者说明 代码 review 工具检验 集成了 eslint、stylelint、git hook 的前端代码检查工具。 初始化 eslint/stylelint 配置文件 安装 eslint/stylelint 及其依赖到当前项目的 node_modules 里 挂载 git 钩子，在提交代码时进行强制校验 组件设计思路在UI层面视觉上的组件是一种产品形式，界限是“视觉可分”，但是在代码层面，也会存在“逻辑可分”，所以开发者开开发前应对业务场景进行分析，把控代码层的组件粒度。 什么情况下需要抽离组件 不能狭隘地认为只是为了复用（包括对于模块化的理解），认为只有一个地方用就没必要抽取封装为组件 组件化是对实现的__分层__，是更有效地代码组合方式 组件化是对资源的重组和优化，从而使项目__资源管理__更合理 组件化有利于__单元测试__ 组件化对__重构__较友好 组件封装原则高复用性 + 少组件 + 大组件 高复用性：对项目中所有Web页面的结构有清晰的把握，能准确提取样式或功能雷同的模块并将其封装成组件 少组件：当深层次的成员无需组件化时，可直接将外层的父元素组件化以减少组件的数量，该原则是基于开发效率考虑的 大组件：应更多的将零散组件拼装成更大的组件，可以简化组件的调用，提升团队开发效率 容器组件 + 展示组件 容器组件：处理数据、逻辑（数据格式化）；对接后端API，格式改变则改变该组件 展示组件：处理样式；对接视觉设计及用户体验，这些组件不关注自己何时何处被渲染 Functional Components应该最大限度的编写和使用 Functional Components : 无状态、无方法、纯组件 数据模型原则：对数据切分时，props的优先级要高于state，尽可能保证组件的无状态化，简化组件的交互逻辑 共享数据（固定数据）：props对象（单向流动性|显示传递性|只读性） &amp;&amp; store 私有数据（动态数据）：state对象 需要反复琢磨的问题Q1：这个组件可否（有必要）再分？ 组件划分的依据通常是 业务逻辑 功能，要考虑各组件之间的关系是否明确（如组件树方式管理组件间依赖关系，兄弟组件不可见），以及组件的可复用度。划分粒度的大小需要根据实际情况权衡，太小会提升维护成本，太大又不够灵活和高复用性。 每一个组件都应该有其独特的划分目的的，有的是为了复用实现，有的是为了封装复杂度清晰业务实现。 Q2：这个组件的依赖是否可再缩减？ 缩减组件依赖可以提高组件的可复用度，常用的方法是IoC（依赖注入），对外弱类型依赖。 Q3：这个组件是否对其它组件造成侵入？ 一个组件的封装性不够，或者自身越界操作，就可能对自身之外造成了侵入，这种情况应该尽量避免，确保组件的生命周期能够对其影响进行有效的管理（如destroy后不留痕迹）。较常见的一种情况是：组件运行时对window对象添加resize监听事件以实现组件响应视窗尺寸变化事件，这种需求的更好替代方案是：组件提供刷新方法，由父组件实现调用（最终由根组件统一处理）。 次优的方案是，当组件destroy前清理恢复。 一个组件不应对其它兄弟组件造成直接影响。 Q4：这个组件可否复用于其它类似场景中？ 需要考虑需要适用的不同场景，在组件接口设计时进行必要的兼容 Q5：这个组件当别人用时，会怎么想？ 接口设计符合规范和大众习惯，尽量让别人用起来简单易上手，易上手是指更符合直觉。假如业务需要不需要这个功能，是否方便清除？ 各组件之间以组合的关系互相配合，也是对功能需求的模块化抽象，当需求变化时可以将实现以模块粒度进行调整。 开发流程 组件初始化: 自动创建组件需要的目录和模版代码 组件 Coding 组件 Demo 组件文档 组件测试 开发者自测 UI 及 API 开发者互测API UI 人肉测试 开发者单元测试 测试流程开发者自测 UI 及 API开发者根据UI设计稿开发完成后，自己根据UI要求及文档分场景根据文档生产工具的 playground 完成自测。 ⚠️极端数据测试 数据为空时 数据接口调用错误时 请求参数极端情况 数据特别小时 数据特别大时 为null，NaN，undefine 开发者互测 API开发者团队内部通过结对编程的方式完成组件的API互测。 开发者单元测试 React 生态圈会推荐使用 jest + enzyme 配套工具 Jest是 Facebook 开发的一个测试框架，它集成了测试执行器、断言库、spy、mock、snapshot和测试覆盖率报告等功能。React 项目本身也是使用 Jest 进行单测的，因此它们俩的契合度相当高。但是使用 jest 做 UI 测试有局限性，只能测试基本的 dom 结构 和 样式，一些逻辑交互无法测到，只能覆盖大部分的情况。 Enzyme是由 airbnb 开发的 React 单测工具。它扩展了 React 的 TestUtils 并通过支持类似 jQuery 的 find 语法可以很方便的对 render出来的结果做各种断言。 UI 人肉测试开发团队测试流程全部走完后，提交到UI设计者测试流程，完成组件UI层面场景、视觉、交互的评审。 发包流程组件发包只有拥有发包权限的人才能操作，Dbox 是以组件库为单位发包的，使用命令 yarn publish 发包，在发包之前会跑组件测试，只有测试通过以后才能发包。 维护流程组件日常维护占整个组件库生命周期的很大一部分，组件库做起来了以后，组件功能后续会不断迭代，也许是 bug fix，也可能是 new feature。 PR / issue 的处理：PR规范 发包 管理 changelog 项目落地 UI组件 脚手架 使用文档 项目官网及社区 命令行 接口数据 mock 工具 构建工具栈 业务组件: 在业务组件库中，不必那么灵活，支持业务需要的属性配置即可。可以封装业务相关的代码进去，而不用担心影响其他业务线，更高的封装程度和业务属性会让该业务线的开发体验和效率提升一个量级 数据上报 监控体系(错误监控、性能监控、业务监控、服务监控) 持续集成: 部署流程和部署平台 自动化测试 后记组件化这条路上，我们还有很多事情要做 参考资源 教你用Sketch Libraries构建组件库/设计体系 - 优设-UISDC 重新设计 React 组件库 http://sangka-z.com/react-in-patterns-cn/chapter-11/ https://blog.csdn.net/liangklfang/article/details/74025364 https://github.com/penouc/blog/issues/7 React 组件设计模式基础 https://juejin.im/post/5a73d6435188257a6a789d0d 谈谈 Vue 业务组件 https://juejin.im/entry/5a97b8bc518825555b2e1845","tags":[{"name":"components","slug":"components","permalink":"http://lulustyle.net/tags/components/"}]},{"title":"大屏业务场景解决方案","date":"2018-12-13T04:36:21.000Z","path":"2018/12/13/大屏业务场景解决方案/","text":"tags: [组件]categories: 业务场景解决方案 无论是在科幻电影还是在真实世界里，可视化大屏都是非常常见的一种表现手法。之前在市局看到了大屏是由多个屏幕组成，看起来有两层楼那么高。 技术栈：echarts + css3 + vw + vh + rem因为运用了大量css3 新特性，所以建议使用 google浏览器，投大屏。 可视化大屏的特性可视化大屏，归根到底还是运用的可视化技术，只不过展现的屏幕比起笔记本和显示器大了很多。相比于传统的桌面级可视化运用，大屏可视化的特性有: 屏幕巨大，用户通常离屏幕比较远，文字表达出来的信息需要足够清楚，通常要在字体和颜色上做文章。 弱化交互，基于键盘和鼠标的交互方式很少，更多时候系统自己做出响应，而不是让人工介入。 视觉冲击力强，设计一般都是以深色为底色，一来科技感十足，二来可以配合突出的主体动画和强设计感的元素。 场景化，一块大屏通常用来展示一类场景，场景主要由图表构成，后台管理系统那套表单通常不会出现在大屏。 动画更重要了，用动画表现出来的数据，通常是大屏项目中最迷人的地方。说动画是大屏项目的灵魂也不为过。 大屏的自动布局和宽高自适应可视化大屏的布局部分也是一个重要的部分。在我们的项目中，准备使用纯css3的vw、vh实现自适应。 视口在CSS标准文档中，视口viewport被称为初始包含块。这个初始包含块是所有CSS百分比宽度推算的根源，它给CSS布局限制了一个最大宽度。 桌面端：视口的宽度和浏览器窗口的宽度一致 移动端 ：视口分为布局视口(layout viewport)、视觉视口(visual viewport)和理想视口(ideal viewport) 可视化大屏属于桌面 视口单位根据CSS3规范，视口单位主要包括4个： vw : 1vw 等于视口宽度的1% vh : 1vh 等于视口高度的1% vmin : 选取 vw 和 vh 中最小的那个 vmax : 选取 vw 和 vh 中最大的那个视口单位区别于%单位，视口单位是依赖于视口的尺寸，根据视口尺寸的百分比来定义的；而%单位则是依赖于元素的祖先元素。用视口单位度量，视口宽度为100vw，高度为100vh，相当于将宽高分别分成了100份。利用视口单位适配页面 vw、vh是基于视口的布局方案 rem布局-解决字体适配（rem布局原理：根据CSS的媒体查询功能，更改html根字体大小，实现字体大小随屏幕尺寸变化。） 使用vw+vh+rem的布局之外，可以再加上elementUI的栅格布局，可以满足需求。 协作 选择一种尺寸作为设计和开发基准 定义一套适配规则，自动适配剩下的两种尺寸(其实不仅这两种，你懂的) 特殊适配效果给出设计效果 参考资源终端设备参数)","tags":[]},{"title":"webpack 前端工程化","date":"2018-12-12T13:37:03.000Z","path":"2018/12/12/webpack 前端工程化/","text":"tags: [组件]categories: 前端工程化 一、webpack 常用 Loader1、加载文件 raw-loader：把文本文件的内容加载到代码中去，在 3-20加载SVG 中有介绍。 file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件，在 3-19加载图片、3-20加载 SVG、4-9 CDN 加速 中有介绍。 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去，在 3-19加载图片、3-20加载 SVG 中有介绍。 source-map-loader：加载额外的 Source Map 文件，以方便断点调试，在 3-21加载 Source Map 中有介绍。 svg-inline-loader：把压缩后的 SVG 内容注入到代码中，在 3-20加载 SVG 中有介绍。 node-loader：加载 Node.js 原生模块 .node 文件。 image-loader：加载并且压缩图片文件。 json-loader：加载 JSON 文件。 yaml-loader：加载 YAML 文件。 2、编译模版 pug-loader：把 Pug 模版转换成 JavaScript 函数返回。 handlebars-loader：把 Handlebars 模版编译成函数返回。 ejs-loader：把 EJS 模版编译成函数返回。 haml-loader：把 HAML 代码转换成 HTML。 markdown-loader：把 Markdown 文件转换成 HTML。 3、转换脚本语言 babel-loader：把 ES6 转换成 ES5，在3-1使用 ES6 语言中有介绍。 ts-loader：把 TypeScript 转换成 JavaScript，在3-2使用 TypeScript 语言中有遇到。 awesome-typescript-loader：把 TypeScript 转换成 JavaScript，性能要比 ts-loader 好。 coffee-loader：把 CoffeeScript 转换成 JavaScript。 4、转换样式文件 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性。 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。 sass-loader：把 SCSS/SASS 代码转换成 CSS，在3-4使用 SCSS 语言中有介绍。 postcss-loader：扩展 CSS 语法，使用下一代 CSS，在3-5使用 PostCSS中有介绍。 less-loader：把 Less 代码转换成 CSS 代码。 stylus-loader：把 Stylus 代码转换成 CSS 代码。 5、检查代码 eslint-loader：通过 ESLint 检查 JavaScript 代码，在 3-16检查代码中有介绍。 tslint-loader：通过 TSLint 检查 TypeScript 代码。 mocha-loader：加载 Mocha 测试用例代码。 coverjs-loader：计算测试覆盖率。 6、其它 vue-loader：加载 Vue.js 单文件组件，在3-7使用 Vue 框架中有介绍。 i18n-loader：加载多语言版本，支持国际化。 ignore-loader：忽略掉部分文件，在3-11构建同构应用中有介绍。 ui-component-loader：按需加载 UI 组件库，例如在使用 antd UI 组件库时，不会因为只用到了 Button 组件而打包进所有的组件。 二、webpack 常用 Plugin1、修改行为define-pluginhttps://webpack.js.org/plugins/define-plugin/定义环境变量 context-replacement-pluginhttps://webpack.js.org/plugins/context-replacement-plugin/修改 require 语句在寻找文件时的默认行为 ignore-pluginhttps://webpack.js.org/plugins/ignore-plugin/用于忽略部分文件 2、优化commons-chunk-plugin(V4.0移除，SplitChunksPlugin取代)https://webpack.js.org/plugins/commons-chunk-plugin/提取公共代码,避免webpack生成重复引入的模块代码，引入模块代码只生成一遍。注意该插件和DLL的功能不一样 提取公共代码对于多页面应用而言，提取公共代码： 减少网络传输流量，降低服务器成本 虽然用户第一次打开网站的速度得不到优化，但之后访问其他页面的速度将大大提高 extract-text-webpack-plugin(V4.0移除，mini-css-extract-plugin取代)https://github.com/webpack-contrib/extract-text-webpack-plugin提取 JS 中的 CSS 代码到单独的文件中 prepack-webpack-pluginhttps://github.com/gajus/prepack-webpack-plugin通过 Facebook 的 Prepack 优化输出的 JS 代码的性能：编译代码时提前将计算结果放到编译后的代码中，而不是在代码运行时才去求值 通过 Babel 将 JS 源码解析成 AST，以更细粒度分析源码 实现了一个 JS 解释器，用于执行源码。借助这个解释器，prepack 才能理解源码具体是如何执行的，并将执行过程中的结果返回到输出中 不能识别 DOM API 和 部分 Node.js API 代码在优化后性能可能更差 代码在优化后，文件的尺寸可能大大增加 现在用于线上环境还为时过早uglifyjs-webpack-pluginhttps://github.com/webpack-contrib/uglifyjs-webpack-plugin通过 UglifyJS 压缩 ES6 代码；V4.0 实例不放到 Plugin 中了，放到 optimization.minimizer 中去了参数： sourceMap: 默认不生成 beautify：是否输出可读性较强的代码，即保留空格和制表符。默认true comments: 是否保留代码中的注释。默认 true compress.warning: 是否在 uglifyJS 删除没用的代码时输出警告信息。默认 true drop_console: 是否删除代码中的所有 console 语句。默认 false collapse_vars: 是否内嵌已定义但是只用到一次的变量。默认true。 reduce_vars: 是否提取出现了多次但是没有定义成变量去引用的静态值 webpack-parallel-uglify-pluginhttps://github.com/gdborton/webpack-parallel-uglify-plugin多线程执行 UglifyJS 代码压缩，提升构建的速度，在生产环境使用使用时即不实用 UglifyJS ，直接用 ParalleUglifyPlugin，但是变成了并行执行 参数： test: 用正则匹配哪些文件需要被压缩，默认为/.js\\$/ include: 用正则命中需要被压缩的文件，默认为[] exclude: 用正则命中不需要被压缩的文件，默认为[] cacheDir: 用于配置缓存存放的目录路径，缓存压缩后的结果，下次遇到一样的输入时直接从缓存中获取压缩后的结果并返回。默认不缓存 workerCount: 开启几个子进程去并发执行压缩。默认为当前运行的 CPU 核数 -1 sourceMap: 会导致压缩过程变慢 uglifyJS: 传递给 uglifyJS 的参数 uglifyES: 传递给 uglifyES 的参数 12345678910111213141516171819202122232425262728const path = require('path')const DefinePlugin = require('webpack/lib/DefinePlugin')const ParalleUglifyPlugin = require('webpack-parallel-uglify-plugin')module.exports = &#123; plugins: [ // 使用 ParalleUglifyPlugin 并行压缩输出的 JS 代码 new ParalleUglifyPlugin(&#123; // 传递给 UglifyJS 的参数 uglifyJS: &#123; output: &#123; // 最紧凑的输出 beautify: false, // 删除所有注释 comments: false, &#125;, compress: &#123; // 在UglifyJS 删除没有用到的代码时不输出警告 warnings: false, // 删除所有的console语句，可以兼容IE浏览器 drop_console: true, &#125; &#125; &#125;) ]&#125; imagemin-webpack-pluginhttps://www.npmjs.com/package/imagemin-webpack-plugin压缩图片文件 webpack-spritesmithhttps://www.npmjs.com/package/webpack-spritesmith制作雪碧图 ModuleConcatenationPluginhttps://webpack.js.org/plugins/module-concatenation-plugin/开启 WebpackScopeHoisting 功能 dll-pluginhttps://webpack.js.org/plugins/dll-plugin/借助 DLL 的思想大幅度提升构建速度DLL：动态链接库，在一个动态链接库中可以包含为其他模块调用的函数和数据 将网页依赖的基础模块抽离出来，打包到一个个单独的动态链接库中。在一个动态链接库中可以包含多个模块 当需要导入的模块存在于某个动态链接库中时，这个模块不能被再次打包，而是去动态链接库中获取 页面依赖的所有动态链接库都需要被加载包含大量复用模块的动态链接库只需被编译一次，在之后的构建过程中被动态链接库包含的模块将不会重新编译，而是直接使用动态链接库中的代码。只要不升级这些模块的版本，动态链接库就不用重新编译 .dll： 包含了大量模块的代码，这些模块被存放在一个数组里，用数组的索引号作为ID，并且通过 _dll_react 变量将自己暴露在全局中，即可以通过 window._dll_react 访问到其中包含的模块 manifest.json: 用于描述在动态链接库文件中包含哪些模块，以及每个模块的路径和 IDDllReferencePlugin 用于在主要的配置文件中引入 DllPlugin 插件打包好的动态链接库文件1234567891011module.exports = &#123; plugins: [ // 这里的路径要和 webpack.dll.config.js 里面的对应。 new webpack.DllReferencePlugin(&#123; // 需要和webpack.dll.config.js中配置的context保持一致，用来指导webpack匹配manifest中库的路径 context: __dirname, // 用来引入webpack.dll.config.js中输出的manifest文件 manifest: path.resolve(__dirname, './dist/dll/vendors-manifest.json') &#125;), ]&#125; DllPlugin 用于打包出一个个单独的动态链接库文件123456789101112module.exports = &#123; plugins: [ new webpack.DllPlugin(&#123; // manifest文件的输出路径,[name]的部分由entry的名字替换 path: path.join(__dirname, 'dist/dll/[name]-manifest.json'), // 这里必须匹配上面的output.library中的值,dll暴露的对象名 name: library, // 解析包路径的上下文，这个要跟配置的dll user一致 context: __dirname &#125;), ]&#125; hot-module-replacement-pluginhttps://webpack.js.org/plugins/hot-module-replacement-plugin/开启模块热替换功能 其他插件serviceworker-webpack-pluginhttps://github.com/oliviertassinari/serviceworker-webpack-plugin为网页应用增加离线缓存功能 stylelint-webpack-pluginhttps://github.com/JaKXz/stylelint-webpack-plugin将stylelint集成到项目中 i18n-webpack-pluginhttps://github.com/webpack-contrib/i18n-webpack-plugin使网页支持国际化 provide-pluginhttps://webpack.js.org/plugins/provide-plugin/从环境中提供的全局变量中加载模块，而不用导入对应的文件 web-webpack-pluginhttps://github.com/gwuhaolin/web-webpack-plugin可方便地为单页应用输出HTML，比 html-webpack-plugin 好用 三、优化缩小文件搜索范围Loader 配置 test use include exclude cacheDirectory: babel 支持缓存转换出的结果12345678910module.exports = &#123; //... rules: [ &#123; test: /\\.(jsx|js)$/, use: 'babel-loader?cacheDirectory', exclude: path.resolve(__dirname, 'node_modules') &#125;, ]&#125; resolve.modules 配置配置Webpack去哪些目录下找第三方模块,默认是[‘node_modules’], 通过配置绝对路径减少搜索步骤 12345module.exports = &#123; resolve: &#123; modules: [path.resolve(__dirname, 'node_modules')] &#125;&#125; resolve.mainFields 配置用于配置第三方模块使用哪个入口文件；可用于不同的运行环境下使用不同的代码，例如在浏览器中通过原生的fetch 或者 XMLHttpRequest 实现，在 Node.js 中通过 http 模块实现 resolve.mainFields 的默认值和当前的 target 配置有关系 当 target 为 web 或者 webworker 时，值是[“browser”, “module”, “main”] 当 target 为其他情况时，值是 [“module”, “main”] 由于大多数第三方模块都采用 main 字段去描述入口文件的位置，所以可以通过配置 mainFields 字段为 main 值，减少搜索步骤，但是注意只要有一个模块出错，都可能会造成构建出的代码无法正常运行12345module.exports = &#123; resolve: &#123; mainFields: ['main'], &#125;&#125; resolve.alias 配置 通过配置alias 使得不同环境引用不同的代码，如react-native-web 的使用 由于webpack 默认会从第三方模块中的 package.json 中的指定入口文件递归解析和处理依赖文件，一般情况下该入口文件会定义成包含检查和警告的未被压缩的代码，但是直接使用单独、完整的min.js文件可以跳过耗时的递归解析操作1234567module.exports = &#123; resolve: &#123; alias: &#123; 'react': path.resolve(__dirname, './node_modules/react/dist/react.min.js') &#125;, &#125;&#125; resolve.extensions 配置 后缀尝试列表要尽可能小，不要将项目中不可能存在的情况写到后缀尝试列表中 频率出现最高的文件后缀要优先放在最前面，以做到尽快退出寻找过程 在源码中写导入语句时，要尽可能带上后缀，从而可以避免寻找过程 12345module.exports = &#123; resolve: &#123; extensions: ['js'], &#125;&#125; module.noParse 配置让 webpack 忽略对部分没采用模块化的文件的递归处理，如jQuery| react.min.js注意被忽略掉的文件里不应该包含 import | require | define 等模块化的语句，不然会导致在构建出的代码包含无法在浏览器环境下执行的模块化语句123456const path = require('path)module.exports = &#123; module: &#123; noParse: [/react\\.min\\.js$/], &#125;&#125; HappyPack将任务分解给多个子进程去并发执行，子进程处理完后再将结果发送给主进程。由于 JS 是单线程模型，所以要发挥多核 CPU 的功能，就只能通过多进程实现，而无法通过多线程实现。 接入 webpack 在 Loader 配置中，对所有文件的处理都交给 happypack/loader, 使用紧跟其后的 querystring ?id=babel 去告诉 happypack/loader 选择哪个 HappyPack 实例处理文件 在 Plugin 中新增了 HappyPack 实例，用于告诉 happypack/loader 如何处理 .js 和 .css 文件。选项中的 id 属性的值和上面 querystring 中的 ?id=babel 对应 id: loaders: 和原本Loader 配置中的一样 threads: 代表开启几个子进程去处理这一类型的文件，默认是 3 个，必须是整数 verbose: 是否允许 HappyPack 输出日志，默认是 true threadPool: 代表共享进程池，即多个 HappyPack 实例都使用同一个共享进程池中的子进程去处理任务，以防止资源占用过多。1npm i -D happypack 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const path = require('path');const HappyPack = require('happypack');module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.(jsx|js)$/, use: ['happypack/loader?id=babel'], // 将对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例 exclude: path.resolve(__dirname, 'node_modules') &#125;, &#123; test: /\\.(css|less)$/, use: ['happypack/loader?id=css'], exclude: path.resolve(__dirname, 'node_modules') &#125;, &#123; test: /\\.(png|svg|jpg|gif|webp|ico)$/, use: ['happypack/loader?id=file'], exclude: path.resolve(__dirname, 'node_modules') &#125;, &#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, use: ['happypack/loader?id=url'], include: path.resolve(__dirname, 'assets/fonts') &#125; ], plugins: [ new HappyPack(&#123; id: 'babel', loaders: ['babel-loader?cacheDirectory'], threadPool: happyThreadPool, &#125;), new HappyPack(&#123; id: 'css', loaders: ['style-loader', 'css-loader', 'less-loader'], threadPool: happyThreadPool, &#125;), new HappyPack(&#123; id: 'file', loaders: ['file-loader'], threadPool: happyThreadPool, &#125;), new HappyPack(&#123; id: 'url', loaders: ['url-loader'], threadPool: happyThreadPool, // 使用共享进程池中的子进程去处理任务 &#125;), ] &#125;&#125;; 优化文件监听1webpack --watch webpack-dev-server 默认开启文件监听在开启监听模式时，默认会监听配置的 Entry 文件和所有 Entry 递归依赖的文件，包括 node_modules 下的第三方模块。 12345module.exports = &#123; watchOptions: &#123; ignored: /node_modules/, &#125;&#125; 采用这种方法优化后，消耗的内存和 CPU 将会大大减少 watchOptions.aggregateTimeout 越大性能越好，能降低重新构建的频率 watchOptions.poll 越小越好，降低检查的频率同时注意这两个优化会导致监听模式反应和灵敏度降低 优化自动刷新自动刷新： 借助浏览器扩展去通过浏览器提供的接口刷新，如 WebStorm IDE 的 LiveEdit 功能 向要开发的网页中注入代理客户端代码，通过代理客户端去刷新整个页面 将要开发的网页装进一个 iframe 中，通过 刷新 iframe 去看到最新效果 devServer.inline : 用来控制是否向 Chunk 中注入代理客户端，默认注入。优化即关闭，从而只注入一个代理客户端，而非粗暴地为每个 chunk 都注入。 入口网址会变成 http://localhost:8080/webpack-dev-server bundle.js 中不再包含代理客户端的代码 模块热替换devServer 默认不开启 1webpack-dev-server --hot 热替换性能问题和自动刷新一样主要是因为需要监听文件的变化和注入客户端：忽略 node_modules Update module 优化1234567const NamedModulesPlugin = require('webpack/lib/NamedModulesPlugin')module.exports = &#123; plugins: [ // 显示出被替换模块的名称 new NamedModulesPlugin(), ]&#125; 压缩 CSScss-loader 内置了 cssnano，只需开启 css-loader 的 minimize 选项1use: ['css-loader?minimize'] CDN 加速内容分发网络：通过将资源部署到世界各地，使用户在访问时按照仅仅原则从离其最近的服务器获取资源，来加快资源的获取速度。通过优化物理链路层传输过程中的光速有限、丢包等问题来提升网速。 针对 HTML 文件：不开启缓存，将 HTML 放到自己的服务器上，而不是 CDN 服务器上，同时关闭自己服务器上的缓存。自己的服务器只提供 HTML 文件和数据接口 针对静态的 JS 、CSS、图片等文件：开启 CDN 和缓存，上传到 CDN 服务上，同时为每个文件名带上由文件内容算出的 Hash 值。 更改 HTML 中引入静态文件的资源引入地址为CDN 服务的 URL 地址 “//cdn.com/id/app_a6976b6d.css” 这样的 URL 省略了 http：或者 http：前缀，这样做在访问这些资源时会自动根据当前 HTML 的 URL 采用了什么模式去决定是采用 HTTP 还是 HTTPS 模式 浏览器规则：在同一时刻针对同一个域名资源的并行请求有限制(大概4个左右)，则会导致资源的加载被阻塞。可以将这些静态资源分散到不同的 CDN 服务上 用多个域名后会带来一个新问题：增加域名解析时间，对于是否采用多域名分散资源，需要根据自己的需求去衡量得失 webpack 实现 CDN 的接入 静态资源导入 URL 需要变成指向 CDN 服务的绝对路径的 URL，而不是相对于 HTML 文件的 URL 静态资源的文件名需要带上由文件内容算出来的 Hash 值，以防止被缓存 将不同类型的资源放到不同域名的 CDN 服务上，以防止资源的并行加载被阻塞 在 output.publicPath 中设置 JS 的地址 在 css-loader.publicPath 中设置被 CSS 导入的资源的地址 在 WebPlugin.stylePublicPath 中设置 CSS 文件的地址12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const path = require(&apos;path&apos;);const HappyPack = require(&apos;happypack&apos;);const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);module.exports = &#123; // ... output: &#123; filename: &apos;[name]_[chunkhash:8].js&apos;, // 为输出的 JS 加上 Hash 值 path: path.resolve(__dirname, &apos;./dist&apos;), publicPath: &apos;//js.cdn.com/id/&apos;, // 指定存放 JS 文件的 CDN 目录 URL &#125;, module: &#123; rules: [ &#123; test: /\\.(jsx|js)$/, use: [&apos;happypack/loader?id=babel&apos;], // 将对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例 exclude: path.resolve(__dirname, &apos;node_modules&apos;) &#125;, &#123; test: /\\.(css|less)$/, use: [&apos;happypack/loader?id=css&apos;], exclude: path.resolve(__dirname, &apos;node_modules&apos;) &#125;, &#123; test: /\\.(png|svg|jpg|gif|webp|ico)$/, use: [&apos;happypack/loader?id=file&apos;], exclude: path.resolve(__dirname, &apos;node_modules&apos;) &#125;, &#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, use: [&apos;happypack/loader?id=url&apos;], include: path.resolve(__dirname, &apos;assets/fonts&apos;) &#125; ], plugins: [ new HappyPack(&#123; id: &apos;babel&apos;, loaders: [&apos;babel-loader?cacheDirectory&apos;] &#125;), new HappyPack(&#123; id: &apos;css&apos;, loaders: [&apos;style-loader&apos;, &apos;css-loader?minimizer&apos;, &apos;less-loader&apos;] &#125;), new HappyPack(&#123; id: &apos;file&apos;, loaders: [&apos;file-loader?name=[name]_[hash:8].[ext]&apos;] // 为输出的图片名加上 Hash 值 &#125;), new HappyPack(&#123; id: &apos;url&apos;, loaders: [&apos;url-loader&apos;] &#125;), new ExtractTextPlugin(&#123; filename: &apos;[name]_[contenthash:8].css&apos;, // 为输出的 CSS 文件名加上 Hash 值 publicPath: &apos;//img.cdn.com/id/&apos;, // 指定存放 CSS 中导入的资源(例如图片)的 CDN 目录 URL &#125;) ] &#125;&#125;; Tree Shaking 剔除 JS 中用不上的死代码，依赖静态的 ES6 模块化语法，如果采用了 ES5 则 webpack 无法分析出可以剔除哪些代码 接入 Tree Shaking 需要配置 Babel 以让其保留 ES6 模块化语句.babelrc12345&#123; \"presets\": [\"env\", &#123; \"modules\": false // 关闭 Babel 的模块转换功能，保留原本的ES6模块化语法 &#125;],&#125; 大部分 NPM 库都会提供两份代码，一份用 CommonJS 模块化语法，一份用 ES6 模块化语法，并在 package.json 中分别指出这两份代码的入口：1234&#123; \"main\": \"lib/index.js\", // 指明采用 CommonJS 模块化的代码入口 \"jsnext:main\": \"es/index.js\" // 指明采用 ES6 模块化的代码入口,社区约定；也有一些模块叫“module”&#125; 配置 webpack 的文件寻找规则123456module.exports = &#123; resolve: &#123; // 针对 NPM 中的第三方模块优先采用 jsnext:main 中指向的 ES6 模块化语法的文件 mainFields: [&apos;jsnext:main&apos;, &apos;browser&apos;, &apos;main&apos;] &#125;&#125; Scope Hoisting 分析模块之间的依赖关系，尽可能将被打散的模块合并到一个函数中，但前提是不能造成代码冗余。因此只有那些被引用了一次的模块才能被合并 代码体积更小，因为函数申明语句会产生大量的代码 代码在运行时因为创建的函数作用域变少了，所以内存开销也变小了 对于非 ES6 模块化语法的代码，会自动降级处理，可以在启动时加上 –display-optimization-bailout 在控制台输出降级日志 123456789const ModuleConcatnationPlugin = require('webpack/lib/optimize/ModuleConcatnationPlugin');module.exports = &#123; resolve: &#123; mainFields: ['jsnext:main', 'browser', 'main'] // Scope Hoisting 依赖 ES6 模块化语法 plugins: [ new ModuleConcatnationPlugin(), // 开启 Scope Hoisting ]&#125; 分割代码以按需加载按需加载：用户当前需要用什么功能就只加载这个功能对应的代码，而不是加载所有功能对应的代码 为 SPA 做按需优化时： 将整个网站划分成一个个小功能，再按照每个功能的相关程度分成几类 将每类合并为一个 Chunk，按需加载对应的 Chunk 不要按需加载首页所对应的功能，将其放到执行入口所在的 Chunk 中，以减少用户能感知的网页加载时间 对于不依赖大量代码的功能点，例如依赖 Chart.js 去画图表、依赖 flv.js 去播放视频的功能点，可再对其进行按需加载 被分割出去的代码的加载需要一定的时机去触发，即当用户操作到了或者即将操作到对应功能时再去加载对应的代码。被分割出去的代码的加载时机需要开发者根据网页的需求去衡量和确定 分割代码按需加载ReactRouter的案例 .babelrc 123456789&#123; \"presets\": [ \"env\", \"react\" ], \"plugins\": [ \"syntax-dynamic-import\" ]&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// main.jsimport React, &#123;PureComponent, createElement&#125; from 'react';import &#123;render&#125; from 'react-dom';import &#123;HashRouter, Route, Link&#125; from 'react-router-dom';import PageHome from './pages/home';/** * 异步加载组件 * @param load 组件加载函数，load 函数会返回一个 Promise，在文件加载完成时 resolve * @returns &#123;AsyncComponent&#125; 返回一个高阶组件用于封装需要异步加载的组件 */function getAsyncComponent(load) &#123; return class AsyncComponent extends PureComponent &#123; componentDidMount() &#123; // 在高阶组件 DidMount 时才去执行网络加载步骤 load().then((&#123;default: component&#125;) =&gt; &#123; // 代码加载成功，获取到了代码导出的值，调用 setState 通知高阶组件重新渲染子组件 this.setState(&#123; component, &#125;) &#125;); &#125; render() &#123; const &#123;component&#125; = this.state || &#123;&#125;; // component 是 React.Component 类型，需要通过 React.createElement 生产一个组件实例 return component ? createElement(component) : null; &#125; &#125;&#125;// 根组件function App() &#123; return ( &lt;HashRouter&gt; &lt;div&gt; &lt;nav&gt; &lt;Link to='/'&gt;Home&lt;/Link&gt; | &lt;Link to='/about'&gt;About&lt;/Link&gt; | &lt;Link to='/login'&gt;Login&lt;/Link&gt; &lt;/nav&gt; &lt;hr/&gt; &lt;Route exact path='/' component=&#123;PageHome&#125;/&gt; &lt;Route path='/about' component=&#123;getAsyncComponent( // 异步加载函数，异步地加载 PageAbout 组件 () =&gt; import(/* webpackChunkName: 'page-about' */'./pages/about') )&#125; /&gt; &lt;Route path='/login' component=&#123;getAsyncComponent( // 异步加载函数，异步地加载 PageAbout 组件 () =&gt; import(/* webpackChunkName: 'page-login' */'./pages/login') )&#125; /&gt; &lt;/div&gt; &lt;/HashRouter&gt; )&#125;// 渲染根组件render(&lt;App/&gt;, window.document.getElementById('app')); 123456// pages/home/index.jsimport React from 'react';export default function PageHome() &#123; return &lt;div&gt;Page Home&lt;/div&gt;&#125; 123456// pages/about/index.jsimport React from 'react';export default function PageAbout() &#123; return &lt;div&gt;Page About&lt;/div&gt;&#125; 123456// pages/login/index.jsimport React from 'react';export default function PageLogin() &#123; return &lt;div&gt;Page Login&lt;/div&gt;&#125; 可视化分析工具1webpack --profile --json webpack analyse(官方) Modules: 展示所有模块，每个模块对应一个文件，且包含所有模块之间的依赖关系图、模块路径、模块ID、模块所属的 Chunk、模块的大小 Chunks: 展示所有代码块，在一个代码块中包含多个模块，并且包含代码块的 ID、名称、大小，每个代码块包含的模块数量，以及代码块之间的依赖关系图 Assets: 展示所有输出的文件资源，包括JS、CSS、图片等，并且包括文件名称、大小及该文件来自哪个代码块 Warning: 展示构建过程中出现的所有警告信息 Errors: 展示构建过程中出现的所有错误信息 Hints：展示处理每个模块所耗费的时间webpack-bundle-analyzer 没有官方的那么多功能，但更直观 打包出的文件中都包含什么 每个文件的尺寸在总体中的占比，一眼看出哪些文件的尺寸大 模块之间的包含关系 每个文件的 Gzip 后的大小 推荐配置最优构建速度123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293const path = require('path');const CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');const &#123;AutoWebPlugin&#125; = require('web-webpack-plugin');const HappyPack = require('happypack');// 自动寻找 pages 目录下的所有目录，把每一个目录看成一个单页应用const autoWebPlugin = new AutoWebPlugin('./src/pages', &#123; // HTML 模版文件所在的文件路径 template: './template.html', // 提取出所有页面公共的代码 commonsChunk: &#123; // 提取出公共代码 Chunk 的名称 name: 'common', &#125;,&#125;);module.exports = &#123; // AutoWebPlugin 会找为寻找到的所有单页应用，生成对应的入口配置， // autoWebPlugin.entry 方法可以获取到生成入口配置 entry: autoWebPlugin.entry(&#123; // 这里可以加入你额外需要的 Chunk 入口 base: './src/base.js', &#125;), output: &#123; filename: '[name].js', &#125;, resolve: &#123; // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤 // 其中 __dirname 表示当前工作目录，也就是项目根目录 modules: [path.resolve(__dirname, 'node_modules')], // 只采用 main 字段作为入口文件描述字段，以减少搜索步骤 mainFields: ['jsnext:main', 'main'], &#125;, module: &#123; rules: [ &#123; // 如果项目源码中只有 js 文件就不要写成 /\\.jsx?$/，提升正则表达式性能 test: /\\.js$/, use: ['happypack/loader?id=babel'], // 只对项目根目录下的 src 目录中的文件采用 babel-loader include: path.resolve(__dirname, 'src'), &#125;, &#123; test: /\\.js$/, use: ['happypack/loader?id=ui-component'], include: path.resolve(__dirname, 'src'), &#125;, &#123; // 增加对 CSS 文件的支持 test: /\\.css/, // 提取出 Chunk 中的 CSS 代码到单独的文件中 use: ['happypack/loader?id=css'], &#125;, ] &#125;, plugins: [ autoWebPlugin, // 使用HappyPack new HappyPack(&#123; id: 'babel', // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启 loaders: ['babel-loader?cacheDirectory'], &#125;), new HappyPack(&#123; // UI 组件加载拆分 id: 'ui-component', loaders: [&#123; loader: 'ui-component-loader', options: &#123; lib: 'antd', style: 'style/index.css', camel2: '-' &#125; &#125;], &#125;), new HappyPack(&#123; id: 'css', // 如何处理 .css 文件，用法和 Loader 配置中一样 loaders: ['style-loader', 'css-loader'], &#125;), // 4-11提取公共代码 new CommonsChunkPlugin(&#123; // 从 common 和 base 两个现成的 Chunk 中提取公共的部分 chunks: ['common', 'base'], // 把公共的部分放到 base 中 name: 'base' &#125;), ], watchOptions: &#123; // 4-5使用自动刷新：不监听的 node_modules 目录下的文件 ignored: /node_modules/, &#125;&#125;; 最佳质量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139const path = require('path');const DefinePlugin = require('webpack/lib/DefinePlugin');const ModuleConcatenationPlugin = require('webpack/lib/optimize/ModuleConcatenationPlugin');const CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');const &#123;AutoWebPlugin&#125; = require('web-webpack-plugin');const HappyPack = require('happypack');const ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin');// 自动寻找 pages 目录下的所有目录，把每一个目录看成一个单页应用const autoWebPlugin = new AutoWebPlugin('./src/pages', &#123; // HTML 模版文件所在的文件路径 template: './template.html', // 提取出所有页面公共的代码 commonsChunk: &#123; // 提取出公共代码 Chunk 的名称 name: 'common', &#125;, // 指定存放 CSS 文件的 CDN 目录 URL stylePublicPath: '//css.cdn.com/id/',&#125;);module.exports = &#123; // AutoWebPlugin 会找为寻找到的所有单页应用，生成对应的入口配置， // autoWebPlugin.entry 方法可以获取到生成入口配置 entry: autoWebPlugin.entry(&#123; // 这里可以加入你额外需要的 Chunk 入口 base: './src/base.js', &#125;), output: &#123; // 给输出的文件名称加上 hash 值 filename: '[name]_[chunkhash:8].js', path: path.resolve(__dirname, './dist'), // 指定存放 JavaScript 文件的 CDN 目录 URL publicPath: '//js.cdn.com/id/', &#125;, resolve: &#123; // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤 // 其中 __dirname 表示当前工作目录，也就是项目根目录 modules: [path.resolve(__dirname, 'node_modules')], // 只采用 main 字段作为入口文件描述字段，以减少搜索步骤 mainFields: ['jsnext:main', 'main'], &#125;, module: &#123; rules: [ &#123; // 如果项目源码中只有 js 文件就不要写成 /\\.jsx?$/，提升正则表达式性能 test: /\\.js$/, use: ['happypack/loader?id=babel'], // 只对项目根目录下的 src 目录中的文件采用 babel-loader include: path.resolve(__dirname, 'src'), &#125;, &#123; test: /\\.js$/, use: ['happypack/loader?id=ui-component'], include: path.resolve(__dirname, 'src'), &#125;, &#123; // 增加对 CSS 文件的支持 test: /\\.css/, // 提取出 Chunk 中的 CSS 代码到单独的文件中 use: ExtractTextPlugin.extract(&#123; use: ['happypack/loader?id=css'], // 指定存放 CSS 中导入的资源（例如图片）的 CDN 目录 URL publicPath: '//img.cdn.com/id/' &#125;), &#125;, ] &#125;, plugins: [ autoWebPlugin, // 4-14开启ScopeHoisting new ModuleConcatenationPlugin(), // 4-3使用HappyPack new HappyPack(&#123; // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件 id: 'babel', // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启 loaders: ['babel-loader?cacheDirectory'], &#125;), new HappyPack(&#123; // UI 组件加载拆分 id: 'ui-component', loaders: [&#123; loader: 'ui-component-loader', options: &#123; lib: 'antd', style: 'style/index.css', camel2: '-' &#125; &#125;], &#125;), new HappyPack(&#123; id: 'css', // 如何处理 .css 文件，用法和 Loader 配置中一样 // 通过 minimize 选项压缩 CSS 代码 loaders: ['css-loader?minimize'], &#125;), new ExtractTextPlugin(&#123; // 给输出的 CSS 文件名称加上 hash 值 filename: `[name]_[contenthash:8].css`, &#125;), // 4-11提取公共代码 new CommonsChunkPlugin(&#123; // 从 common 和 base 两个现成的 Chunk 中提取公共的部分 chunks: ['common', 'base'], // 把公共的部分放到 base 中 name: 'base' &#125;), new DefinePlugin(&#123; // 定义 NODE_ENV 环境变量为 production 去除 react 代码中的开发时才需要的部分 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125; &#125;), // 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码 new ParallelUglifyPlugin(&#123; // 传递给 UglifyJS 的参数 uglifyJS: &#123; output: &#123; // 最紧凑的输出 beautify: false, // 删除所有的注释 comments: false, &#125;, compress: &#123; // 在UglifyJs删除没有用到的代码时不输出警告 warnings: false, // 删除所有的 `console` 语句，可以兼容ie浏览器 drop_console: true, // 内嵌定义了但是只用到一次的变量 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125; &#125;, &#125;), ]&#125;; 参考资源《深入浅出 webpack》https://github.com/gwuhaolin/dive-into-webpackwebpack-demos/webpack.config.js at master · dongyuanxin/webpack-demos","tags":[]},{"title":"关于开源组件","date":"2018-12-12T13:27:18.000Z","path":"2018/12/12/关于开源组件/","text":"实战React业务组件库 · 语雀","tags":[]},{"title":"Function Programming","date":"2018-12-12T12:13:32.000Z","path":"2018/12/12/Function Programming/","text":"解决什么问题人工智能、区块链、AR、VR、新零售等业务场景的出现，产品界面交互正在变得越来越复杂，需要快速、正确、高效地开发出高复杂度页面。 FP 有什么特点JS 语言中的函数不同于 Java ，C/C++ 等语言, 可以被当做参数和返回值进行传递 函数为一等公民 模块化、组合 引用透明 避免状态改变 避免共享状态 案例分别实现数组所有元素相加、相乘、相与？非 FP 风格123456789101112131415161718192021222324function plus(array) &#123; var res = array[0]; for (let i = 1; i &lt; array.length; i++) &#123; res += array[i]; &#125;&#125;function mul(array) &#123; var res = array[0]; for (let i = 1; i &lt; array.length; i++) &#123; res *= array[i]; &#125;&#125;function and (array) &#123; var res = array[0]; for (let i = 1; i &lt; array.length; i++) &#123; res = res &amp; array[i]; &#125;&#125;plus(array);mul(array);and(array); FP 风格12345678910111213var ops = &#123; \"plus\": (x,y)=&gt;x+y, \"mul\" : (x,y)=&gt;x*y, \"and\" : (x,y)=&gt;x&amp;y&#125;function operation(op, array) &#123; return array.slice(1).reduce(ops[op], array[0]);&#125; operation(\"plus\", array);operation(\"mul\", array);operation(\"and\", array); React 的 FPReact 框架中，当用户操作 UI 或者 API 的返回带来了数据的改变，React 随即进行 virtual dom diff 计算得到 dom 的修改指令，对 dom 元素应用修改指令便得到最新的 html 界面，如下图所示： 不难发现，React 其实是应用数据对UI的一种映射，不同的数据会映射出不同样式的 UI 界面，我们可以得出如下的表达式： 没错，React 的本质其实是一种函数，并且还是符合 FP 要求的“引用透明”函数。所谓“引用透明”就是指函数的输出仅依赖函数参数，不受任何外部环境影响。这样的函数可测试性强，也非常容易进行组合。 在 React 的体系下，任何组件都可由一个个更小的组件构成，每个组件都只关心自己的输入，他们不断地接受新的数据并输出对应的新的UI界面。React 框架中常用的“高阶组件”可以看作引用透明”函数的组合模式。 在具体业务中我们通常还需要权衡 React 组件的复用性和开发体验，如果组件被拆分的过于细，固然复用性会提升，但文件数量会增加，对应的文档和沟通成本也会增加，这也是 FP 在实践过程中经常遭人诟病的点，即复用性提升后带来的额外开发成本。","tags":[]},{"title":"不想当架构师的前端不是一名好前端","date":"2018-12-08T12:52:10.000Z","path":"2018/12/08/不想当架构师的前端不是一名好前端/","text":"架构师能力模型团队管理能力在线运维能力 项目管理能力性能优化能力 架构能力编程能力 调试能力 编译部署能力","tags":[]},{"title":"博客搭建","date":"2018-12-08T12:48:16.000Z","path":"2018/12/08/博客搭建/","text":"前言语雀 是一款非常好用的知识管理网站（类似 GitBook)，它的编辑器非常好用，而且支持导出 Markdown，这篇文章是教你如何使用语雀的编辑器写静态博客。这里的静态博客用了 Hexo，Jekyll 也是没有问题的。 创建 Hexo 博客已经有 Hexo 博客的可以跳过。如果你是 Jekyll ，也可以跳过。 安装 Node.js 安装 Hexo 脚手架 1npm install -g hexo-cli 初始化一个博客 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 其他设置和命令见：https://hexo.io/zh-cn/docs/ 安装语雀文章下载插件yuque-hexo 是一个 Node.js 环境下的语雀下载器，使用 npm 安装 安装 yuque-hexo 1npm i -g yuque-hexo 注册语雀，创建知识库，获得你的个人路径和知识库的名字，比如我的博客的知识库是 https://www.yuque.com/page/luan.ma 在 Hexo 博客的目录下面的 package.json 中，进行下面的配置 12345678910&#123; \"name\": \"your hexo project\", //如果原来已经有这个不用再加了，直接加下面的就可以 \"yuqueConfig\": &#123; \"baseUrl\": \"https://www.yuque.com/api/v2\", \"login\": \"page\", \"repo\": \"luan.ma\", \"mdNameFormat\": \"slug\", \"postPath\": \"source/_posts/yuque\" &#125;&#125; 如果不是 Hexo 博客，则需要按照上面的文件保存一个 package.json 到博客目录，并且配置 postPath 为正确的文章目录 同步文章1yuque-hexo sync PS: 插件支持 Front-matter，在语雀写文章的时候直接写在前面，然后插入一条分割线即可，不写也没问题：123tags: [Hexo]categories: 教程date: 2018-10-05 10:43:50 启动/部署 Hexo 博客 本地启动（调试用） 1hexo s 生成 html 不部署 1hexo g 自动上传到服务器/静态空间/git （部署） 先找到一个部署插件 在配置文件中配置好相关的账号密码 在 hexo 中生成 HTML 并且部署1hexo g -d 静态博客空间选择 Github Pages： 方便，不太稳定，Git部署 Coding.net Pages： 需要挂一个链接 或者 付费，速度尚可，Git部署 腾讯云 COS + 腾讯云 CDN：需要备案，速度极快，COS 插件部署 自有服务器：可定制，速度一般 ，支持多种方式部署 后记核心是把 yuque-hexo 这个东西介绍给大家，本博客目前也是使用这个方案同步语雀的文章。 当然，关于 Hexo 皮肤、评论插件等等玩法也要折腾很久，我就不在这篇文章里面说了。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://lulustyle.net/tags/Hexo/"}]}]